C251 COMPILER V5.54.0.0,  AppHostComm                                                      26/05/17  20:21:05  PAGE 1   


C251 COMPILER V5.54.0.0, COMPILATION OF MODULE AppHostComm
OBJECT MODULE PLACED IN ..\output\obj\AppHostComm.obj
COMPILER INVOKED BY: D:\software\Keil\C251\BIN\C251.EXE ..\..\src\source\app\AppHostComm.c SMALL ROM(HUGE) OPTIMIZE(9,SP
                    -EED) REGFILE(..\output\obj\mcu.ORC) BROWSE INCDIR(..\..\src\include;..\..\src\include\app;..\..\src\include\flow;..\..\s
                    -rc\include\driver\;..\..\src\include\lib_drv\;..\..\src\include\config;..\..\src\include\Debug) DEFINE(__FT8836__) DEBUG
                    - PRINT(..\output\list\AppHostComm.lst) TABS(2) OBJECT(..\output\obj\AppHostComm.obj) 

stmt  level    source

    1          /*******************************************************************************
    2          * Copyright (C) 2012-2013, FocalTech Systems (R)，All Rights Reserved.
    3          *
    4          * File Name: AppHostComm.c
    5          *
    6          *    Author:
    7          *
    8          *   Created: 2016-12-26
    9          *
   10          *  Abstract:
   11          *
   12          * Reference:
   13          *
   14          *   Version:
   15          *
   16          *******************************************************************************/
   17          
   18          /*******************************************************************************
   19          * 1.Included header files
   20          *******************************************************************************/
   21          #include <string.h>
   22          #include "DrvHostComm.h"
   23          #include "DrvSysCtrl.h"
   24          #include "AppHostComm.h"
   25          #include "AppParameter.h"
   26          #include "FlowFactory.h"
   27          #include "FlowUpgrade.h"
   28          #include "TestRwSFR.h"
   29          
   30          
   31          
   32          /*******************************************************************************
   33          * 2.Private constant and macro definitions using #define
   34          *******************************************************************************/
   35          
   36          /* 标准I2C命令响应
   37           * W EB AA 09 r 03
   38           * 返回 EB AA 08
   39           */
   40          #define STD_I2C_CMD_ACK_EN   1
   41          /*******************************************************************************
   42          * 3.Private enumerations, structures and unions using typedef
   43          *******************************************************************************/
   44          typedef enum
   45          {
   46              SWITCH_TO_STD_I2C_INIT = 0,
   47              SWITCH_TO_STD_I2C_EB = SWITCH_TO_STD_I2C_INIT,
   48              SWITCH_TO_STD_I2C_AA,
   49              SWITCH_TO_STD_I2C_09,
   50              SWITCH_TO_STD_I2C_END = SWITCH_TO_STD_I2C_09,
   51          } ENUM_SWITCH_TO_STD_I2C;
   52          
   53          /*******************************************************************************
   54          * 4.Static variables
   55          *******************************************************************************/
   56          static UINT8 DRAM s_ucI2cWrByteIdx;      /* the byte index of each Host Write */
C251 COMPILER V5.54.0.0,  AppHostComm                                                      26/05/17  20:21:05  PAGE 2   

   57          UINT8 DRAM g_ucI2cDataAddr;              /* current data accessing address */
   58          
   59          static ENUM_SWITCH_TO_STD_I2C XRAM g_ucSwitch2STDI2C = SWITCH_TO_STD_I2C_INIT;
   60          
   61          
   62          /*******************************************************************************
   63          * 5.Global variable or extern global variabls/functions
   64          *******************************************************************************/
   65          /* Touch Panel Parameters */
   66          UNION_PanelParameter XRAM g_unPanelParam;
   67          
   68          
   69          /*******************************************************************************
   70          * 6.Static function prototypes
   71          *******************************************************************************/
   72          UINT8 AppAnswerSwitch2STDI2C(UINT8 ucAddr);
   73          void AppHandleSwitch2STDI2C(UINT8 ucAddr, UINT8 ucData);
   74          /*******************************************************************************
   75          *   Name: AppAnswerSwitch2STDI2C
   76          *  Brief: Answer Switch2STDI2C command.
   77          *  Input: None
   78          * Output: None
   79          * Return: UINT8 => the read byte
   80          *******************************************************************************/
   81          UINT8 AppAnswerSwitch2STDI2C(UINT8 ucAddr)
   82          {
   83   1          static UINT8 CROM bufCmd[3] = {0xEB,0xAA,0x08};
   84   1          static UINT8 XRAM bufIdx;
   85   1          UINT8 cmdByte;
   86   1      
   87   1          if (ucAddr == 0xEB)
   88   1          {
   89   2              bufIdx = 0;
   90   2          }
   91   1      
   92   1          cmdByte = bufCmd[bufIdx];
   93   1          bufIdx ++;
   94   1          if (bufIdx == 3)
   95   1          {
   96   2              bufIdx = 0;
   97   2              g_ucSwitch2STDI2C = SWITCH_TO_STD_I2C_INIT;
   98   2          }
   99   1          g_ucI2cDataAddr = 0xEB;
  100   1      
  101   1          return cmdByte;
  102   1      }
  103          
  104          /*******************************************************************************
  105          *   Name: AppHandleSwitch2STDI2C
  106          *  Brief: Handlef Switch2STDI2C command.
  107          *  Input: None
  108          * Output: None
  109          * Return: UINT8 => the read byte
  110          *******************************************************************************/
  111          void AppHandleSwitch2STDI2C(UINT8 ucAddr, UINT8 ucData)
  112          {
  113   1          if ((ucAddr == 0xEB) || (ucAddr == 0xEC))
  114   1          {
  115   2              if (g_ucSwitch2STDI2C == SWITCH_TO_STD_I2C_INIT)
  116   2              {
  117   3                  if (ucData == 0xAA)
  118   3                  {
  119   4                      g_ucSwitch2STDI2C = SWITCH_TO_STD_I2C_AA;
  120   4                      g_ucI2cDataAddr --;
  121   4                  }
  122   3              }
C251 COMPILER V5.54.0.0,  AppHostComm                                                      26/05/17  20:21:05  PAGE 3   

  123   2              if (g_ucSwitch2STDI2C == SWITCH_TO_STD_I2C_AA)
  124   2              {
  125   3                  if (ucData == 0x09)
  126   3                  {
  127   4                      g_ucSwitch2STDI2C = SWITCH_TO_STD_I2C_END;
  128   4                  }
  129   3                  else
  130   3                  {
  131   4                      g_ucSwitch2STDI2C = SWITCH_TO_STD_I2C_INIT;
  132   4                  }
  133   3              }
  134   2              g_ucI2cDataAddr = 0xEA;
  135   2          }
  136   1      }
  137          /*******************************************************************************
  138          *   Name: AppReadGestureData
  139          *  Brief: Read Spec Gesture Data from the register at 0xD3 in normal device mode
  140          *  Input: None
  141          * Output: None
  142          * Return: UINT8 => the read byte
  143          *******************************************************************************/
  144          
  145          #define AppReadGestureData()    0xFF;
  146          
  147          
  148          /*******************************************************************************
  149          *   Name: AppHostUpdateHeadState
  150          *  Brief: Update Register Header and Switch Flow State
  151          *  Input: UINT8 NewRegHeader => New Register Header Value
  152          * Output: None
  153          * Return: None
  154          *******************************************************************************/
  155          void AppHostUpdateHeadState(UINT8 NewRegHeader)
  156          {
  157   1          UINT8 DeviceMode;
  158   1      
  159   1          g_RegHead.ucData = NewRegHeader;
  160   1      
  161   1          /* Optimize, make running time short */
  162   1          DeviceMode = g_DeviceMode;
  163   1      
  164   1          if (DeviceMode == DEVICE_MODE_TEST)
  165   1          {
  166   2              g_State = SS_FACTORY;
  167   2          }
  168   1          else if ((DeviceMode == DEVICE_MODE_NORMAL) || DeviceMode == DEVICE_MODE_INFO)
  169   1          {
  170   2              g_State = SS_WORK;
  171   2          }
  172   1          else
  173   1          {
  174   2              /* 非法命令---跳到工作模式  */
  175   2              DBG_HOST("\nMode:error,w00=%02x",NewRegHeader);
  176   2              g_State = SS_WORK;
  177   2              g_RegHead.ucData = 0x00;
  178   2          }
  179   1      }
  180          
  181          /*******************************************************************************
  182          *   Name: AppWriteRegMapDataNormal
  183          *  Brief: Write a byte to the register at given address in normal device mode
  184          *  Input: UINT8 ucAddr => register address
  185          *         UINT8 ucData => register value to be written
  186          * Output: None
  187          * Return: None
  188          *******************************************************************************/
C251 COMPILER V5.54.0.0,  AppHostComm                                                      26/05/17  20:21:05  PAGE 4   

  189          static void AppWriteRegMapDataNormal(UINT8 ucAddr, UINT8 ucData)
  190          {
  191   1          /* DEVICE_MODE locates at register address 0x00 */
  192   1          if (ucAddr == 0x00)
  193   1          {
  194   2              AppHostUpdateHeadState(ucData);
  195   2          }
  196   1      
  197   1          /* REG ADDR 0xEB switch to STD I2C */
  198   1          else if ((ucAddr == 0xEB) || (ucAddr == 0xEC))
  199   1          {
  200   2              AppHandleSwitch2STDI2C(ucAddr, ucData);
  201   2          }
  202   1      
  203   1          /* REG ADDR 0x80 - 0xBF contain paramters of normal state */
  204   1          else if ((ucAddr >= REG_PARAM_ADDR_FIRST) && (ucAddr <= REG_PARAM_ADDR_LAST))
  205   1          {
  206   2              //AppParamWrite((UINT8)(ucAddr - REG_PARAM_ADDR_FIRST),ucData);
  207   2          }
  208   1      
  209   1          /* 连续写FC寄存器才有效，中间有别的寄存器插入，则需要重新发FC AA命令 */
  210   1          if (ucAddr == 0xFC)
  211   1          {
  212   2              //AppUpRstDownProc(ucData);
  213   2          }
  214   1          else
  215   1          {
  216   2              //g_ucLastState = SS_WORK;
  217   2          }
  218   1      }
  219          
  220          /*******************************************************************************
  221          *   Name: AppReadRegMapDataNormal
  222          *  Brief: Read a byte from the register at given address in normal device mode
  223          *  Input: UINT8 ucAddr => register address
  224          * Output: None
  225          * Return: UINT8 => the read byte
  226          *******************************************************************************/
  227          static UINT8 AppReadRegMapDataNormal(UINT8 ucAddr)
  228          {
  229   1          /* REG ADDR 0x00 stores devive mode for all kinds of register map */
  230   1          if (ucAddr == 0x00)
  231   1          {
  232   2              return g_RegHead.ucData;
  233   2          }
  234   1          /* REG ADDR 0x01 stores gesture ID,
  235   1           * REG ADDR 0x02 stores current point number,
  236   1           * REG ADDR 0x03 - 0x3E stores points status
  237   1           * 取数据指针
  238   1           */
  239   1      #if 0        
                   else if (ucAddr <= 0x03)
                   {
                       if (g_bBuffer1Finished)
                       {
                           g_pReportBuf = &g_unReportBuffer1;
                       }
                       else
                       {
                           g_pReportBuf = &g_unReportBuffer2;
                       }
                       return g_pReportBuf->buf[ucAddr - 1];
                   }
                   else if (ucAddr <= REG_OUTPUT_ADDR_LAST)
                   {
                       return g_pReportBuf->buf[ucAddr - 1];
C251 COMPILER V5.54.0.0,  AppHostComm                                                      26/05/17  20:21:05  PAGE 5   

                   }
               #endif
  257   1          else if ((ucAddr == 0xEB) || (ucAddr == 0xEC))
  258   1          {
  259   2              return AppAnswerSwitch2STDI2C(ucAddr);
  260   2          }
  261   1          else if ((ucAddr >= REG_PARAM_ADDR_FIRST) && (ucAddr <= REG_PARAM_ADDR_LAST))
  262   1          {
  263   2              return g_stSysParam.Offset[ucAddr - REG_PARAM_ADDR_FIRST];
  264   2          }
  265   1      
  266   1      
  267   1          /* REG ADDR 0xFC stores bootloader switch condition */
  268   1          else if (ucAddr == 0xFC)
  269   1          {
  270   2              return g_stSysParam.Params.reg.ucState;
  271   2          }
  272   1          else if (ucAddr == 0xFE)
  273   1          {
  274   2              //return g_stModeCtrl[g_ucParaModeCur].ucK2Delay;
  275   2              return 0; //   ls
  276   2          }
  277   1          else
  278   1          {
  279   2              return 0xFF;
  280   2          }
  281   1      }
  282          
  283          /*******************************************************************************
  284          *   Name: AppHostRegRead
  285          *  Brief:
  286          *  Input: None
  287          * Output: None
  288          * Return: None
  289          *******************************************************************************/
  290          UINT8 AppHostRegRead(UINT8 addr)
  291          {
  292   1          UINT8 DRAM myDeviceMode;
  293   1          UINT8 DRAM ch = 0;
  294   1          /* Optimize, make running time short */
  295   1          myDeviceMode = g_DeviceMode;
  296   1          if (myDeviceMode == DEVICE_MODE_NORMAL)
  297   1          {
  298   2              ch = AppReadRegMapDataNormal(addr);
  299   2          }
  300   1          else if (myDeviceMode == DEVICE_MODE_TEST)
  301   1          {
  302   2              ch = AppReadRegMapDataTest(addr);
  303   2          }
  304   1          else
  305   1          {
  306   2              DBG_HOST("\nR:mode error%0d",myDeviceMode);
  307   2          }
  308   1          return ch;
  309   1      }
  310          
  311          
  312          /*******************************************************************************
  313          *   Name: AppHostRegWrite
  314          *  Brief:
  315          *  Input: None
  316          * Output: None
  317          * Return: None
  318          *******************************************************************************/
  319          void AppHostRegWrite(UINT8 addr,UINT8 ch)
  320          {
C251 COMPILER V5.54.0.0,  AppHostComm                                                      26/05/17  20:21:05  PAGE 6   

  321   1          UINT8 DRAM myDeviceMode;
  322   1          /* Optimize, make running time short */
  323   1          myDeviceMode = g_DeviceMode;
  324   1          if (myDeviceMode == DEVICE_MODE_NORMAL)
  325   1          {
  326   2              AppWriteRegMapDataNormal(addr, ch);
  327   2          }
  328   1          else if (myDeviceMode == DEVICE_MODE_TEST)
  329   1          {
  330   2              AppWriteRegMapDataTest(addr, ch);
  331   2          }
  332   1          else
  333   1          {
  334   2              DBG_HOST("\nW:mode error");
  335   2          }
  336   1      }
  337          
  338          /*******************************************************************************
  339          *   Name: CommInitHostCommCtrl
  340          *  Brief: Initialize control variables of IRQ handlers
  341          *  Input: None
  342          * Output: None
  343          * Return: None
  344          *******************************************************************************/
  345          static void CommInitHostCommCtrl(void)
  346          {
  347   1          s_ucI2cWrByteIdx = 0;
  348   1          g_ucI2cDataAddr  = 0;
  349   1          DATA_BUF = g_RegHead.ucData;
  350   1      }
  351          
  352          /*******************************************************************************
  353          *   Name: HostCommProc
  354          *  Brief:
  355          *         标准I2C处理
  356          *  Input:
  357          * Output:
  358          * Return:
  359          *******************************************************************************/
  360          static void HostCommProc(void)
  361          {
  362   1          UINT8 DRAM tmp;
  363   1      
  364   1          /* Host Write while Chip Read */
  365   1          if (RI_FLAG)
  366   1          {
  367   2              RI_FLAG = 0;
  368   2      
  369   2              if (s_ucI2cWrByteIdx == 0)
  370   2              {
  371   3                  s_ucI2cWrByteIdx = 1;
  372   3                  /* Save first byte as data address */
  373   3                  g_ucI2cDataAddr = DATA_BUF;
  374   3                  /* Get ready for host to read the first byte after set address */
  375   3                  DATA_BUF = AppHostRegRead(g_ucI2cDataAddr);
  376   3                  return;
  377   3              }
  378   2              else
  379   2              {
  380   3                  tmp = DATA_BUF;
  381   3                  AppHostRegWrite(g_ucI2cDataAddr,tmp);
  382   3                  g_ucI2cDataAddr++;
  383   3              }
  384   2          }
  385   1      
  386   1          /* Host read while FT5422 write */
C251 COMPILER V5.54.0.0,  AppHostComm                                                      26/05/17  20:21:05  PAGE 7   

  387   1          if (TI_FLAG)
  388   1          {
  389   2              TI_FLAG = 0;
  390   2              g_ucI2cDataAddr++;
  391   2              DATA_BUF = AppHostRegRead(g_ucI2cDataAddr);
  392   2          }
  393   1      }
  394          
  395          /*******************************************************************************
  396          *   Name: ISR_I2C
  397          *  Brief: Interrupt Service Routine (ISR) for I2C communication
  398          *  Input: None
  399          * Output: None
  400          * Return: None
  401          *******************************************************************************/
  402          void ISR_I2C(void) interrupt 5
  403          {
  404   1          HostCommProc();
  405   1      }
  406          
  407          /*******************************************************************************
  408          *   Name: ISR_I2C
  409          *  Brief: Interrupt Service Routine (ISR) for I2C communication stop
  410          *  Input: None
  411          * Output: None
  412          * Return: None
  413          *******************************************************************************/
  414          void ISR_I2C_Stop(void) interrupt 8
  415          {
  416   1          I2CSTP = 0;
  417   1          s_ucI2cWrByteIdx = 0;
  418   1      }
  419          
  420          /*******************************************************************************
  421          *   Name: AppHostCommInit
  422          *  Brief: Initialize the module communicats with host
  423          *  Input: None
  424          * Output: None
  425          * Return: None
  426          *******************************************************************************/
  427          void AppHostCommInit(void)
  428          {
  429   1          /* default device mode is normal mode */
  430   1          g_RegHead.ucData = 0; // g_unPanelParam.reg.RegHead.ucData
  431   1      
  432   1          /*  IF there is not have interrupt to host, host read the buffers, It maybe
  433   1           *  report the wrong status to host
  434   1           */
  435   1      
  436   1          /* Initialize hardware and controls of host communication interface */
  437   1          DrvHostCommInit();
  438   1          CommInitHostCommCtrl();
  439   1      }
  440          
  441          


Module Information          Static   Overlayable
------------------------------------------------
  code size            =        11     ------
  ecode size           =       388     ------
  data size            =         2     ------
  idata size           =    ------     ------
  pdata size           =    ------     ------
  xdata size           =    ------     ------
  xdata-const size     =    ------     ------
  edata size           =        95     ------
C251 COMPILER V5.54.0.0,  AppHostComm                                                      26/05/17  20:21:05  PAGE 8   

  bit size             =    ------     ------
  ebit size            =    ------     ------
  bitaddressable size  =    ------     ------
  ebitaddressable size =    ------     ------
  far data size        =    ------     ------
  huge data size       =    ------     ------
  const size           =    ------     ------
  hconst size          =         6     ------
End of Module Information.


C251 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
