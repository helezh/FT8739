C251 COMPILER V5.54.0.0,  DrvAsmCtrl                                                       26/05/17  20:21:09  PAGE 1   


C251 COMPILER V5.54.0.0, COMPILATION OF MODULE DrvAsmCtrl
OBJECT MODULE PLACED IN ..\output\obj\DrvAsmCtrl.obj
COMPILER INVOKED BY: D:\software\Keil\C251\BIN\C251.EXE ..\..\src\source\driver\DrvAsmCtrl.c SMALL ROM(HUGE) OPTIMIZE(9,
                    -SPEED) REGFILE(..\output\obj\mcu.ORC) BROWSE INCDIR(..\..\src\include;..\..\src\include\app;..\..\src\include\flow;..\..
                    -\src\include\driver\;..\..\src\include\lib_drv\;..\..\src\include\config;..\..\src\include\Debug) DEFINE(__FT8836__) DEB
                    -UG PRINT(..\output\list\DrvAsmCtrl.lst) TABS(2) OBJECT(..\output\obj\DrvAsmCtrl.obj) 

stmt  level    source

    1          /*******************************************************************************
    2          * Copyright (C) 2012-2013, FocalTech Systems (R)£¬All Rights Reserved.
    3          *
    4          * File Name: DrvAsmCtrl.c
    5          *
    6          *    Author: linjianjun
    7          *
    8          *   Created: 2014-10-10
    9          *
   10          *  Abstract:
   11          *
   12          * Reference:
   13          *
   14          *******************************************************************************/
   15          
   16          /*******************************************************************************
   17          * Included header files
   18          *******************************************************************************/
   19          #include "CfgGlobal.h"
   20          #include "CfgAutoTune.h"
   21          
   22          #include "DrvSysCtrl.h"
   23          #include "DrvAfe.h"
   24          //#include "DrvAsmCtrl.h"
   25          //#include "DrvMonDet.h"
   26          
   27          #include "LibDrv.h"
   28          
   29          //#include "AppDataStruct.h"
   30          //#include "AppAfeCtrl.h"
   31          
   32          
   33          #include "DrvAsm.h"
   34          
   35          /*******************************************************************************
   36          * Private constant and macro definitions using #define
   37          *******************************************************************************/
   38          
   39          /*******************************************************************************
   40          * Private enumerations, structures and unions using typedef
   41          *******************************************************************************/
   42          
   43          /*******************************************************************************
   44          * Static variables
   45          *******************************************************************************/
   46          
   47          /*******************************************************************************
   48          * Global variable or extern global variabls/functions
   49          *******************************************************************************/
   50          ST_AsmRegisters * XRAM pAsmRegs = (volatile ST_AsmRegisters *)ASM_REG_BASE_ADDR;
   51          UINT16 XRAM g_ucLcdBusyCnt = 0;
   52          
   53          
   54          extern volatile UINT8 XRAM g_ucFrameEndFlag;
   55          extern volatile UINT8 XRAM g_ucAramReadyFlag;  
   56          extern volatile UINT16 XRAM g_usAsmIntFlag0;
C251 COMPILER V5.54.0.0,  DrvAsmCtrl                                                       26/05/17  20:21:09  PAGE 2   

   57          extern volatile UINT16 XRAM g_usAsmIntFlag1;
   58          extern volatile UINT8 XRAM g_ucLcdSyncMissFlag;   
   59          extern volatile UINT16 XRAM g_ucIntCount;
   60          extern volatile UINT8 XRAM g_ucTimeOutFlag;  // hw mon time out
   61          extern volatile UINT8 XRAM g_ucTchDetFlag;  // tch det
   62          
   63          extern UINT8 XRAM ucAfeRunMode;
   64          extern UINT8 XRAM g_ucAfeScanMode;
   65          
   66          /*******************************************************************************
   67          * Static function prototypes
   68          *******************************************************************************/
   69          
   70          /*******************************************************************************
   71          *   Name: Asm_Config_Init
   72          *  Brief: Afe scanÅäÖÃ²ÎÊý³õÊ¼»¯
   73          *  Input: 
   74          * Output: 
   75          * Return: 
   76          *******************************************************************************/
   77          void Asm_Config_Init(void)
   78          {     
   79   1          //REG_14    
   80   1          pAsmRegs->usAsmScanCfg0 =   ((0<<BIT_MONITOR_MODE)         // [15]Ó²¼þ´¥Ãþ¼ì²âÄ£Ê½: 1: ÊÇ£»      0:·ñ
             -   
   81   1                                      +(0<<BIT_CB_ADJUST_MODE)       // [14]CBÐ£ÕýÄ£Ê½:       1:Ð£ÕýÄ£Ê½   0:Õý
             -³£Ä£Ê½           
   82   1                                      +(0<<BIT_AFE_CLKGATE_EN)       // [12]×Ô¶¯ÃÅ¿ØAFEÊ±ÖÓ:  1:×Ô¶¯ÃÅ¿Ø 0:²»×Ô
             -¶¯ÃÅ¿Ø 
   83   1                                      +(0<<BIT_SCAN_START_STORE_EN)  // [10]1:±£´æ£¬×Ô¶¯Æô¶¯ÏÂÒ»´ÎÉ¨Ãè£¬0:²»±£´
             -æ£¬²»×Ô¶¯Æô¶¯ÏÂ´ÎÉ¨Ãè¡£          
   84   1                                      +(1<<BIT_LCD_FRAME_HEAD_ALIGN) // [9]µÚ0Ö¡µÄÆô¶¯Ê±¿ÌÑ¡Ôñ:0:µ±Ç°LCDÖ¡¿ªÊ¼Ê
             -£Óà¿ÓÉ¨Ãè; 1:´í¹ýID,ÏÂLCDÖ¡¿ªÊ¼É¨Ãè      
   85   1                                      +(0<<BIT_VBLANK_EDGE_SEL)      // [8]busy_idÇåÁãÐÅºÅÑ¡Ôñ: 0:ÉÏÉýÑØ £»1: Ï
             -Â½µÑØ  
   86   1                                      +(0<<BIT_VSTART_EDGE_SEL)      // [7]busy_idÇåÁãÐÅºÅÑ¡Ôñ: 0:ÉÏÉýÑØ £»1: Ï
             -Â½µÑØ      
   87   1                                      +(0<<BIT_VMID_EDGE_SEL)        // [6]busy_idÇåÁãÐÅºÅÑ¡Ôñ: 0:ÉÏÉýÑØ £»1: Ï
             -Â½µÑØ 
   88   1                                      +(0<<BIT_VEND_EDGE_SEL)        // [5]busy_idÇåÁãÐÅºÅÑ¡Ôñ: 0:ÉÏÉýÑØ £»1: Ï
             -Â½µÑØ 
   89   1                                      +(0<<BIT_CLR_BUSY_ID_SEL)      // [4:3] ÇåÁãÐÅºÅÑ¡Ôñ: 0:vstart; 1:vmid 2:
             -vend 3:vblank
   90   1                                      +(0<<BIT_TP_FRAME_NUM));       // [2:0]¶àÖ¡É¨ÃèµÄ×ÜÖ¡Êý 0-3: É¨Ãè1-4¸öTPÖ
             -¡  
   91   1      
   92   1          pAsmRegs->usAsmScanCfg0 |= (0<<BIT_SCAN_START_STORE_EN);      // 1:±£´æ£¬×Ô¶¯Æô¶¯ÏÂÒ»´ÎÉ¨Ãè
   93   1      
   94   1          pAsmRegs->usAsmScanCfg0 |= (1<<BIT_LCD_FRAME_HEAD_ALIGN);     // 1:´í¹ýID,ÏÂLCDÖ¡¿ªÊ¼É¨Ãè 
   95   1      #if TEST_CUR_LEFT_SCAN
                   pAsmRegs->usAsmScanCfg0&=~(1<<BIT_LCD_FRAME_HEAD_ALIGN);      // 0:µ±Ç°LCDÖ¡¿ªÊ¼Ê£Óà¿ÓÉ¨Ãè;  
               #endif
   98   1          DBG_FLOW("\n  13 pAsmRegs->usAsmScanCfg0: %04x",pAsmRegs->usAsmScanCfg0);
   99   1          
  100   1          //REG_15         
  101   1          pAsmRegs->usAsmScanCfg1 =   ((1<<BIT_LCD_RUN_INTPHASE)     // [15] LCD RUNÖÐ¶ÏµçÆ½Ñ¡Ôñ£¬         0:µÍ
             -µçÆ½£¬1:¼ì²â¸ßµçÆ½                       
  102   1                                      +(1<<BIT_LCD_DSTB_INTPHASE)    // [14] LCD Deep StandbyÖÐ¶ÏµçÆ½Ñ¡Ôñ£¬0:µÍ
             -µçÆ½£¬1:¼ì²â¸ßµçÆ½                       
  103   1                                      +(0<<BIT_LPF_MODE_TP_TURBO_REQ)// [9] ÇëÇó: 0:²»¿ª¿Ó  1:¿ª¿Ó
  104   1                                      +(0<<BIT_VB_MODE_REQ)          // [8] ÇëÇó: 0:Ð¡¿Ó    1:´ó¿Ó 
  105   1                                      +(1<<BIT_TP_END_SEL)           // [5] Ö¡½áÊøÎ»ÖÃÑ¡Ôñ. 0:tp_frame_end. 1:a
             -ram rdy(¹ØÏµµ½Á¬ÐøÉ¨ÃèÏÂÖ¡Æô¶¯Î»ÖÃ)
  106   1                                      +(DAT_TP_STANDBY_ENABLE<<BIT_STB_EN)               // [4] Ô¤ÏÈ¼ÓÔØ²ÎÊý£¬È
             -çCB shiftÊ¹ÄÜ: 1:Ê¹ÄÜ ÔÚlcd busyÇ°µÄ´òµã¼ÓÔØtab,ËÙ¶È¿ì¡£Ö»Ö§³ÖÐ¡¿Ó        
  107   1                                      +(0<<BIT_HW_MONITOR_EN)        // [3] Ó²¼þMonitorÊ¹ÄÜ£»           1: Ê¹ÄÜ
C251 COMPILER V5.54.0.0,  DrvAsmCtrl                                                       26/05/17  20:21:09  PAGE 3   

             - 
  108   1                                      +(0<<BIT_VBLANK_INV));         // [1] VblankÓÐÐ§µçÆ½Ñ¡Ôñ£¬ÓÃÓÚÖÐ¶Ï, 0:¸ßµ
             -çÆ½£¬1:µÍµçÆ½   
  109   1                                
  110   1          //REG_16 
  111   1          pAsmRegs->usAsmTpFrameCfg0 =  ((0<<BIT_TAB_ID1)            // [14]µÚ1¸öTPÖ¡ÓÃµÄTable±íºÅ  
  112   1                                        +(0<<BIT_BUSY_ID1)           // [8] µÚ1¸öTPÖ¡ÆðÊ¼¿ÓºÅ        
  113   1                                        +(0<<BIT_TAB_ID0)            // [6] µÚ0¸öTPÖ¡ÓÃµÄTable±íºÅ     
  114   1                                        +(0<<BIT_BUSY_ID0));         // [0] µÚ0¸öTPÖ¡ÆðÊ¼¿ÓºÅ 
  115   1      
  116   1          //REG_17 
  117   1          pAsmRegs->usAsmTpFrameCfg1 =  ((0<<BIT_TAB_ID3)            // [14]µÚ3¸öTPÖ¡ÓÃµÄTable±íºÅ  
  118   1                                        +(0<<BIT_BUSY_ID3)           // [8] µÚ3¸öTPÖ¡ÆðÊ¼¿ÓºÅ        
  119   1                                        +(0<<BIT_TAB_ID2)            // [6] µÚ2¸öTPÖ¡ÓÃµÄTable±íºÅ     
  120   1                                        +(0<<BIT_BUSY_ID2));         // [0] µÚ2¸öTPÖ¡ÆðÊ¼¿ÓºÅ 
  121   1      
  122   1          //REG_18 
  123   1          pAsmRegs->usAsmTpFrameCfg2 =  ((0<<BIT_BUSY_ID5)           // [8] µÚ5¸öTPÖ¡ÆðÊ¼¿ÓºÅ        
  124   1                                        +(0<<BIT_BUSY_ID4));         // [0] µÚ4¸öTPÖ¡ÆðÊ¼¿ÓºÅ 
  125   1      
  126   1          //REG_19 
  127   1          pAsmRegs->usAsmTpFrameCfg3 =  ((0<<BIT_BUSY_ID7)           // [8] µÚ7¸öTPÖ¡ÆðÊ¼¿ÓºÅ        
  128   1                                        +(0<<BIT_BUSY_ID6));         // [0] µÚ6¸öTPÖ¡ÆðÊ¼¿ÓºÅ 
  129   1      
  130   1          //REG_20   
  131   1          pAsmRegs->usAsmScanDly =   ((0<<BIT_TAB_EN3)               // [13] Tab3±íÊ¹ÄÜ: 1:Ê¹ÄÜ  ÒÑ¾­É¾³ý 
  132   1                                     +(0<<BIT_TAB_EN2)               // [12] Tab2±íÊ¹ÄÜ: 1:Ê¹ÄÜ  ÒÑ¾­É¾³ý 
  133   1                                     +(0<<BIT_TAB_EN1)               // [11] Tab1±íÊ¹ÄÜ: 1:Ê¹ÄÜ  ÒÑ¾­É¾³ý 
  134   1                                     +(0<<BIT_TAB_EN0)               // [10] Tab0±íÊ¹ÄÜ: 1:Ê¹ÄÜ  ÒÑ¾­É¾³ý 
  135   1                                     +(0<<BIT_SCAN_DELAY));          // [9:0]LCD RUNÏÂ½µÑØµ½É¨Ãè¿ªÊ¼µÄÑÓÊ±
  136   1      
  137   1          //REG_21 
  138   1          pAsmRegs->usAsmStbMaseL =  (0xffff<<BIT_STB_MASK_L);       // [15:0]STB_TICKÖÐ¶ÏÆÁ±ÎÉèÖÃµÍÎ»
  139   1      
  140   1          //REG_22  
  141   1          pAsmRegs->usAsmStbMaseH =  (0xffff<<BIT_STB_MASK_H);       // [15:0]STB_TICKÖÐ¶ÏÆÁ±ÎÉèÖÃ¸ßÎ»
  142   1      
  143   1          //REG_23 24 25   
  144   1          pAsmRegs->usAsmAramBaseL   = 0;
  145   1          pAsmRegs->usAsmAramBaseR   = CH_ORDER_MAX;
  146   1          pAsmRegs->usAsmAramBaseKey = 2*CH_ORDER_MAX;
  147   1      
  148   1          //REG_26 27 28   
  149   1          pAsmRegs->usAsmAramCBL     = 0;
  150   1          pAsmRegs->usAsmAramCBR     = CH_ORDER_MAX;  
  151   1          pAsmRegs->usAsmAramCBKey   = 2*CH_ORDER_MAX;
  152   1      
  153   1          //REG_04
  154   1          pAsmRegs->usAsmIntEn0 = 0; 
  155   1          DBG_FLOW("\n pAsmRegs->usAsmIntEn0 : %04x",pAsmRegs->usAsmIntEn0);
  156   1      //    while(1);
  157   1      
  158   1          pAsmRegs->usAsmIntEn0 =  ((0<<BIT_LCD_BUSY_FALL_EN0)            //15
  159   1                                   +(0<<BIT_LCD_BUSY_RISE_EN0)            //14
  160   1                                   +(0<<BIT_LCD_PANEL_CONFLICT_EN0)       //13
  161   1                                   +(0<<BIT_LCD_DSTB_FAIL_EN0)            //12
  162   1                                   +(0<<BIT_LCD_DSTB_RISE_EN0)            //11 
  163   1                                   +(0<<BIT_LCD_SYNC_MISS_FALL_EN0)       //10
  164   1                                   +(0<<BIT_LCD_SYNC_MISS_RISE_EN0)       //9
  165   1                                   +(0<<BIT_LCD_ARAM_RDY_EN0)             //8
  166   1                                   +(0<<BIT_LCD_FRAME_END_EN0)            //7
  167   1                                   +(0<<BIT_LCD_TCH_DET_EN0)              //6
  168   1                                   +(0<<BIT_LCD_VSTART_EN0)               //5
  169   1                                   +(0<<BIT_LCD_VMID_EN0)                 //4
  170   1                                   +(0<<BIT_LCD_VEND_EN0)                 //3
  171   1                                   +(0<<BIT_LCD_VBLANK_EN0)               //2
C251 COMPILER V5.54.0.0,  DrvAsmCtrl                                                       26/05/17  20:21:09  PAGE 4   

  172   1                                   +(0<<BIT_LCD_RUN_FALL_EN0)             //1 
  173   1                                   +(0<<BIT_LCD_RUN_RISE_EN0));           //0
  174   1          
  175   1      
  176   1          //REG_05
  177   1          pAsmRegs->usAsmIntEn1 = 0; 
  178   1          pAsmRegs->usAsmIntEn1 = ((0<<BIT_HW_MON_TIMEOUT_EN1)             //14
  179   1                                  +(0<<BIT_LCD_LPF_MODE_EN_FALL_EN1)      //13
  180   1                                  +(0<<BIT_LCD_LPF_MODE_EN_RISE_EN1)      //12
  181   1                                  +(0<<BIT_LCD_STB_TICK_EN1)              //11
  182   1                                  +(0<<BIT_LCD_ODD_EVEN_FALL_EN1)         //10
  183   1                                  +(0<<BIT_LCD_ODD_EVEN_RISE_EN1)         //9
  184   1                                  +(0<<BIT_LCD_VDO_MODE_FALL_EN1)         //8
  185   1                                  +(0<<BIT_LCD_VDO_MODE_RISE_EN1)         //7  
  186   1                                  +(0<<BIT_LCD_IDLE_MODE_FALL_EN1)        //6  
  187   1                                  +(0<<BIT_LCD_IDLE_MODE_RISE_EN1)        //5
  188   1                                  +(0<<BIT_LCD_3D_MODE_FALL_EN1)          //4
  189   1                                  +(0<<BIT_LCD_3D_MODE_RISE_EN1)          //3
  190   1                                  +(0<<BIT_LCD_RUN_EN1)                   //2
  191   1                                  +(0<<BIT_LCD_DSTB_EN1));                //1
  192   1                               
  193   1                                                                                   
  194   1      // Test Wake Up    
  195   1           //REG_06
  196   1           pAsmRegs->usAsmIntWakeEn0 = 0;
  197   1           pAsmRegs->usAsmIntWakeEn0 = ((0<<BIT_LCD_BUSY_FALL_WAKE_EN0)       //15
  198   1                                       +(0<<BIT_LCD_BUSY_RISE_WAKE_EN0)       //14
  199   1                                       +(0<<BIT_LCD_PANEL_CONFLICT_WAKE_EN0)  //13
  200   1                                       +(0<<BIT_LCD_DSTB_FAIL_WAKE_EN0)       //12
  201   1                                       +(0<<BIT_LCD_DSTB_RISE_WAKE_EN0)       //11
  202   1                                       +(0<<BIT_LCD_SYNC_MISS_FALL_WAKE_EN0)  //10
  203   1                                       +(0<<BIT_LCD_SYNC_MISS_RISE_WAKE_EN0)  //9
  204   1                                       +(0<<BIT_LCD_ARAM_RDY_WAKE_EN0)        //8
  205   1                                       +(0<<BIT_LCD_FRAME_END_WAKE_EN0)       //7
  206   1                                       +(0<<BIT_LCD_TCH_DET_WAKE_EN0)         //6
  207   1                                       +(0<<BIT_LCD_VSTART_WAKE_EN0)          //5
  208   1                                       +(0<<BIT_LCD_VMID_WAKE_EN0)            //4
  209   1                                       +(0<<BIT_LCD_VEND_WAKE_EN0)            //3
  210   1                                       +(0<<BIT_LCD_VBLANK_WAKE_EN0)          //2
  211   1                                       +(0<<BIT_LCD_RUN_FALL_WAKE_EN0)        //1
  212   1                                       +(0<<BIT_LCD_RUN_RISE_WAKE_EN0));      //0  
  213   1           //REG_07
  214   1           pAsmRegs->usAsmIntWakeEn1 = 0;
  215   1           pAsmRegs->usAsmIntWakeEn1 = ((0<<BIT_LCD_STB_TICK_WAKE_EN1)        //11  
  216   1                                       +(0<<BIT_LCD_ODD_EVEN_FALL_WAKE_EN1)   //10
  217   1                                       +(0<<BIT_LCD_ODD_EVEN_RISE_WAKE_EN1)   //9
  218   1                                       +(0<<BIT_LCD_VDO_MODE_FALL_WAKE_EN1)   //8
  219   1                                       +(0<<BIT_LCD_VDO_MODE_RISE_WAKE_EN1)   //7 
  220   1                                       +(0<<BIT_LCD_IDLE_MODE_FALL_WAKE_EN1)  //6 
  221   1                                       +(0<<BIT_LCD_IDLE_MODE_RISE_WAKE_EN1)  //5
  222   1                                       +(0<<BIT_LCD_3D_MODE_FALL_WAKE_EN1)    //4
  223   1                                       +(0<<BIT_LCD_3D_MODE_RISE_WAKE_EN1));  //3     
  224   1      
  225   1      #if TEST_STANDBY_WAKEUP_ALL
                   pAsmRegs->usAsmIntWakeEn0 = 0xFFFF;
                   pAsmRegs->usAsmIntWakeEn1 = 0xFFFF;
               #endif
  229   1                                                
  230   1           DBG_FLOW("\n 6usAsmIntWakeEn0: %04x",pAsmRegs->usAsmIntWakeEn0);
  231   1           DBG_FLOW("\n 7usAsmIntWakeEn1: %04x",pAsmRegs->usAsmIntWakeEn1);     
  232   1      
  233   1      
  234   1      #if 0// LCD RELOAD FLASH WAKE UP  interrupt 0
                   LCD_RELOAD_FLASH_WKEN = 1;    
               #endif
  237   1      
C251 COMPILER V5.54.0.0,  DrvAsmCtrl                                                       26/05/17  20:21:09  PAGE 5   

  238   1      #if TEST_LCD_LVD_WAKEUP// LCD LVD WAKE UP interrupt 0
                   LCD_LVD_PHASE = 1;  // 1:¼ì²â¸ßµçÆ½
                   LCD_LVD_WKEN = 1;            
               #endif
  242   1      
  243   1      #if TEST_LCD_ESD_WAKEUP// LCD ESD WAKE UP interrupt 0    
                   LCD_ESD_PHASE = 1;  // 1:¼ì²â¸ßµçÆ½
                   LCD_ESD_WKEN = 1;       
               #endif
  247   1      
  248   1      #if TEST_LCD_RUN_WAKEUP//LCD RUN WAKE UP interrupt 0   
                   pAsmRegs->usAsmScanCfg1|=(1<<BIT_LCD_RUN_INTPHASE);     //[15] LCD RUNÖÐ¶ÏµçÆ½Ñ¡Ôñ.1:¼ì²â¸ßµçÆ½      
             -                 
                   LCD_TIM_WKEN = 1;  
                   pAsmRegs->usAsmIntEn1|=(1<<BIT_LCD_RUN_EN1);            // LCD RUN ÖÐ¶ÏÊ¹ÄÜ  interrupt 4    
               #endif
  253   1      
  254   1      #if TEST_LCD_DSTB_WAKEUP//LCD_DSTB WAKE UP interrupt 0 
                   pAsmRegs->usAsmScanCfg1|=(1<<BIT_LCD_DSTB_INTPHASE);    //[15] LCD DSTBÖÐ¶ÏµçÆ½Ñ¡Ôñ.1:¼ì²â¸ßµçÆ½  
                   LCD_TIM_WKEN = 1;
                   pAsmRegs->usAsmIntEn1|=(1<<BIT_LCD_DSTB_EN1);           // LCD DEEP STANDBY ÖÐ¶ÏÊ¹ÄÜ   interrupt 4   
             -               
               #endif
  259   1      
  260   1          //REG_2 3  
  261   1          pAsmRegs->usAsmIntClr0  = 0xFFFF;
  262   1          pAsmRegs->usAsmIntClr1  = 0xFFFF; 
  263   1           
  264   1          ASM_EI  = 1;  /* asm int */
  265   1          EX0 = 1;  /* int0 wake up */ 
  266   1          
  267   1          EA = 1;
  268   1      }
  269          
  270          void DrvAsmWakeEnable0(UINT16 usWakeMode)
  271          {
  272   1          //REG_06
  273   1          pAsmRegs->usAsmIntWakeEn0 |=(1<<usWakeMode);       
  274   1      }
  275          
  276          void DrvAsmWakeEnable1(UINT16 usWakeMode)
  277          {
  278   1          //REG_07
  279   1          pAsmRegs->usAsmIntWakeEn1 |=(1<<usWakeMode);       
  280   1      }
  281          
  282          void DrvAsmWakeDisable0(UINT16 usWakeMode)
  283          {
  284   1          //REG_06
  285   1          pAsmRegs->usAsmIntWakeEn0&=~(1<<usWakeMode);       
  286   1      }
  287          
  288          void DrvAsmWakeDisable1(UINT16 usWakeMode)
  289          {
  290   1          //REG_07
  291   1          pAsmRegs->usAsmIntWakeEn1&=~(1<<usWakeMode);       
  292   1      }
  293          
  294          void DrvAsmInterEnableAll(void)
  295          {
  296   1          //REG_04
  297   1          pAsmRegs->usAsmIntEn0 = 0xFFFF; //¿ªÆôÖÐ¶ÏÊ¹ÄÜ
  298   1          //REG_05
  299   1          pAsmRegs->usAsmIntEn1 = 0xFFFF; //¿ªÆôÖÐ¶ÏÊ¹ÄÜ
  300   1      
  301   1          //DBG_FLOW("\npAsmRegs->usAsmIntEn0: %04x",pAsmRegs->usAsmIntEn0);          
C251 COMPILER V5.54.0.0,  DrvAsmCtrl                                                       26/05/17  20:21:09  PAGE 6   

  302   1      }
  303          
  304          void DrvAsmInterDisableAll(void)
  305          {
  306   1          //REG_04
  307   1          pAsmRegs->usAsmIntEn0 = 0x0; //¹Ø±ÕÖÐ¶ÏÊ¹ÄÜ
  308   1          //REG_05
  309   1          pAsmRegs->usAsmIntEn1 = 0x0; //¹Ø±ÕÖÐ¶ÏÊ¹ÄÜ
  310   1      
  311   1          //DBG_FLOW("\npAsmRegs->usAsmIntEn0: %04x",pAsmRegs->usAsmIntEn0);          
  312   1      }
  313          
  314          void DrvAsmInterEnable0(UINT16 usInterMode)
  315          {
  316   1          //REG_04
  317   1          pAsmRegs->usAsmIntEn0|=(TRUE<<usInterMode); //¿ªÆôÖÐ¶ÏÊ¹ÄÜ
  318   1          //DBG_FLOW("\npAsmRegs->usAsmIntEn0: %04x",pAsmRegs->usAsmIntEn0);          
  319   1      }
  320          
  321          void DrvAsmInterDisable0(UINT16 usInterMode)
  322          {
  323   1          //REG_04
  324   1          pAsmRegs->usAsmIntEn0&=~(TRUE<<usInterMode); //¹Ø±ÕÖÐ¶ÏÊ¹ÄÜ
  325   1      }
  326          
  327          void DrvAsmInterEnable1(UINT16 usInterMode)
  328          {
  329   1          //REG_05
  330   1          pAsmRegs->usAsmIntEn1|=(TRUE<<usInterMode); //¿ªÆôÖÐ¶ÏÊ¹ÄÜ
  331   1      }
  332          
  333          void DrvAsmInterDisable1(UINT16 usInterMode)
  334          {
  335   1          //REG_05
  336   1          pAsmRegs->usAsmIntEn1&=~(TRUE<<usInterMode); //¹Ø±ÕÖÐ¶ÏÊ¹ÄÜ
  337   1      }
  338          
  339          void DrvAsmInterClear0(UINT16 usClearMode)
  340          {
  341   1          pAsmRegs->usAsmIntClr0|=(TRUE<<usClearMode); //Çå³ýÖÐ¶Ï 
  342   1      }
  343          
  344          UINT16 DrvAsmGetSta(void)
  345          {
  346   1          //REG8
  347   1          return pAsmRegs->usAsmIntSta;
  348   1      }
  349          
  350          UINT16 DrvAsmGetSta1(void)
  351          {
  352   1          //REG10
  353   1          return pAsmRegs->usAsmScanSta1;
  354   1      }
  355          
  356          void DrvAsmSetIDReset(void)
  357          {
  358   1          //REG13
  359   1          pAsmRegs->usAsmScanCtrl|= (1<<1);
  360   1      }
  361          
  362          void DrvAsmSetPhase(void)
  363          {
  364   1          //REG15
  365   1          pAsmRegs->usAsmScanCfg1|=((1<<BIT_LCD_RUN_INTPHASE)     // [15] LCD RUNÖÐ¶ÏµçÆ½Ñ¡Ôñ£¬         0:µÍµçÆ
             -½£¬1:¼ì²â¸ßµçÆ½                       
  366   1                                   +(1<<BIT_LCD_DSTB_INTPHASE));   // [14] LCD Deep StandbyÖÐ¶ÏµçÆ½Ñ¡Ôñ£¬0:µÍµç
C251 COMPILER V5.54.0.0,  DrvAsmCtrl                                                       26/05/17  20:21:09  PAGE 7   

             -Æ½£¬1:¼ì²â¸ßµçÆ½                           
  367   1      }
  368          
  369          void DrvAsmSeStbtMask(UINT16 usMask)
  370          {
  371   1          //REG21
  372   1          pAsmRegs->usAsmStbMaseL = (usMask<<BIT_STB_MASK_L);       // [15:0]STB_TICKÖÐ¶ÏÆÁ±ÎÉèÖÃµÍÎ»
  373   1      }
  374          
  375          void DebugReadAsmReg(void)
  376          {
  377   1          DBG_FLOW("\npAsmReg0: %04x",pAsmRegs->usAsmIntFlag0);          // 00  RO
  378   1          DBG_FLOW("\npAsmReg1: %04x",pAsmRegs->usAsmIntFlag1);          // 01  RO
  379   1          DBG_FLOW("\npAsmReg2: %04x",pAsmRegs->usAsmIntClr0);           // 02  WO
  380   1          DBG_FLOW("\npAsmReg3: %04x",pAsmRegs->usAsmIntClr1);           // 03  WO
  381   1          DBG_FLOW("\npAsmReg4: %04x",pAsmRegs->usAsmIntEn0);            // 04
  382   1          DBG_FLOW("\npAsmReg5: %04x",pAsmRegs->usAsmIntEn1);            // 05
  383   1          DBG_FLOW("\npAsmReg6: %04x",pAsmRegs->usAsmIntWakeEn0);        // 06
  384   1          DBG_FLOW("\npAsmReg7: %04x",pAsmRegs->usAsmIntWakeEn1);        // 07
  385   1          DBG_FLOW("\npAsmReg8: %04x",pAsmRegs->usAsmIntSta);            // 08  RO
  386   1          DBG_FLOW("\npAsmReg9: %04x",pAsmRegs->usAsmScanSta0);          // 09  RO
  387   1          DBG_FLOW("\npAsmReg10: %04x",pAsmRegs->usAsmScanSta1);         // 10  RO
  388   1          DBG_FLOW("\npAsmReg11: %04x",pAsmRegs->usAsmScanSta2);         // 11  RO
  389   1          DBG_FLOW("\npAsmReg12: %04x",pAsmRegs->usAsmScanSta3);         // 12  RO    
  390   1          DBG_FLOW("\npAsmReg13: %04x",pAsmRegs->usAsmScanCtrl);         // 13  WO
  391   1          DBG_FLOW("\npAsmReg14: %04x",pAsmRegs->usAsmScanCfg0);         // 14
  392   1          DBG_FLOW("\npAsmReg15: %04x",pAsmRegs->usAsmScanCfg1);         // 15
  393   1          DBG_FLOW("\npAsmReg16: %04x",pAsmRegs->usAsmTpFrameCfg0);      // 16
  394   1          DBG_FLOW("\npAsmReg17: %04x",pAsmRegs->usAsmTpFrameCfg1);      // 17
  395   1          DBG_FLOW("\npAsmReg18: %04x",pAsmRegs->usAsmTpFrameCfg2);      // 18
  396   1          DBG_FLOW("\npAsmReg19: %04x",pAsmRegs->usAsmTpFrameCfg3);      // 19
  397   1          DBG_FLOW("\npAsmReg20: %04x",pAsmRegs->usAsmScanDly);          // 20
  398   1          DBG_FLOW("\npAsmReg21: %04x",pAsmRegs->usAsmStbMaseL);         // 21
  399   1          DBG_FLOW("\npAsmReg22: %04x",pAsmRegs->usAsmStbMaseH);         // 22  
  400   1          DBG_FLOW("\npAsmReg23: %04x",pAsmRegs->usAsmAramBaseL);        // 23
  401   1          DBG_FLOW("\npAsmReg24: %04x",pAsmRegs->usAsmAramBaseR);        // 24
  402   1          DBG_FLOW("\npAsmReg25: %04x",pAsmRegs->usAsmAramBaseKey);      // 25    
  403   1          DBG_FLOW("\npAsmReg26: %04x",pAsmRegs->usAsmAramCBL);          // 26
  404   1          DBG_FLOW("\npAsmReg27: %04x",pAsmRegs->usAsmAramCBR);          // 27
  405   1          DBG_FLOW("\npAsmReg28: %04x",pAsmRegs->usAsmAramCBKey);        // 28
  406   1      }
  407          
  408          void AppGetAsmState(void)
  409          {
  410   1          DBG_FLOW("\n8usAsmIntSta: %04x",pAsmRegs->usAsmIntSta);            // 08  RO
  411   1          DBG_FLOW("\n9usAsmScanSta0: %04x busy_id:0x%x",pAsmRegs->usAsmScanSta0,pAsmRegs->usAsmScanSta0&0x3F);
             -          // 09  RO
  412   1          DBG_FLOW("\n10usAsmScanSta1: %04x lcd_busy:0x%x",pAsmRegs->usAsmScanSta1,(pAsmRegs->usAsmScanSta1>>10
             -)&0x1);         // 10  RO
  413   1          DBG_FLOW("\n11usAsmScanSta2: stb_id:0x%04x stb_tick_id:0x%x",pAsmRegs->usAsmScanSta2>>6,pAsmRegs->usA
             -smScanSta2&0x3F);     // 11  RO
  414   1          DBG_FLOW("\n12usAsmScanSta3: max:0x%04x min:0x%04x",pAsmRegs->usAsmScanSta3>>6,pAsmRegs->usAsmScanSta
             -3&0x3F);         // 12  RO  
  415   1      }
  416          
  417          /*******************************************************************************
  418          *   Name: DrvAsmCloseTable
  419          *  Brief: 
  420          *  Input:
  421          * Output:  
  422          * Return:  
  423          *******************************************************************************/
  424          void DrvAsmCloseTable(void)
  425          {
  426   1          //REG_19   
  427   1          pAsmRegs->usAsmScanDly&=~(0xF<<10);
C251 COMPILER V5.54.0.0,  DrvAsmCtrl                                                       26/05/17  20:21:09  PAGE 8   

  428   1      }
  429          
  430          /*******************************************************************************
  431          *   Name: DrvLoadTabSingle
  432          *  Brief: ¸üÐÂ±íÏî ,Ò»´ÎÆô¶¯ É¨Ãè1¸öTPÖ¡
  433          *  Input: ucTabId:ÐèÒª¸üÐÂµÄ±íID, ucBusyID µÚ0¸öTPÖ¡ÆðÊ¼¿ÓºÅ 
  434          * Output:  
  435          * Return:  
  436          *******************************************************************************/
  437          void DrvLoadTabSingle(UINT8 ucTabId,UINT8 ucBusyID)
  438          {
  439   1          //REG_20   
  440   1          pAsmRegs->usAsmScanDly|=   ((1<<BIT_TAB_EN3)              // [13] Tab3±íÊ¹ÄÜ: 1:Ê¹ÄÜ 
  441   1                                     +(1<<BIT_TAB_EN2)              // [12] Tab2±íÊ¹ÄÜ: 1:Ê¹ÄÜ 
  442   1                                     +(1<<BIT_TAB_EN1)              // [11] Tab1±íÊ¹ÄÜ: 1:Ê¹ÄÜ 
  443   1                                     +(1<<BIT_TAB_EN0));            // [10] Tab0±íÊ¹ÄÜ: 1:Ê¹ÄÜ 
  444   1      //    DBG_FLOW("\n17pAsmRegs->usAsmScanDly: %04x",pAsmRegs->usAsmScanDly);         
  445   1      
  446   1          //REG_14    
  447   1          pAsmRegs->usAsmScanCfg0&=~(0x7<<BIT_TP_FRAME_NUM);      
  448   1          pAsmRegs->usAsmScanCfg0|=(0<<BIT_TP_FRAME_NUM);         // [1:0]¶àÖ¡É¨ÃèµÄ×ÜÖ¡Êý 0-3: É¨Ãè1-4¸öTPÖ¡ 
  449   1          
  450   1          //REG_16 
  451   1          pAsmRegs->usAsmTpFrameCfg0|= ((ucTabId<<BIT_TAB_ID0)      // [1] µÚ0¸öTPÖ¡ÓÃµÄTable±íºÅ     
  452   1                                       +(ucBusyID<<BIT_BUSY_ID0));  // [0] µÚ0¸öTPÖ¡ÆðÊ¼¿ÓºÅ 
  453   1      }
  454          
  455          /*******************************************************************************
  456          *   Name: DrvLoadTabMultiple
  457          *  Brief: ¸üÐÂ±íÏî ,Ò»´ÎÆô¶¯ ¶àTPÖ¡É¨Ãè
  458          *  Input: ucBusyId0-3,LCD_BUSYÆô¶¯É¨Ãè¿ÓºÅ£¬ ucScanMul: ¶àÉÙ´ÎTPÉ¨Ãè 
  459          * Output:  
  460          * Return:  
  461          *******************************************************************************/
  462          void DrvLoadTabMultiple(UINT8 ucBusyId0,UINT8 ucBusyId1,UINT8 ucBusyId2,UINT8 ucBusyId3,UINT8 ucScanMul,U
             -INT8 ucTab)
  463          {
  464   1          UINT8 ucF0TabId;
  465   1          UINT8 ucF1TabId;
  466   1          UINT8 ucF2TabId;
  467   1          UINT8 ucF3TabId;
  468   1          
  469   1          ucF0TabId = ucTab; // TAB±íID
  470   1          ucF1TabId = ucTab;
  471   1          ucF2TabId = ucTab;
  472   1          ucF3TabId = ucTab;
  473   1      
  474   1          
  475   1          //REG_20   
  476   1          pAsmRegs->usAsmScanDly|=   ((1<<BIT_TAB_EN3)               // [13] Tab3±íÊ¹ÄÜ: 1:Ê¹ÄÜ 
  477   1                                     +(1<<BIT_TAB_EN2)               // [12] Tab2±íÊ¹ÄÜ: 1:Ê¹ÄÜ 
  478   1                                     +(1<<BIT_TAB_EN1)               // [11] Tab1±íÊ¹ÄÜ: 1:Ê¹ÄÜ 
  479   1                                     +(1<<BIT_TAB_EN0));             // [10] Tab0±íÊ¹ÄÜ: 1:Ê¹ÄÜ 
  480   1      
  481   1          //REG_14    
  482   1          pAsmRegs->usAsmScanCfg0&=~(0x7<<BIT_TP_FRAME_NUM);      
  483   1          pAsmRegs->usAsmScanCfg0|=(ucScanMul<<BIT_TP_FRAME_NUM);   // [1:0]¶àÖ¡É¨ÃèµÄ×ÜÖ¡Êý 0-3: É¨Ãè1-4¸öTPÖ¡
             -                                
  484   1                                     
  485   1          //REG_16 
  486   1          pAsmRegs->usAsmTpFrameCfg0 = ((ucF1TabId<<BIT_TAB_ID1)     // [3] µÚ1¸öTPÖ¡ÓÃµÄTable±íºÅ  
  487   1                                        +(ucBusyId1<<BIT_BUSY_ID1)   // [2] µÚ1¸öTPÖ¡ÆðÊ¼¿ÓºÅ        
  488   1                                        +(ucF0TabId<<BIT_TAB_ID0)    // [1] µÚ0¸öTPÖ¡ÓÃµÄTable±íºÅ     
  489   1                                        +(ucBusyId0<<BIT_BUSY_ID0)); // [0] µÚ0¸öTPÖ¡ÆðÊ¼¿ÓºÅ 
  490   1      
  491   1          //REG_17 
C251 COMPILER V5.54.0.0,  DrvAsmCtrl                                                       26/05/17  20:21:09  PAGE 9   

  492   1          pAsmRegs->usAsmTpFrameCfg1 = ((ucF3TabId<<BIT_TAB_ID3)     // [3] µÚ3¸öTPÖ¡ÓÃµÄTable±íºÅ  
  493   1                                        +(ucBusyId3<<BIT_BUSY_ID3)   // [2] µÚ3¸öTPÖ¡ÆðÊ¼¿ÓºÅ        
  494   1                                        +(ucF2TabId<<BIT_TAB_ID2)    // [1] µÚ2¸öTPÖ¡ÓÃµÄTable±íºÅ     
  495   1                                        +(ucBusyId2<<BIT_BUSY_ID2)); // [0] µÚ2¸öTPÖ¡ÆðÊ¼¿ÓºÅ 
  496   1                               
  497   1      }
  498          
  499          /*******************************************************************************
  500          *   Name: DrvAsmScanStart
  501          *  Brief: Æô¶¯É¨Ãè
  502          *  Input: 
  503          * Output: 
  504          * Return: 
  505          *******************************************************************************/
  506          void DrvAsmScanStart(void)
  507          {
  508   1          pAsmRegs->usAsmScanCtrl|=(1<<BIT_SCAN_START);   // [0] WO: Æô¶¯É¨Ãè  
  509   1          //DBG_FLOW("\nStart"); 
  510   1      }
  511          
  512          /*******************************************************************************
  513          *   Name: DrvAsmSetMonitorMode
  514          *  Brief: Ó²¼þ´¥Ãþ¼ì²âÄ£Ê½: 1: ÊÇ£»      0:·ñ   
  515          *  Input: 
  516          * Output: 
  517          * Return: 
  518          *******************************************************************************/
  519          void DrvAsmSetMonitorMode(UINT8 ucModeEn)
  520          {
  521   1          //REG_14   
  522   1          pAsmRegs->usAsmScanCfg0&=~(1<<BIT_MONITOR_MODE);
  523   1          pAsmRegs->usAsmScanCfg0|=(ucModeEn<<BIT_MONITOR_MODE);     // [15]Ó²¼þ´¥Ãþ¼ì²âÄ£Ê½: 1: ÊÇ£»      0:·ñ
             -   
  524   1          // Ó²¼þ´¥Ãþ¼ì²âÄ£Ê½ÏÂ£¬ÎÞARAM READYÖÐ¶Ï£¬²ÉÓÃframe_end Ö¡½áÊøÖÐ¶ÏÀ´ÅÐ¶ÏÉ¨ÃèÍê³É
  525   1          pAsmRegs->usAsmScanCfg1&=~(1<<BIT_TP_END_SEL);           // [5] Ö¡½áÊøÎ»ÖÃÑ¡Ôñ. 0:tp_frame_end. 1:ara
             -m rdy(¹ØÏµµ½Á¬ÐøÉ¨ÃèÏÂÖ¡Æô¶¯Î»ÖÃ)
  526   1      }
  527          
  528          /*******************************************************************************
  529          *   Name: DrvAsmSetCBAdjustMode
  530          *  Brief: CBÐ£ÕýÄ£Ê½:       1:Ð£ÕýÄ£Ê½   0:Õý³£Ä£Ê½   
  531          *  Input: 
  532          * Output: 
  533          * Return: 
  534          *******************************************************************************/
  535          void DrvAsmSetCBAdjustMode(UINT8 ucModeEn)
  536          {
  537   1          //REG_14    
  538   1          pAsmRegs->usAsmScanCfg0&=~(1<<BIT_CB_ADJUST_MODE);
  539   1          pAsmRegs->usAsmScanCfg0|=(ucModeEn<<BIT_CB_ADJUST_MODE);   // [14]CBÐ£ÕýÄ£Ê½:       1:Ð£ÕýÄ£Ê½   0:Õý
             -³£Ä£Ê½   
  540   1      }
  541          
  542          
  543          /*******************************************************************************
  544          *   Name: DrvGetAramCb
  545          *  Brief: 
  546          *  Input: 
  547          * Output: 
  548          * Return: 
  549          *******************************************************************************/
  550          void DrvGetAramCb(void)
  551          {
  552   1          UINT16 XRAM i;
  553   1          UINT16 XRAM ausCbBuff;
  554   1          UINT16 XRAM ausCbBase;
C251 COMPILER V5.54.0.0,  DrvAsmCtrl                                                       26/05/17  20:21:09  PAGE 10  

  555   1      
  556   1          ARAM_SEL = 1;
  557   1         
  558   1          DBG_FLOW("\nRead CB from Aram");
  559   1      
  560   1          ausCbBase = pAsmRegs->usAsmAramCBL;
  561   1          DBG_FLOW("\nAFE_L CB  BASE ADDR:%04x",ausCbBase);  
  562   1          for(i = 0; i < CH_ORDER_MAX>>1; i++)
  563   1          {   
  564   2              if((i%18) == 0)
  565   2                  DBG_FLOW("\n");
  566   2              
  567   2              ausCbBuff = ARAM_ADDR16((ausCbBase<<1)+(i<<1));        
  568   2              DBG_FLOW("%04x  ",ausCbBuff); 
  569   2          }
  570   1          
  571   1          DBG_FLOW("\n\n");
  572   1      
  573   1          ausCbBase = pAsmRegs->usAsmAramCBR;
  574   1          DBG_FLOW("\nAFE_R CB  BASE ADDR:%04x",ausCbBase);  
  575   1          for(i = 0; i < CH_ORDER_MAX>>1; i++)
  576   1          {   
  577   2              if((i%18) == 0)
  578   2                  DBG_FLOW("\n");
  579   2              
  580   2              ausCbBuff = ARAM_ADDR16((ausCbBase<<1)+(i<<1));      
  581   2              DBG_FLOW("%04x  ",ausCbBuff); 
  582   2          }  
  583   1      
  584   1          DBG_FLOW("\n\n");
  585   1      
  586   1          /*¶Á³öAFE_KEYµÄCBÐ£ÕýÖµ*/
  587   1          ausCbBase = pAsmRegs->usAsmAramCBKey;
  588   1          DBG_FLOW("\nAFE_KEY CB  BASE ADDR:%04x\n",ausCbBase);    
  589   1          for(i = 0; i < 8; i++)
  590   1          {
  591   2              ausCbBuff = ARAM_ADDR16((ausCbBase<<1)+(i<<1));
  592   2              DBG_FLOW("%04x  ",ausCbBuff);
  593   2          }     
  594   1          
  595   1          ARAM_SEL = 0;
  596   1      }
  597          
  598          /*******************************************************************************
  599          *   Name: DrvGetAramRawData
  600          *  Brief: 
  601          *  Input: 
  602          * Output: 
  603          * Return: 
  604          *******************************************************************************/
  605          void DrvGetAramRawData(void)
  606          {
  607   1          UINT16 XRAM i;
  608   1          UINT16 XRAM ausDataBuff[CH_ORDER_MAX*2+14];
  609   1          UINT16 XRAM ausDataBase;
  610   1      
  611   1          ARAM_SEL = 1;
  612   1      
  613   1          /*¶Á³öAFE_LµÄRawData*/
  614   1          ausDataBase = pAsmRegs->usAsmAramBaseL;
  615   1          for(i = 0; i < CH_ORDER_MAX; i++)
  616   1          {
  617   2              ausDataBuff[i] = ARAM_ADDR16((ausDataBase<<1)+(i<<1));
  618   2          }
  619   1      
  620   1          /*¶Á³öAFE_RµÄRawData*/
C251 COMPILER V5.54.0.0,  DrvAsmCtrl                                                       26/05/17  20:21:09  PAGE 11  

  621   1          ausDataBase = pAsmRegs->usAsmAramBaseR;   
  622   1          for(i = 0; i < CH_ORDER_MAX; i++)
  623   1          {
  624   2              ausDataBuff[CH_ORDER_MAX + i] = ARAM_ADDR16((ausDataBase<<1)+(i<<1));
  625   2          }
  626   1      
  627   1          /*¶Á³öAFE_KEYµÄRawData*/
  628   1          ausDataBase = pAsmRegs->usAsmAramBaseKey;
  629   1         
  630   1          for(i = 0; i < 14; i++)
  631   1          {
  632   2              ausDataBuff[CH_ORDER_MAX*2 + i] = ARAM_ADDR16((ausDataBase<<1)+(i<<1));
  633   2          }
  634   1        
  635   1          DBG_FLOW("\nAFE_L RawData:");
  636   1          for(i = 0; i < CH_ORDER_MAX; i++)
  637   1        {
  638   2          if(i%18 == 0)
  639   2          {
  640   3            DBG_FLOW("\n");
  641   3          }
  642   2          DBG_FLOW("%04x  ",ausDataBuff[i]);
  643   2        }
  644   1      
  645   1          DBG_FLOW("\nAFE_R RawData:");
  646   1          for(i = 0; i < CH_ORDER_MAX; i++)
  647   1        {
  648   2          if(i%18 == 0)
  649   2          {
  650   3            DBG_FLOW("\n");
  651   3          }
  652   2          DBG_FLOW("%04x  ",ausDataBuff[CH_ORDER_MAX + i]);
  653   2        }
  654   1        
  655   1          DBG_FLOW("\nAFE_Key RawData:\n"); 
  656   1          for(i = 0; i < 8; i++)
  657   1          {
  658   2          DBG_FLOW("%04x ",ausDataBuff[CH_ORDER_MAX*2 + i]);    
  659   2          }
  660   1      
  661   1          DBG_FLOW("\nAFE Info:");
  662   1          DBG_FLOW("%04x  ",ausDataBuff[CH_ORDER_MAX*2 + 8]);
  663   1          DBG_FLOW("%04x  ",ausDataBuff[CH_ORDER_MAX*2 + 11]);
  664   1      
  665   1          DBG_FLOW("\nAFE Tp Diff Max:");
  666   1          DBG_FLOW("%04x  ",ausDataBuff[CH_ORDER_MAX*2 + 9]);
  667   1          DBG_FLOW("%04x  ",ausDataBuff[CH_ORDER_MAX*2 + 12]);
  668   1      
  669   1          DBG_FLOW("\nAFE Key Diff Max:");
  670   1          DBG_FLOW("%04x  ",ausDataBuff[CH_ORDER_MAX*2 + 10]);
  671   1          DBG_FLOW("%04x  ",ausDataBuff[CH_ORDER_MAX*2 + 13]);    
  672   1          ARAM_SEL = 0; 
  673   1      }
  674          
  675          
  676          
  677          /*******************************************************************************
  678          *   Name: DrvGetAdcData
  679          *  Brief: 
  680          *  Input: 
  681          * Output: 
  682          * Return: 
  683          *******************************************************************************/
  684          void DrvGetAdcData(UINT16 ucLen)
  685          {
  686   1          UINT16 XRAM i;
C251 COMPILER V5.54.0.0,  DrvAsmCtrl                                                       26/05/17  20:21:09  PAGE 12  

  687   1          UINT16 XRAM ausDataBuff;
  688   1          UINT16 XRAM ausDataBase;
  689   1      
  690   1          ARAM_SEL = 1;
  691   1      
  692   1          /*¶Á³öAFE_LµÄRawData*/
  693   1          ausDataBase = pAsmRegs->usAsmAramBaseL;
  694   1          DBG_FLOW("\nAFE_L Adc Data:");
  695   1          for(i = 0; i < ucLen; i++)
  696   1          {
  697   2              ausDataBuff = ARAM_ADDR16((ausDataBase<<1)+(i<<1));
  698   2              if((i%24) == 0)
  699   2              { 
  700   3                  DBG_FLOW("\n");
  701   3              }
  702   2              DBG_FLOW("%04x ",ausDataBuff);
  703   2              }
  704   1      #if 0
                   /*¶Á³öAFE_RµÄRawData*/
                   ausDataBase = pAsmRegs->usAsmAramBaseR;
                   DBG_FLOW("\nAFE_R RawData:");    
                   for(i = 0; i < ucLen; i++)
                   {
                       ausDataBuff = ARAM_ADDR16((ausDataBase<<1)+(i<<1));
                       if((i%18) == 0)
                       {
                           DBG_FLOW("\n");
                       }
                       DBG_FLOW("%04x  ",ausDataBuff);
                   }
               #endif
  718   1      
  719   1          
  720   1          ARAM_SEL = 0; 
  721   1      }
  722          
  723          /*******************************************************************************
  724          *   Name: DrvAsmSetSTBTickMask
  725          *  Brief: STB_TICKÖÐ¶ÏÆÁ±ÎÉèÖÃ 
  726          *  Input: 
  727          * Output: 
  728          * Return: 
  729          *******************************************************************************/
  730          void DrvAsmSetSTBTickMask(UINT16 usMaskL,UINT16 usMaskH)
  731          {
  732   1          //REG_21  
  733   1          pAsmRegs->usAsmStbMaseL = (usMaskL<<BIT_STB_MASK_L);       // [15:0]STB_TICKÖÐ¶ÏÆÁ±ÎÉèÖÃµÍÎ»
  734   1      
  735   1          //REG_22  
  736   1          pAsmRegs->usAsmStbMaseH = (usMaskH<<BIT_STB_MASK_H);       // [15:0]STB_TICKÖÐ¶ÏÆÁ±ÎÉèÖÃ¸ßÎ»
  737   1      }
  738          
  739          /*******************************************************************************
  740          *   Name: DrvAsmMonitoModeInit
  741          *  Brief: Ó²¼þ´¥Ãþ¼ì²âÄ£Ê½ 
  742          *  Input: 
  743          * Output: 
  744          * Return: 
  745          *******************************************************************************/
  746          void DrvAsmMonitoModeInit(void)
  747          {
  748   1        UINT16 XRAM usReg0;
  749   1        UINT16 XRAM usReg1;
  750   1        UINT16 XRAM usReg2;
  751   1        UINT16 XRAM usReg3;
  752   1        UINT16 XRAM usReg4;
C251 COMPILER V5.54.0.0,  DrvAsmCtrl                                                       26/05/17  20:21:09  PAGE 13  

  753   1        UINT16 XRAM usReg5;
  754   1        UINT16 XRAM usReg6;
  755   1        UINT16 XRAM usReg7;
  756   1        UINT16 XRAM usReg8;
  757   1        UINT16 XRAM usReg9;
  758   1      
  759   1        usReg0 = rAFE_SYS_CFG1;
  760   1      
  761   1      #if TEST_FREERUN_MONITOR
                 usReg1 = rAFE_SCAN_CFG0;
                 usReg1 =((1<<BIT_AFE_SCAN_TIMES)         //É¨Ãè´ÎÊý£¬Êµ¼ÊÖµÎªÅäÖÃÖµ¼Ó1;  
                     +(4<<BIT_AFE_SCAN_MODE));       //·½Ê½5
               #else
  766   1        usReg1 = rAFE_SCAN_CFG0;
  767   1        usReg1 =((1<<BIT_AFE_SCAN_TIMES)         //É¨Ãè´ÎÊý£¬Êµ¼ÊÖµÎªÅäÖÃÖµ¼Ó1;  
  768   1            +(0<<BIT_AFE_SCAN_MODE));       //·½Ê½1
  769   1      
  770   1      
  771   1        //REG_14  
  772   1        pAsmRegs->usAsmScanCfg0&=~(0x7<<BIT_TP_FRAME_NUM);    
  773   1        pAsmRegs->usAsmScanCfg0|=(0<<BIT_TP_FRAME_NUM);   // [1:0]¶àÖ¡É¨ÃèµÄ×ÜÖ¡Êý 0-3: É¨Ãè1-4¸öTPÖ¡                
  774   1                       
  775   1        //REG_16 
  776   1        pAsmRegs->usAsmTpFrameCfg0 = ((2<<BIT_TAB_ID1)     // [3] µÚ1¸öTPÖ¡ÓÃµÄTable±íºÅ  
  777   1                        +(0<<BIT_BUSY_ID1)   // [2] µÚ1¸öTPÖ¡ÆðÊ¼¿ÓºÅ      
  778   1                        +(2<<BIT_TAB_ID0)    // [1] µÚ0¸öTPÖ¡ÓÃµÄTable±íºÅ   
  779   1                        +(1<<BIT_BUSY_ID0)); // [0] µÚ0¸öTPÖ¡ÆðÊ¼¿ÓºÅ 
  780   1      
  781   1        //REG_17 
  782   1        pAsmRegs->usAsmTpFrameCfg1 = ((2<<BIT_TAB_ID3)     // [3] µÚ3¸öTPÖ¡ÓÃµÄTable±íºÅ  
  783   1                        +(0<<BIT_BUSY_ID3)   // [2] µÚ3¸öTPÖ¡ÆðÊ¼¿ÓºÅ      
  784   1                        +(2<<BIT_TAB_ID2)    // [1] µÚ2¸öTPÖ¡ÓÃµÄTable±íºÅ   
  785   1                        +(0<<BIT_BUSY_ID2)); // [0] µÚ2¸öTPÖ¡ÆðÊ¼¿ÓºÅ 
  786   1      
  787   1            
  788   1      #endif
  789   1      
  790   1        usReg3 = rAFE_DUMMY_SCAN_CFG;
  791   1        usReg3 =((1<<10)         //[11:8]MuxÇÐ»»Ö®¼äDummy´ÎÊý    
  792   1            +(0<<5)         //[7:4]¿ÓÇ°Dummy´ÎÊý
  793   1            +(2<<0));       //[3:0]TpÖ¡Ç°Dummy´ÎÊý       
  794   1             
  795   1        usReg2 = rAFE_SCAN_CFG1; 
  796   1        usReg2 =((0<<9)         //[10:9] ²ÉÑùÄ£Ê½: 0:Ë«±ß²ÉÑù£¬Ä£ÄâÏà¼õ; 1:¸º±ß²ÉÑù; 2:Õý±ß²ÉÑù; 3:Ë«±ß²ÉÑù£¬Êý×ÖÏà
             -¼õ    
  797   1            +(0<<8)         //[8] SXÉ¨Ãè·½Ê½:  0:Ë«±ßÉ¨Ãè(4ÖÖ²ÉÑùmode); 1: µ¥±ßÉ¨Ãè(½ö1ÖÖµ¥±ß²ÉÑù)
  798   1            +(4<<0));       //[0] ·½Ê½6£¬É¨Ãè¶ÎÊý       
  799   1             
  800   1        usReg4 = rAFE_BASE_TRACK_CFG;
  801   1        usReg4 = ((32<<BIT_BASE_TRACK_STEP)       //[9:2]MonitorÄ£Ê½£¬Base¸ú×Ù£¬²½½ø¸ú×Ù²½³¤                           
  802   1              +(1<<BIT_BASE_TRACK_MODE)       //[1] MonitorÄ£Ê½£¬Base¸ú×Ù·½Ê½: 0:²½½ø¸ú×Ù; 1:Ô­Öµ¸ú×Ù
  803   1              +(1<<BIT_BASE_TRACK_ENABLE));     //[0] MontiorÄ£Ê½£¬Base¸ú×ÙÊ¹ÄÜ£¬1:Ê¹ÄÜ 
  804   1              
  805   1        usReg5 = rACC_OFFSET;
  806   1        usReg6 = rTP_MONITOR_THRESHOLD;
  807   1        usReg7 = rKEY_MONITOR_THRESHOLD;
  808   1        usReg8 = rAFE_ANA_K1_CFG0;
  809   1        usReg9 = rAFE_ANA_K2_CFG1;
  810   1      
  811   1        DrvAsmCloseTable(); // ²»¸üÐÂTab±íÏî,Ö±½ÓÓÃ¼Ä´æÆ÷ÅäÖÃ
  812   1        
  813   1        Drv_XsiWriteReg(pXSI0Regs, Addr_AFE_SYS_CFG1, usReg0, AFE_REG); //5
  814   1        Drv_XsiWriteReg(pXSI1Regs, Addr_AFE_SYS_CFG1, usReg0, AFE_REG);
  815   1      
  816   1        Drv_XsiWriteReg(pXSI0Regs, Addr_AFE_SCAN_CFG0, usReg1, AFE_REG); //6
  817   1        Drv_XsiWriteReg(pXSI1Regs, Addr_AFE_SCAN_CFG0, usReg1, AFE_REG);
C251 COMPILER V5.54.0.0,  DrvAsmCtrl                                                       26/05/17  20:21:09  PAGE 14  

  818   1      
  819   1        Drv_XsiWriteReg(pXSI0Regs, Addr_AFE_SCAN_CFG1, usReg2, AFE_REG); //7
  820   1        Drv_XsiWriteReg(pXSI1Regs, Addr_AFE_SCAN_CFG1, usReg2, AFE_REG);
  821   1      
  822   1        Drv_XsiWriteReg(pXSI0Regs, Addr_AFE_DUMMY_SCAN_CFG, usReg3, AFE_REG); //8
  823   1        Drv_XsiWriteReg(pXSI1Regs, Addr_AFE_DUMMY_SCAN_CFG, usReg3, AFE_REG);
  824   1      
  825   1        Drv_XsiWriteReg(pXSI0Regs, Addr_AFE_BASE_TRACK_CFG, usReg4, AFE_REG); //9 Base¸ú×Ù·½Ê½:   1:Ô­Öµ¸ú×Ù
  826   1        Drv_XsiWriteReg(pXSI1Regs, Addr_AFE_BASE_TRACK_CFG, usReg4, AFE_REG);
  827   1      
  828   1        Drv_XsiWriteReg(pXSI0Regs, Addr_ACC_OFFSET, usReg5, AFE_REG); //10
  829   1        Drv_XsiWriteReg(pXSI1Regs, Addr_ACC_OFFSET, usReg5, AFE_REG);
  830   1      
  831   1        Drv_XsiWriteReg(pXSI0Regs, Addr_TP_MONITOR_THRESHOLD, usReg6, AFE_REG); //11
  832   1        Drv_XsiWriteReg(pXSI1Regs, Addr_TP_MONITOR_THRESHOLD, usReg6, AFE_REG);
  833   1      
  834   1        Drv_XsiWriteReg(pXSI0Regs, Addr_KEY_MONITOR_THRESHOLD, usReg7, AFE_REG); //12
  835   1        Drv_XsiWriteReg(pXSI1Regs, Addr_KEY_MONITOR_THRESHOLD, usReg7, AFE_REG);
  836   1      
  837   1        Drv_XsiWriteReg(pXSI0Regs, Addr_AFE_ANA_K1_CFG0, usReg8, AFE_REG); //13
  838   1        Drv_XsiWriteReg(pXSI1Regs, Addr_AFE_ANA_K1_CFG0, usReg8, AFE_REG);
  839   1      
  840   1        Drv_XsiWriteReg(pXSI0Regs, Addr_AFE_ANA_K2_CFG1, usReg9, AFE_REG); //14
  841   1        Drv_XsiWriteReg(pXSI1Regs, Addr_AFE_ANA_K2_CFG1, usReg9, AFE_REG);
  842   1      
  843   1            
  844   1        // Ó²¼þ´¥Ãþ¼ì²âÄ£Ê½ÏÂ£¬ÎÞARAM READYÖÐ¶Ï£¬²ÉÓÃframe_end Ö¡½áÊøÖÐ¶ÏÀ´ÅÐ¶ÏÉ¨ÃèÍê³É
  845   1        pAsmRegs->usAsmIntEn0|=(TRUE<<BIT_LCD_FRAME_END_EN0); 
  846   1        DrvAsmInterEnable0(BIT_LCD_FRAME_END_EN0);
  847   1        // ¹Ø±ÕARAM ,Tch DetÖÐ¶Ï
  848   1        pAsmRegs->usAsmIntEn0&=~(TRUE<<BIT_LCD_ARAM_RDY_EN0);  
  849   1        pAsmRegs->usAsmIntEn0&=~(TRUE<<BIT_LCD_TCH_DET_EN0);      
  850   1         
  851   1        //ÉèÖÃÔ­Öµ¸ú×Ù£¬É¨Ãè»ñÈ¡base,Ê¹ÄÜbase¸ú×Ù
  852   1        DrvAsmSetMonitorMode(TRUE);         //1:´¥Ãþ¼ì²âÄ£Ê½
  853   1        
  854   1        pAsmRegs->usAsmIntEn0|=(TRUE<<BIT_LCD_ARAM_RDY_EN0);   // ÕâÀï¿ªAramReady,²âÊÔÊÇ·ñ½øAramReadyÖÐ¶Ï  
  855   1        DrvAsmInterEnable0(BIT_LCD_ARAM_RDY_EN0);
  856   1      
  857   1        DrvAfeSetBaseTrack(1,0);          //Ê¹ÄÜbase¸ú×Ù£¬1:Ô­Öµ¸ú×Ù   Step: 0
  858   1        DBG_FLOW("\npAsmRegs->usAsmIntEn0:0x%x",pAsmRegs->usAsmIntEn0);
  859   1      
  860   1        g_ucFrameEndFlag = 0;
  861   1        DrvAsmScanStart();              // ÏÈÆô¶¯Ò»´ÎÉ¨Ãè£¬±£Ö¤BaseRAMÓÐÊý¾Ý£¬ºóÃæÔÙ¿ªÆôDETÖÐ¶Ï¡£
  862   1        DBG_FLOW("\nAsmMonitoMode ScanStart");
  863   1        
  864   1        while(!g_ucFrameEndFlag);
  865   1        
  866   1      //    DrvGetRptRamRawBase();          // MonitorÄ£Ê½²»ÉÏ±¨Êý¾Ýµ½ARAM,Í¨¹ýRptRamÉÏ±¨¡£
  867   1      
  868   1        DrvAfeInitBase();
  869   1      
  870   1        DrvAfeSetHCBTarget(8000,8000);          //ÉèÖÃÓ²¼þCBÐ£ÕýµÄÄ¿±êÖµ
  871   1      
  872   1        //Ê¹ÄÜ´¥Ãþ»½ÐÑÖÐ¶Ï
  873   1        pAsmRegs->usAsmIntWakeEn0|=(TRUE<<BIT_LCD_TCH_DET_WAKE_EN0);   
  874   1          
  875   1        //Ê¹ÄÜ´¥Ãþ¼ì²âÖÐ¶Ï
  876   1      //    pAsmRegs->usAsmIntEn0|=(TRUE<<BIT_LCD_TCH_DET_EN0);  
  877   1      }
  878          
  879          
  880          void DrvAsmReq120hz_Small_LcdBusy(void)
  881          {
  882   1          //REG_15    
  883   1          pAsmRegs->usAsmScanCfg1&=~(1<<BIT_VB_MODE_REQ);    // [8] ÇëÇó: 0:Ð¡¿Ó     
C251 COMPILER V5.54.0.0,  DrvAsmCtrl                                                       26/05/17  20:21:09  PAGE 15  

  884   1      }                              
  885          
  886          void DrvAsmReq60hz_Big_LcdBusy(void)
  887          {
  888   1          //REG_15    
  889   1          pAsmRegs->usAsmScanCfg1|=(1<<BIT_VB_MODE_REQ);     // [8] ÇëÇó: 1:´ó¿Ó 
  890   1      }
  891          
  892          void DrvAsmSkipFramNoLcdBusy(void)
  893          {
  894   1          //REG_15    
  895   1          pAsmRegs->usAsmScanCfg1&=~(1<<BIT_LPF_MODE_TP_TURBO_REQ);    // [9]:TpÇëÇóLCDÔÚskip frameÊ±£¬ÊÇ·ñ¿ª¿Ó
             -¡£0:²»¿ª¿Ó 
  896   1      }                              
  897          
  898          void DrvAsmSkipFramHaveLcdBusy(void)
  899          {
  900   1          //REG_15    
  901   1          pAsmRegs->usAsmScanCfg1|=(1<<BIT_LPF_MODE_TP_TURBO_REQ);     // [9]:TpÇëÇóLCDÔÚskip frameÊ±£¬ÊÇ·ñ¿ª¿Ó
             -¡£ 1:¿ª¿Ó¡£
  902   1      }
  903          
  904          /*******************************************************************************
  905          *   Name: DrvLoadTabCB
  906          *  Brief: ¸üÐÂ±íÏî ,¸ù¾ÝcbÐ£ÕýÄ£Ê½,ÅäÖÃbusyid
  907          *  Input: 
  908          * Output:  
  909          * Return:  
  910          *******************************************************************************/
  911          void DrvLoadTabCB(UINT8 ucTabId,ENUM_AFE_MODE ucCbMode)
  912          {
  913   1            
  914   1          //REG_19   
  915   1          pAsmRegs->usAsmScanDly|=   ((1<<BIT_TAB_EN3)               // [13] Tab3±íÊ¹ÄÜ: 1:Ê¹ÄÜ 
  916   1                                     +(1<<BIT_TAB_EN2)               // [12] Tab2±íÊ¹ÄÜ: 1:Ê¹ÄÜ 
  917   1                                     +(1<<BIT_TAB_EN1)               // [11] Tab1±íÊ¹ÄÜ: 1:Ê¹ÄÜ 
  918   1                                     +(1<<BIT_TAB_EN0));             // [10] Tab0±íÊ¹ÄÜ: 1:Ê¹ÄÜ 
  919   1      
  920   1          switch(ucCbMode)
  921   1          {
  922   2              case AFE_120HZ_MODE:
  923   2              {
  924   3                  pAsmRegs->usAsmScanCfg0&=~(0x7<<BIT_TP_FRAME_NUM);
  925   3                  pAsmRegs->usAsmScanCfg0|=(CB_TP_FRAME_NUM<<BIT_TP_FRAME_NUM);          // [1:0]¶àÖ¡É¨ÃèµÄ×ÜÖ¡
             -Êý 0-3: É¨Ãè1-4¸öTPÖ¡     
  926   3                  
  927   3                  pAsmRegs->usAsmTpFrameCfg0|= ((ucTabId<<BIT_TAB_ID0)                   // [1] µÚ0¸öTPÖ¡ÓÃµÄTa
             -ble±íºÅ
  928   3                                             + (CB_BUSY_ID0<<BIT_BUSY_ID0)               // [0] µÚ0¸öTPÖ¡ÆðÊ¼¿Ó
             -ºÅ 
  929   3                                             + (ucTabId<<BIT_TAB_ID1)                    // µÚ1¸öTPÖ¡ÓÃµÄTable±
             -íºÅ
  930   3                                             + (CB_BUSY_ID1<<BIT_BUSY_ID1));             // µÚ1¸öTPÖ¡ÆðÊ¼¿ÓºÅ
  931   3      
  932   3                  pAsmRegs->usAsmTpFrameCfg1|= ((ucTabId<<BIT_TAB_ID2)                   // [1] µÚ2¸öTPÖ¡ÓÃµÄTa
             -ble±íºÅ
  933   3                                             + (CB_BUSY_ID2<<BIT_BUSY_ID2)               // [0] µÚ2¸öTPÖ¡ÆðÊ¼¿Ó
             -ºÅ 
  934   3                                             + (ucTabId<<BIT_TAB_ID3)                    // µÚ3¸öTPÖ¡ÓÃµÄTable±
             -íºÅ
  935   3                                             + (CB_BUSY_ID3<<BIT_BUSY_ID3));             // µÚ3¸öTPÖ¡ÆðÊ¼¿ÓºÅ  
             -                             
  936   3      
  937   3                  pAsmRegs->usAsmTpFrameCfg2|= ((CB_BUSY_ID4<<BIT_BUSY_ID4)              // [0] µÚ4¸öTPÖ¡ÆðÊ¼¿Ó
             -ºÅ            
  938   3                                             + (CB_BUSY_ID5<<BIT_BUSY_ID5));             // µÚ5¸öTPÖ¡ÆðÊ¼¿ÓºÅ  
C251 COMPILER V5.54.0.0,  DrvAsmCtrl                                                       26/05/17  20:21:09  PAGE 16  

             -                                                       
  939   3      
  940   3                  pAsmRegs->usAsmTpFrameCfg3|= ((CB_BUSY_ID6<<BIT_BUSY_ID6)              // [0] µÚ4¸öTPÖ¡ÆðÊ¼¿Ó
             -ºÅ            
  941   3                                             + (CB_BUSY_ID7<<BIT_BUSY_ID7));             // µÚ5¸öTPÖ¡ÆðÊ¼¿ÓºÅ
  942   3                  break;
  943   3              }
  944   2      
  945   2              case AFE_60HZ_MODE:
  946   2              {
  947   3                  pAsmRegs->usAsmScanCfg0&=~(0x7<<BIT_TP_FRAME_NUM);
  948   3                  pAsmRegs->usAsmScanCfg0|=(0<<BIT_TP_FRAME_NUM);                        // [1:0]¶àÖ¡É¨ÃèµÄ×ÜÖ¡
             -Êý 0-3: É¨Ãè1-4¸öTPÖ¡     
  949   3                  
  950   3                  pAsmRegs->usAsmTpFrameCfg0|= ((ucTabId<<BIT_TAB_ID0)                   // [1] µÚ0¸öTPÖ¡ÓÃµÄTa
             -ble±íºÅ
  951   3                                             + (1<<BIT_BUSY_ID0)                         // [0] µÚ0¸öTPÖ¡ÆðÊ¼¿Ó
             -ºÅ 
  952   3                                             + (ucTabId<<BIT_TAB_ID1)                    // µÚ1¸öTPÖ¡ÓÃµÄTable±
             -íºÅ
  953   3                                             + (1<<BIT_BUSY_ID1));                       // µÚ1¸öTPÖ¡ÆðÊ¼¿ÓºÅ
  954   3      
  955   3                  pAsmRegs->usAsmTpFrameCfg1|= ((ucTabId<<BIT_TAB_ID2)                   // [1] µÚ2¸öTPÖ¡ÓÃµÄTa
             -ble±íºÅ
  956   3                                             + (1<<BIT_BUSY_ID2)                         // [0] µÚ2¸öTPÖ¡ÆðÊ¼¿Ó
             -ºÅ 
  957   3                                             + (ucTabId<<BIT_TAB_ID3)                    // µÚ3¸öTPÖ¡ÓÃµÄTable±
             -íºÅ
  958   3                                             + (1<<BIT_BUSY_ID3));                       // µÚ3¸öTPÖ¡ÆðÊ¼¿ÓºÅ  
             -                             
  959   3      
  960   3                  pAsmRegs->usAsmTpFrameCfg2|= ((1<<BIT_BUSY_ID4)                        // [0] µÚ4¸öTPÖ¡ÆðÊ¼¿Ó
             -ºÅ            
  961   3                                             + (1<<BIT_BUSY_ID5));                       // µÚ5¸öTPÖ¡ÆðÊ¼¿ÓºÅ  
             -                                                       
  962   3      
  963   3                  pAsmRegs->usAsmTpFrameCfg3|= ((1<<BIT_BUSY_ID6)                        // [0] µÚ4¸öTPÖ¡ÆðÊ¼¿Ó
             -ºÅ            
  964   3                                             + (1<<BIT_BUSY_ID7));                       // µÚ5¸öTPÖ¡ÆðÊ¼¿ÓºÅ
  965   3                  break;
  966   3              }
  967   2      
  968   2              case AFE_FREERUN_MODE:
  969   2              {
  970   3                  pAsmRegs->usAsmScanCfg0&=~(0x7<<BIT_TP_FRAME_NUM);
  971   3                  pAsmRegs->usAsmScanCfg0|=(7<<BIT_TP_FRAME_NUM);                        // [1:0]¶àÖ¡É¨ÃèµÄ×ÜÖ¡
             -Êý 0-3: É¨Ãè1-4¸öTPÖ¡     
  972   3      
  973   3                  pAsmRegs->usAsmTpFrameCfg0|= (ucTabId<<BIT_TAB_ID0);                  // [1] µÚ0¸öTPÖ¡ÓÃµÄTab
             -le±íºÅ
  974   3                  break;
  975   3              }
  976   2              
  977   2              default:
  978   2                  break;
  979   2          }
  980   1      }
  981          
  982          /*******************************************************************************
  983          *   Name: DrvAsmClrInt
  984          *  Brief:    
  985          *  Input: 
  986          * Output: 
  987          * Return: 
  988          *******************************************************************************/
  989          void DrvAsmClrInt(void)
C251 COMPILER V5.54.0.0,  DrvAsmCtrl                                                       26/05/17  20:21:09  PAGE 17  

  990          {
  991   1          pAsmRegs->usAsmIntClr0 = 0xFFFF;
  992   1          pAsmRegs->usAsmIntClr1 = 0xFFFF;
  993   1      }
  994          
  995          /*******************************************************************************
  996          *   Name: DrvAsmSetHwMonitorMode
  997          *  Brief: Ó²¼þMonitorÄ£Ê½: 1: ÊÇ£»      0:·ñ   
  998          *  Input: 
  999          * Output: 
 1000          * Return: 
 1001          *******************************************************************************/
 1002          void DrvAsmSetRtcMonitorMode(UINT8 ucModeEn)
 1003          {
 1004   1          //REG_14   
 1005   1          pAsmRegs->usAsmScanCfg0&=~(1<<BIT_MONITOR_MODE);
 1006   1          pAsmRegs->usAsmScanCfg0|=(ucModeEn<<BIT_MONITOR_MODE);     // [15]Ó²¼þ´¥Ãþ¼ì²âÄ£Ê½: 1: ÊÇ£»      0:·ñ
             - 
 1007   1      
 1008   1      
 1009   1          pAsmRegs->usAsmScanCfg1&=~(1<<BIT_HW_MONITOR_EN);
 1010   1          pAsmRegs->usAsmScanCfg1|=(ucModeEn<<BIT_HW_MONITOR_EN);  // [3]Ó²¼þmonitorÊ¹ÄÜ. 1:ÊÇ. 0:·ñ
 1011   1      
 1012   1          if(ucModeEn)
 1013   1          {
 1014   2              // Ó²¼þ´¥Ãþ¼ì²âÄ£Ê½ÏÂ£¬ÎÞARAM READYÖÐ¶Ï£¬²ÉÓÃframe_end Ö¡½áÊøÖÐ¶ÏÀ´ÅÐ¶ÏÉ¨ÃèÍê³É
 1015   2              pAsmRegs->usAsmScanCfg1&=~(1<<BIT_TP_END_SEL);           // [5] Ö¡½áÊøÎ»ÖÃÑ¡Ôñ. 0:tp_frame_end. 1
             -:aram rdy(¹ØÏµµ½Á¬ÐøÉ¨ÃèÏÂÖ¡Æô¶¯Î»ÖÃ)
 1016   2          }
 1017   1          else
 1018   1          {
 1019   2              // Ó²¼þ´¥Ãþ¼ì²âÄ£Ê½ÏÂ£¬ÎÞARAM READYÖÐ¶Ï£¬²ÉÓÃframe_end Ö¡½áÊøÖÐ¶ÏÀ´ÅÐ¶ÏÉ¨ÃèÍê³É
 1020   2              pAsmRegs->usAsmScanCfg1 |=(1<<BIT_TP_END_SEL);           // [5] Ö¡½áÊøÎ»ÖÃÑ¡Ôñ. 0:tp_frame_end. 1
             -:aram rdy(¹ØÏµµ½Á¬ÐøÉ¨ÃèÏÂÖ¡Æô¶¯Î»ÖÃ)        
 1021   2          }
 1022   1      }
 1023          /*******************************************************************************
 1024          *   Name: DrvAsmSetRtcMonitorTimer
 1025          *  Brief: Ó²¼þMonitor timerÉèÖÃ
 1026          *  Input: 
 1027          * Output: 
 1028          * Return: 
 1029          *******************************************************************************/
 1030          void DrvAsmSetRtcMonitorTimer(UINT16 ucTimer)
 1031          {
 1032   1          //REG_39   
 1033   1          pAsmRegs->usAsmHwMonTimer = ucTimer&0x0FFF;
 1034   1          DBG_FLOW("\nASM REG_39:%04x",pAsmRegs->usAsmHwMonTimer);
 1035   1      }  
 1036          
 1037          /*******************************************************************************
 1038          *   Name: DrvAsmSetHwMonPwrEn(UINT8 ucEn)
 1039          *  Brief: Ó²¼þMonitor ¿ØÖÆÉÏÏÂµçÊ±ÐòÉèÖÃ
 1040          *  Input: 
 1041          * Output: 
 1042          * Return: 
 1043          *******************************************************************************/
 1044          void DrvAsmSetHwMonPwrEn(UINT8 ucEn)
 1045          {
 1046   1          //REG_33
 1047   1          if(ucEn == 0)
 1048   1          {
 1049   2              pAsmRegs->usAsmPwrCtrl&= (~ BITn(2));
 1050   2          }
 1051   1          else
 1052   1          {
C251 COMPILER V5.54.0.0,  DrvAsmCtrl                                                       26/05/17  20:21:09  PAGE 18  

 1053   2              pAsmRegs->usAsmPwrCtrl |=  BITn(2);
 1054   2      
 1055   2              
 1056   2          }
 1057   1          DBG_FLOW("\nASM REG_33:%04x",pAsmRegs->usAsmPwrCtrl);
 1058   1      } 
 1059          
 1060          /*******************************************************************************
 1061          *   Name: DrvAfeClkGateEn(UINT8 ucEn)
 1062          *  Brief: AsmÊÇ·ñ×Ô¶¯¿ØÖÆafe clkÃÅ¿Ø
 1063          *  Input: 
 1064          * Output: 
 1065          * Return: 
 1066          *******************************************************************************/
 1067          void DrvAfeClkGateEn(UINT8 ucEn)
 1068          {
 1069   1          if(ucEn == 0)
 1070   1          {
 1071   2              pAsmRegs->usAsmScanCfg0&= (~ BITn(12));
 1072   2          }
 1073   1          else
 1074   1          {
 1075   2              pAsmRegs->usAsmScanCfg0 |=  BITn(12);        
 1076   2          }
 1077   1      
 1078   1      }
 1079          
 1080          
 1081          /*******************************************************************************
 1082          *   Name: DrvAsmMonitoModeInit
 1083          *  Brief: Ó²¼þ´¥Ãþ¼ì²âÄ£Ê½ 
 1084          *  Input: 
 1085          * Output: 
 1086          * Return: 
 1087          *******************************************************************************/
 1088          void DrvAsmRtcMonitoModeInit(void)
 1089          {
 1090   1        //ASM×Ô¶¯ÃÅ¿Øafe clk
 1091   1        DrvAfeClkGateEn(1);
 1092   1      
 1093   1          DrvAfeSetTabBaseTrack(1,0,3);                  //Ê¹ÄÜbase¸ú×Ù£¬1:Ô­Öµ¸ú×Ù   Step: 0 
 1094   1        
 1095   1          /* ¼ÓÔØTab±í*/
 1096   1          //DrvLoadTabMultiple(1,0,0,0,0,3);
 1097   1          DrvLoadTabSingle(3,1);
 1098   1      
 1099   1      #if 1                                       //Ë¢Ò»Ö¡base
 1100   1      
 1101   1          // Ó²¼þ´¥Ãþ¼ì²âÄ£Ê½ÏÂ£¬ÎÞARAM READYÖÐ¶Ï£¬²ÉÓÃframe_end Ö¡½áÊøÖÐ¶ÏÀ´ÅÐ¶ÏÉ¨ÃèÍê³É
 1102   1          pAsmRegs->usAsmIntEn0|=(TRUE<<BIT_LCD_FRAME_END_EN0); 
 1103   1          
 1104   1          // ¹Ø±ÕARAM ,Tch DetÖÐ¶Ï
 1105   1          pAsmRegs->usAsmIntEn0&=~(TRUE<<BIT_LCD_ARAM_RDY_EN0);    
 1106   1          pAsmRegs->usAsmIntEn0&=~(TRUE<<BIT_LCD_TCH_DET_EN0);          
 1107   1             
 1108   1           
 1109   1          g_ucFrameEndFlag = 0;
 1110   1          DrvAsmScanStart();                        // ÏÈÆô¶¯Ò»´ÎÉ¨Ãè£¬±£Ö¤BaseRAMÓÐÊý¾Ý£¬ºóÃæÔÙ¿ªÆôDETÖÐ¶Ï¡£
 1111   1          DBG_FLOW("\nAsmMonitoMode ScanStart");
 1112   1          
 1113   1          while(!g_ucFrameEndFlag);
 1114   1          
 1115   1          DrvGetRptRamRawBase();                    // MonitorÄ£Ê½²»ÉÏ±¨Êý¾Ýµ½ARAM,Í¨¹ýRptRamÉÏ±¨¡£
 1116   1      #endif
 1117   1      
 1118   1          DelayMs(10);
C251 COMPILER V5.54.0.0,  DrvAsmCtrl                                                       26/05/17  20:21:09  PAGE 19  

 1119   1      
 1120   1          DrvAsmSetRtcMonitorTimer(1000);                           //ÉèÖÃ²úÉú¶àÉÙ´ÎrtcÖÐ¶ÏÒÔºó£¬ÈôÃ»ÓÐtouch de
             -t£¬²úÉútimeoutÖÐ¶Ï
 1121   1      
 1122   1      
 1123   1      #if 0
                   pAsmRegs->usAsmIntClr0 |= ((1<<BIT_LCD_TCH_DET_CLR0)
                                           + (1<<BIT_LCD_FRAME_END_CLR0));//ÐèÒªÏÈÇå³ý±êÖ¾Î»£¬·ñÔò»áÎó½øtch detÖÐ¶Ï
                   pAsmRegs->usAsmIntClr1 |= (1<<BIT_HW_MON_TIMEOUT_CLR1);//Çå³ýtimeout±êÖ¾
               #else
 1128   1          pAsmRegs->usAsmIntClr0 = 0xFFFF;
 1129   1          pAsmRegs->usAsmIntClr1 = 0xFFFF;
 1130   1      #endif
 1131   1      
 1132   1        DrvAsmInterEnable0(BIT_LCD_FRAME_END_EN0);
 1133   1        DrvAsmInterEnable0(BIT_LCD_TCH_DET_EN0);
 1134   1        DrvAsmInterEnable1(BIT_HW_MON_TIMEOUT_EN1);
 1135   1      
 1136   1        DrvAsmWakeEnable0(BIT_LCD_TCH_DET_WAKE_EN0);
 1137   1        DrvAsmWakeEnable1(BIT_HW_MON_TIMEOUT_WAKE_EN1);
 1138   1      
 1139   1      
 1140   1      #if 1   
 1141   1          DBG_FLOW("\npAsmRegs->usAsmIntEn0:0x%04x",pAsmRegs->usAsmIntEn0);
 1142   1          DBG_FLOW("\npAsmRegs->usAsmIntEn1:0x%04x",pAsmRegs->usAsmIntEn1);
 1143   1          DBG_FLOW("\npAsmRegs->usAsmIntWakeEn0:0x%04x",pAsmRegs->usAsmIntWakeEn0);
 1144   1          DBG_FLOW("\npAsmRegs->usAsmIntWakeEn1:0x%04x",pAsmRegs->usAsmIntWakeEn1);
 1145   1      #endif
 1146   1      
 1147   1      #if 0     //´òÓ¡asmÅäÖÃ
                   for(i = 0;i < 41; i++)
                   {
                       DBG_FLOW("\nReg[%d]:%04x",i,*(UINT16 *)(ASM_REG_BASE_ADDR + 2*i));
                   }
               #endif 
 1153   1      
 1154   1      }
 1155          
 1156          /*******************************************************************************
 1157          *   Name:  DrvAsmSetPwrOn
 1158          *  Brief:  ÉÏµçÊ±Ðò
 1159          *  Input: 
 1160          * Output: 
 1161          * Return: 
 1162          *******************************************************************************/
 1163          void DrvAsmSetPwrOn(void)
 1164          {
 1165   1          if(((pAsmRegs->usAsmPwrSta)&0x0001) == 0)                   //µ±Ç°ÎªÏÂµç×´Ì¬
 1166   1          {
 1167   2              pAsmRegs->usAsmPwrCtrl |= (1<<BIT_PWRON_START);         //Æô¶¯ÉÏµçÊ±Ðò
 1168   2              while(((pAsmRegs->usAsmPwrSta)&0x0001) == 0);           //µÈ´ýÉÏµçÍê³É
 1169   2          }
 1170   1      }
 1171          
 1172          
 1173          /*******************************************************************************
 1174          *   Name:  DrvAsmSetPwrOff
 1175          *  Brief:  ÉÏµçÊ±Ðò
 1176          *  Input: 
 1177          * Output: 
 1178          * Return: 
 1179          *******************************************************************************/
 1180          void DrvAsmSetPwrOff(void)
 1181          {
 1182   1          if(((pAsmRegs->usAsmPwrSta)&0x0001) == 1)                   //µ±Ç°ÎªÉÏµç×´Ì¬
 1183   1          {
C251 COMPILER V5.54.0.0,  DrvAsmCtrl                                                       26/05/17  20:21:09  PAGE 20  

 1184   2              pAsmRegs->usAsmPwrCtrl |= (1<<BIT_PWROFF_START);        //Æô¶¯ÏÂµçÊ±Ðò
 1185   2              while(((pAsmRegs->usAsmPwrSta)&0x0001) == 1);           //µÈ´ýÏÂµçÍê³É
 1186   2          }
 1187   1      }
 1188          
 1189          /*******************************************************************************
 1190          *   Name:  DrvAsmAramAvail
 1191          *  Brief:  Æô¶¯Ò»´Î£¬¶à´ÎÉ¨Ãè£¬AramÔÚµÚÒ»´ÎÉ¨Ãèºó£¬È¡×ßºó£¬¿ÉÒÔ½øÐÐÏÂ´ÎÉ¨Ãè¡£
 1192          *  Input: 
 1193          * Output: 
 1194          * Return: 
 1195          *******************************************************************************/
 1196          void DrvAsmAramAvail(void)
 1197          {
 1198   1          //REG_13  
 1199   1          pAsmRegs->usAsmScanCtrl|=(1<<BIT_AFE_WR_ARAM_AVAIL_N_CLR); // [2] WO: 1:¿ÉÒÔ²Ù×÷ARAM
 1200   1      }
 1201          
 1202          /*******************************************************************************
 1203          *   Name:  DrvAsmAfeClkGateEn
 1204          *  Brief:  1,×Ô¶¯ÃÅ¿Ø£¬¿ØÖÆAFEÄ£¿éÊ±ÖÓ×Ô¶¯¿ªÆô¡£
 1205          *  Input: 
 1206          * Output: 
 1207          * Return: 
 1208          *******************************************************************************/
 1209          void DrvAsmAfeClkGateEn(void)
 1210          {
 1211   1          //REG_14    
 1212   1          pAsmRegs->usAsmScanCfg0|=(1<<BIT_AFE_CLKGATE_EN);       // [12]×Ô¶¯ÃÅ¿ØAFEÊ±ÖÓ:  1:×Ô¶¯ÃÅ¿Ø 0:²»×Ô¶¯Ã
             -Å¿Ø 
 1213   1      }
 1214          
 1215          /*******************************************************************************
 1216          *   Name: ISR_LcdRun
 1217          *  Brief: lcd run
 1218          *  Input: none
 1219          * Output: none
 1220          * Return: none
 1221          *******************************************************************************/
 1222          void ISR_LcdRun_IRQHandler(void) interrupt  4
 1223          {
 1224   1          UINT16 usAsmIntEn0,usAsmIntEn1;
 1225   1          UINT16 usAsmIntFlag0,usAsmIntFlag1;
 1226   1      
 1227   1          usAsmIntEn0   = pAsmRegs->usAsmIntEn0;
 1228   1          usAsmIntEn1   = pAsmRegs->usAsmIntEn1;
 1229   1      
 1230   1          usAsmIntFlag0 = pAsmRegs->usAsmIntFlag0;
 1231   1          usAsmIntFlag1 = pAsmRegs->usAsmIntFlag1;
 1232   1      
 1233   1          /* LCD RUN int */
 1234   1          if (usAsmIntEn1&LCD_RUN_INT1)
 1235   1          {
 1236   2              if (usAsmIntFlag1&LCD_RUN_INT1)
 1237   2              {
 1238   3                  /* lcd_run¼«ÐÔÉèÖÃ 1: ¼ì²â¸ß */
 1239   3                  if(pAsmRegs->usAsmScanCfg1&BITn(BIT_LCD_RUN_INTPHASE)) 
 1240   3                  {
 1241   4                     pAsmRegs->usAsmScanCfg1&=~(1<<BIT_LCD_RUN_INTPHASE);     // [15] LCD RUNÖÐ¶ÏµçÆ½Ñ¡Ôñ£¬    
             -                           
 1242   4                     DBG_FLOW("\nRun INTPHAS 1");
 1243   4                  }
 1244   3                  else
 1245   3                  {
 1246   4                     pAsmRegs->usAsmScanCfg1|=(1<<BIT_LCD_RUN_INTPHASE);     // [15] LCD RUNÖÐ¶ÏµçÆ½Ñ¡Ôñ£¬     
             -                          
C251 COMPILER V5.54.0.0,  DrvAsmCtrl                                                       26/05/17  20:21:09  PAGE 21  

 1247   4                     DBG_FLOW("\nRun INTPHAS 2");
 1248   4                  }
 1249   3             
 1250   3                  pAsmRegs->usAsmIntClr1 |=LCD_RUN_INT1;
 1251   3                  g_usAsmIntFlag1 |=LCD_RUN_INT1;
 1252   3                  //DBG_FLOW("\nLCD RUN int");
 1253   3              }
 1254   2          }
 1255   1      
 1256   1          /* lcd Deep StandBy int */
 1257   1          if (usAsmIntEn1&LCD_DSTB_INT1)
 1258   1          {
 1259   2              if (usAsmIntFlag1&LCD_DSTB_INT1)
 1260   2              {
 1261   3                  /* lcd_dstb¼«ÐÔÉèÖÃ1: ¼ì²â¸ß */
 1262   3                  if(pAsmRegs->usAsmScanCfg1&BITn(BIT_LCD_DSTB_INTPHASE)) 
 1263   3                  {
 1264   4                     pAsmRegs->usAsmScanCfg1&=~(1<<BIT_LCD_DSTB_INTPHASE);     // [15] LCD DSTBÖÐ¶ÏµçÆ½Ñ¡Ôñ£¬  
             -                            
 1265   4                     DBG_FLOW("\nLCD DSTB_INTPHASE 1");
 1266   4                  }
 1267   3                  else
 1268   3                  {
 1269   4                     pAsmRegs->usAsmScanCfg1|=(1<<BIT_LCD_DSTB_INTPHASE);     // [15] LCD DSTBÖÐ¶ÏµçÆ½Ñ¡Ôñ£¬   
             -                        
 1270   4                     DBG_FLOW("\nLCD DSTB_INTPHASE 2");
 1271   4                  }
 1272   3                  
 1273   3                  pAsmRegs->usAsmIntClr1 |=LCD_DSTB_INT1;
 1274   3                  g_usAsmIntFlag1 |=LCD_DSTB_INT1;
 1275   3                  //DBG_FLOW("\nlcd Deep StandBy int");
 1276   3              }
 1277   2          }       
 1278   1      //    DBG_FLOW("\nISR_LcdRun");
 1279   1      }
 1280          
 1281          /*******************************************************************************
 1282          *   Name: DrvScanCtrl_IRQHandler
 1283          *  Brief: 
 1284          *  Input: 
 1285          * Output: 
 1286          * Return: 
 1287          *******************************************************************************/
 1288          void DrvScanCtrl_IRQHandler(void) interrupt 9
 1289          {
 1290   1          UINT16 usAsmIntEn0,usAsmIntEn1;
 1291   1          UINT16 usAsmIntFlag0,usAsmIntFlag1;
 1292   1      
 1293   1          usAsmIntEn0   = pAsmRegs->usAsmIntEn0;
 1294   1          usAsmIntEn1   = pAsmRegs->usAsmIntEn1;
 1295   1      
 1296   1          usAsmIntFlag0 = pAsmRegs->usAsmIntFlag0;
 1297   1          usAsmIntFlag1 = pAsmRegs->usAsmIntFlag1;
 1298   1      
 1299   1      //    DBG_FLOW("\nint9 0x%x 0x%x",pAsmRegs->usAsmIntFlag0,pAsmRegs->usAsmIntFlag1);
 1300   1          g_usAsmIntSta = DrvAsmGetSta();  
 1301   1      
 1302   1          /* lcd busy fall int */
 1303   1          if (usAsmIntEn0&LCD_BUSY_FALL_INT0)
 1304   1          {
 1305   2              if (usAsmIntFlag0&LCD_BUSY_FALL_INT0)
 1306   2              {
 1307   3                  pAsmRegs->usAsmIntClr0 |= LCD_BUSY_FALL_INT0;   /* Ð´1Çå0 */
 1308   3                  g_usAsmIntFlag0 |= LCD_BUSY_FALL_INT0;
 1309   3                  //DBG_FLOW("\nlcd busy fall: %04x",pAsmRegs->usAsmScanSta0);
 1310   3                  if(g_ucLcdBusyCnt<64)
C251 COMPILER V5.54.0.0,  DrvAsmCtrl                                                       26/05/17  20:21:09  PAGE 22  

 1311   3                  {
 1312   4                      g_ucLcdBusyCnt++;
 1313   4      #if TEST_CUR_LEFT_SCAN               
                               if(g_ucLcdBusyCnt == 3)
                               {
                                    DrvAsmScanStart();
                               }
               #endif                
 1319   4                      //DBG_FLOW("\nlcd busy %04x",g_ucLcdBusyCnt);
 1320   4                  }
 1321   3              }
 1322   2          }
 1323   1      
 1324   1          
 1325   1          /* lcd busy rise int */
 1326   1          if (usAsmIntEn0&LCD_BUSY_RISE_INT0)
 1327   1          {
 1328   2              if (usAsmIntFlag0&LCD_BUSY_RISE_INT0)
 1329   2              {
 1330   3                  pAsmRegs->usAsmIntClr0 |= LCD_BUSY_RISE_INT0;   /* Ð´1Çå0 */
 1331   3                  g_usAsmIntFlag0 |= LCD_BUSY_RISE_INT0;
 1332   3                  DBG_INT("\nint busy rise");
 1333   3                  //DBG_FLOW("\nlcd_busy: %04x tp_busy: %04x",(pAsmRegs->usAsmScanSta1>>10)&0x1,(pAsmRegs->usAs
             -mScanSta1>>11)&0x1);
 1334   3                  //DBG_FLOW("\ntail_margin: %04x",pAsmRegs->usAsmTailMargin);
 1335   3              }
 1336   2          }
 1337   1      
 1338   1          /* lcd dstb int */
 1339   1          if (usAsmIntEn0&LCD_DSTB_RISE_INT0)
 1340   1          {
 1341   2              if (usAsmIntFlag0&LCD_DSTB_RISE_INT0)
 1342   2              {
 1343   3                  pAsmRegs->usAsmIntClr0 |= LCD_DSTB_RISE_INT0;   /* Ð´1Çå0 */
 1344   3                  g_usAsmIntFlag0 |= LCD_DSTB_RISE_INT0;
 1345   3                  DBG_INT("\nint lcd dstb int: %04x",pAsmRegs->usAsmIntSta);
 1346   3              }
 1347   2          }
 1348   1      
 1349   1          /* lcd sync miss fall int */
 1350   1          if (usAsmIntEn0&LCD_SYNC_MISS_FALL_INT0)
 1351   1          {
 1352   2              if (usAsmIntFlag0&LCD_SYNC_MISS_FALL_INT0)
 1353   2              {
 1354   3                  pAsmRegs->usAsmIntClr0 |= LCD_SYNC_MISS_FALL_INT0;   /* Ð´1Çå0 */
 1355   3                  g_usAsmIntFlag0 |= LCD_SYNC_MISS_FALL_INT0;
 1356   3                  DBG_FLOW("\nint lcd sync miss fall");
 1357   3      
 1358   3                  //AFE_RST = 1;
 1359   3                  //AFE_RST = 0;
 1360   3                  g_ucLcdSyncMissFlag = 1;
 1361   3                  //while(1);
 1362   3              }
 1363   2          }
 1364   1      
 1365   1          /* lcd sync miss rise int */
 1366   1          if (usAsmIntEn0&LCD_SYNC_MISS_RISE_INT0)
 1367   1          {
 1368   2              if (usAsmIntFlag0&LCD_SYNC_MISS_RISE_INT0)
 1369   2              {
 1370   3                  pAsmRegs->usAsmIntClr0 |= LCD_SYNC_MISS_RISE_INT0;
 1371   3                  g_usAsmIntFlag0 |= LCD_SYNC_MISS_RISE_INT0;
 1372   3                  AFE_RST = 1;
 1373   3                  AFE_RST = 0;
 1374   3      
 1375   3                  g_ucLcdSyncMissFlag = 1;
C251 COMPILER V5.54.0.0,  DrvAsmCtrl                                                       26/05/17  20:21:09  PAGE 23  

 1376   3                  DBG_FLOW("\nint lcd sync miss rise");
 1377   3              }
 1378   2          }
 1379   1      
 1380   1          /* aram ready int */
 1381   1          if (usAsmIntEn0&ARAM_READY_INT0)
 1382   1          {
 1383   2              if (usAsmIntFlag0&ARAM_READY_INT0)
 1384   2              {
 1385   3                  pAsmRegs->usAsmIntClr0 |= ARAM_READY_INT0;
 1386   3                  g_usAsmIntFlag0 |= ARAM_READY_INT0;
 1387   3                  g_ucAramReadyFlag = 1;
 1388   3      #if TEST_CUR_LEFT_SCAN                          
               //            DBG_FLOW("\nARAM_READY: %04x",pAsmRegs->usAsmScanSta0);//Aram readyÖÐ¶ÏºóÓ²¼þµÃµ½Ö¡id.
               //            DBG_FLOW("\nA lcd_busy: %04x tp_busy: %04x",(pAsmRegs->usAsmScanSta1>>10)&0x1,(pAsmRegs->us
             -AsmScanSta1>>11)&0x1);
               #endif           
 1392   3                  g_ucIntCount++;
 1393   3                  if(g_ucIntCount>=12)
 1394   3                  {
 1395   4                      g_ucIntCount = 0;
 1396   4                  }
 1397   3          
 1398   3      #if TEST_SCAN_START_IN_VSTART_INT                     
 1399   3                  DrvGetAramData();
 1400   3                  if(ucAfeRunMode == TP_FREE_RUN_MODE)  
 1401   3                  {
 1402   4      
 1403   4                  }
 1404   3                  else
 1405   3                  {
 1406   4                      DrvAsmAramAvail(); // realse aram:  Asm¿ÉÒÔÍùAramÐ´ÏÂÒ»¸ötpÖ¡Êý¾Ý, ´¥·¢AramReadyÖÐ¶Ï
 1407   4                  }
 1408   3      #endif  
 1409   3                  //DBG_INT("\nint Aram");
 1410   3              }
 1411   2          }
 1412   1      
 1413   1          /* panel conflict int */
 1414   1          if (usAsmIntEn0&LCD_PANEL_CONFLICT_INT0)
 1415   1          {
 1416   2              if (usAsmIntFlag0&LCD_PANEL_CONFLICT_INT0)
 1417   2              {
 1418   3                  pAsmRegs->usAsmIntClr0 |= LCD_PANEL_CONFLICT_INT0;
 1419   3                  g_usAsmIntFlag0 |= LCD_PANEL_CONFLICT_INT0;
 1420   3                  DBG_FLOW("\n xx int panel conflict xx");
 1421   3              }
 1422   2          }
 1423   1      
 1424   1          /* frame end int */
 1425   1          if (usAsmIntEn0&FRAME_END_INT0)
 1426   1          {
 1427   2              if (usAsmIntFlag0&FRAME_END_INT0)
 1428   2              {
 1429   3                  pAsmRegs->usAsmIntClr0 |= FRAME_END_INT0;
 1430   3                  g_usAsmIntFlag0 |= FRAME_END_INT0;
 1431   3                  g_ucFrameEndFlag = 1;
 1432   3                  DBG_FLOW("\nint frame end");
 1433   3              }
 1434   2          }
 1435   1      
 1436   1          /* afe det int */
 1437   1          if (usAsmIntEn0&AFE_DET_INT0)
 1438   1          {
 1439   2              if (usAsmIntFlag0&AFE_DET_INT0)
 1440   2              {
C251 COMPILER V5.54.0.0,  DrvAsmCtrl                                                       26/05/17  20:21:09  PAGE 24  

 1441   3                  pAsmRegs->usAsmIntClr0 |= AFE_DET_INT0;
 1442   3                  g_usAsmIntFlag0 |= AFE_DET_INT0;
 1443   3                  g_ucTchDetFlag = 1;
 1444   3                  DBG_FLOW("\n============int tch det");
 1445   3              }
 1446   2          }
 1447   1      
 1448   1          /*hw mon timeout int*/
 1449   1          if(usAsmIntEn1&LCD_HW_MON_TIMEOUT_INT1)
 1450   1          {
 1451   2              if(usAsmIntFlag1&LCD_HW_MON_TIMEOUT_INT1)
 1452   2              {       
 1453   3                  pAsmRegs->usAsmIntClr1 |= LCD_HW_MON_TIMEOUT_INT1;
 1454   3                  g_usAsmIntFlag1 |= LCD_HW_MON_TIMEOUT_INT1;
 1455   3                  g_ucTimeOutFlag = 1;
 1456   3                  DBG_INT("\nint hw mon timeout");
 1457   3              }
 1458   2          }    
 1459   1      
 1460   1          /* lcd vstart int */
 1461   1          if (usAsmIntEn0&LCD_VSTART_INT0)
 1462   1          {
 1463   2              if (usAsmIntFlag0&LCD_VSTART_INT0)
 1464   2              {
 1465   3                  pAsmRegs->usAsmIntClr0 |= LCD_VSTART_INT0;
 1466   3                  g_usAsmIntFlag0 |= LCD_VSTART_INT0;
 1467   3                  //DBG_INT("\nint vstart");
 1468   3      
 1469   3      #if TEST_CUR_LEFT_SCAN
                           return;
               #endif
 1472   3      #if TEST_120_ARAM_READY_WAKEUP
                           return;
               #endif 
 1475   3                  DrvAsmScanStart();         
 1476   3              }
 1477   2          }
 1478   1      
 1479   1          /* lcd vmid int */
 1480   1          if (usAsmIntEn0&LCD_VMID_INT0)
 1481   1          {
 1482   2              if (usAsmIntFlag0&LCD_VMID_INT0)
 1483   2              {
 1484   3                  pAsmRegs->usAsmIntClr0 |= LCD_VMID_INT0;
 1485   3                  g_usAsmIntFlag0 |= LCD_VMID_INT0;
 1486   3                  DBG_INT("\nint vmid");
 1487   3              }
 1488   2          }
 1489   1      
 1490   1          /* lcd vend int */
 1491   1          if (usAsmIntEn0&LCD_VEND_INT0)
 1492   1          {
 1493   2              if (usAsmIntFlag0&LCD_VEND_INT0)
 1494   2              {
 1495   3                  pAsmRegs->usAsmIntClr0 |= LCD_VEND_INT0;
 1496   3                  g_usAsmIntFlag0 |= LCD_VEND_INT0;
 1497   3                  DBG_INT("\nint vend");
 1498   3              }
 1499   2          }
 1500   1      
 1501   1          /* lcd vblank int */
 1502   1          if (usAsmIntEn0&LCD_VBLANK_INT0)
 1503   1          {
 1504   2              if (usAsmIntFlag0&LCD_VBLANK_INT0)
 1505   2              {
 1506   3                  pAsmRegs->usAsmIntClr0 |= LCD_VBLANK_INT0;
C251 COMPILER V5.54.0.0,  DrvAsmCtrl                                                       26/05/17  20:21:09  PAGE 25  

 1507   3                  g_usAsmIntFlag0 |= LCD_VBLANK_INT0;
 1508   3                  g_ucLcdBusyCnt = 0;
 1509   3                  DBG_INT("\nint vblank");
 1510   3                  //DBG_FLOW("\nint VBLANK max:0x%x min:0x%x",(pAsmRegs->usAsmScanSta3>>6),(pAsmRegs->usAsmScan
             -Sta3&0x1F));
 1511   3              }
 1512   2          }
 1513   1      
 1514   1      #if 0
                   /* lcd glance fall int */
                   if (usAsmIntEn&LCD_GLANCE_FALL_INT)
                   {
                       if (usAsmIntFlag&LCD_GLANCE_FALL_INT)
                       {
                           pAsmRegs->usAsmIntClr |= LCD_GLANCE_FALL_INT;
                           g_usAsmIntFlag |= LCD_GLANCE_FALL_INT;
                           if ((pAsmRegs->usAsmIntSta&LCD_GLANCE_STA) == 0)
                           {
                               if (pAsmRegs->usAsmIntSta&LCD_RUN_STA)
                               {
                                   g_ucAfeScanMode = TP_NOMAL_MODE;
                               }
                               else
                               {
                                   g_ucAfeScanMode = TP_FREE_RUN_MODE;
                               }
                               AFE_RST = 1;
                               AFE_RST = 0;
                               DBG_INT("\nglance mode fall");
                           }           
                       }
                   }
               
                   /* lcd glance rise int */
                   if (usAsmIntEn&LCD_GLANCE_RISE_INT)
                   {
                       if (usAsmIntFlag&LCD_GLANCE_RISE_INT)
                       {
                           pAsmRegs->usAsmIntClr |= LCD_GLANCE_RISE_INT;
                           g_usAsmIntFlag |= LCD_GLANCE_RISE_INT;
                           if (pAsmRegs->usAsmIntSta&LCD_GLANCE_STA)
                           {
                               g_ucAfeScanMode = TP_GLANCE_MODE;
                               AFE_RST = 1;
                               AFE_RST = 0;
                               DBG_INT("\nglance mode rise");
                           }
                       }
                   }
               
               #endif
 1557   1      
 1558   1          /* lcd run fall int */
 1559   1          if (usAsmIntEn0&LCD_RUN_FALL_INT0)
 1560   1          {
 1561   2              if (usAsmIntFlag0&LCD_RUN_FALL_INT0)
 1562   2              {
 1563   3                  pAsmRegs->usAsmIntClr0 |= LCD_RUN_FALL_INT0;
 1564   3                  if ((pAsmRegs->usAsmIntSta&LCD_RUN_STA) == 0)
 1565   3                  {
 1566   4                      g_usAsmIntFlag0 |= LCD_RUN_FALL_INT0;
 1567   4                      ucAfeRunMode = TP_FREE_RUN_MODE;
 1568   4                      AFE_RST = 1;
 1569   4                      AFE_RST = 0;
 1570   4                      DBG_FLOW("\nint free");
 1571   4                  }
C251 COMPILER V5.54.0.0,  DrvAsmCtrl                                                       26/05/17  20:21:09  PAGE 26  

 1572   3              }
 1573   2          }
 1574   1      
 1575   1          /* lcd run rise int */
 1576   1          if (usAsmIntEn0&LCD_RUN_RISE_INT0)       
 1577   1          {
 1578   2              if (usAsmIntFlag0&LCD_RUN_RISE_INT0)
 1579   2              {
 1580   3                  if (pAsmRegs->usAsmIntSta&LCD_RUN_STA)
 1581   3                  {
 1582   4                      g_usAsmIntFlag0 |= LCD_RUN_RISE_INT0;   
 1583   4                      if (g_ucAfeScanMode == TP_60HZ_RUN_MODE)
 1584   4                      {
 1585   5                          ucAfeRunMode = TP_60HZ_RUN_MODE;
 1586   5                          DBG_FLOW("\nint 60HZ ");
 1587   5                      }
 1588   4                      else
 1589   4                      {
 1590   5                          ucAfeRunMode = TP_120HZ_RUN_MODE;
 1591   5                          DBG_FLOW("\nint 120Hz ");
 1592   5                      }
 1593   4                      pAsmRegs->usAsmIntClr0 |= LCD_RUN_RISE_INT0;
 1594   4      
 1595   4                      AFE_RST = 1;
 1596   4                      AFE_RST = 0;
 1597   4                      DBG_INT("\nint nomal");
 1598   4                  }
 1599   3              }
 1600   2          }
 1601   1          
 1602   1      //  Enable1  
 1603   1          /* lcd STB tick int */
 1604   1          if (usAsmIntEn1&LCD_STB_TICK_INT1)
 1605   1          {
 1606   2              if (usAsmIntFlag1&LCD_STB_TICK_INT1)
 1607   2              {
 1608   3                  pAsmRegs->usAsmIntClr1 |=LCD_STB_TICK_INT1 ;
 1609   3                  g_usAsmIntFlag1 |=LCD_STB_TICK_INT1;
 1610   3                  //DBG_FLOW("\nint STB tick %d 0x%x,0x%x",g_ucLcdBusyCnt,(pAsmRegs->usAsmScanSta2>>6),(pAsmReg
             -s->usAsmScanSta2&0x1F));
 1611   3              }
 1612   2          }
 1613   1          
 1614   1          /* lcd odd even fall int */
 1615   1          if (usAsmIntEn1&LCD_ODD_EVEN_FALL_INT1)
 1616   1          {
 1617   2              if (usAsmIntFlag1&LCD_ODD_EVEN_FALL_INT1)
 1618   2              {
 1619   3                  pAsmRegs->usAsmIntClr1 |=LCD_ODD_EVEN_FALL_INT1 ;
 1620   3                  g_usAsmIntFlag1 |= LCD_ODD_EVEN_FALL_INT1;
 1621   3                  DBG_INT1("\nint odd even fall");
 1622   3              }
 1623   2          }
 1624   1      
 1625   1          /* lcd odd even rise int */
 1626   1          if (usAsmIntEn1&LCD_ODD_EVEN_RISE_INT1)
 1627   1          {
 1628   2              if (usAsmIntFlag1&LCD_ODD_EVEN_RISE_INT1)
 1629   2              {
 1630   3                  pAsmRegs->usAsmIntClr1 |=LCD_ODD_EVEN_RISE_INT1 ;
 1631   3                  g_usAsmIntFlag1 |= LCD_ODD_EVEN_RISE_INT1;
 1632   3                  DBG_INT1("\nint odd even rise");
 1633   3              }
 1634   2          }
 1635   1      
 1636   1          /* lcd VDO node fall int */
C251 COMPILER V5.54.0.0,  DrvAsmCtrl                                                       26/05/17  20:21:09  PAGE 27  

 1637   1          if (usAsmIntEn1&LCD_VDO_MODE_FALL_INT1)
 1638   1          {
 1639   2              if (usAsmIntFlag1&LCD_VDO_MODE_FALL_INT1)
 1640   2              {
 1641   3                  pAsmRegs->usAsmIntClr1 |=LCD_VDO_MODE_FALL_INT1 ;
 1642   3                  g_usAsmIntFlag1 |=LCD_VDO_MODE_FALL_INT1 ;
 1643   3                  DBG_INT1("\nint VDO mode fall");
 1644   3              }
 1645   2          }
 1646   1      
 1647   1          /* lcd VDO node rise int */
 1648   1          if (usAsmIntEn1&LCD_VDO_MODE_RISE_INT1)
 1649   1          {
 1650   2              if (usAsmIntFlag1&LCD_VDO_MODE_RISE_INT1)
 1651   2              {
 1652   3                  pAsmRegs->usAsmIntClr1 |=LCD_VDO_MODE_RISE_INT1 ;
 1653   3                  g_usAsmIntFlag1 |=LCD_VDO_MODE_RISE_INT1 ;
 1654   3                  DBG_INT1("\nint VDO mode rise");
 1655   3              }
 1656   2          }
 1657   1          
 1658   1          /* lcd IDLE node fall int */
 1659   1          if (usAsmIntEn1&LCD_IDLE_MODE_FALL_INT1)
 1660   1          {
 1661   2              if (usAsmIntFlag1&LCD_IDLE_MODE_FALL_INT1)
 1662   2              {
 1663   3                  pAsmRegs->usAsmIntClr1 |=LCD_IDLE_MODE_FALL_INT1 ;
 1664   3                  g_usAsmIntFlag1 |=LCD_IDLE_MODE_FALL_INT1 ;
 1665   3                  DBG_INT1("\nint IDLE mode fall");
 1666   3              }
 1667   2          }
 1668   1      
 1669   1          /* lcd IDLE node rise int */
 1670   1          if (usAsmIntEn1&LCD_IDLE_MODE_RISE_INT1)
 1671   1          {
 1672   2              if (usAsmIntFlag1&LCD_IDLE_MODE_RISE_INT1)
 1673   2              {
 1674   3                  pAsmRegs->usAsmIntClr1 |=LCD_IDLE_MODE_RISE_INT1 ;
 1675   3                  g_usAsmIntFlag1 |=LCD_IDLE_MODE_RISE_INT1 ;
 1676   3                  DBG_INT1("\nint IDLE mode rise");
 1677   3              }
 1678   2          }
 1679   1      
 1680   1          /* lcd 3D node fall int */
 1681   1          if (usAsmIntEn1&LCD_3D_MODE_FALL_INT1)
 1682   1          {
 1683   2              if (usAsmIntFlag1&LCD_3D_MODE_FALL_INT1)
 1684   2              {
 1685   3                  pAsmRegs->usAsmIntClr1 |=LCD_3D_MODE_FALL_INT1 ;
 1686   3                  g_usAsmIntFlag1 |=LCD_3D_MODE_FALL_INT1 ;
 1687   3                  DBG_INT1("\nint 3D mode fall");
 1688   3              }
 1689   2          }
 1690   1      
 1691   1          /* lcd 3D node rise int */
 1692   1          if (usAsmIntEn1&LCD_3D_MODE_RISE_INT1)
 1693   1          {
 1694   2              if (usAsmIntFlag1&LCD_3D_MODE_RISE_INT1)
 1695   2              {
 1696   3                  pAsmRegs->usAsmIntClr1 |=LCD_3D_MODE_RISE_INT1 ;
 1697   3                  g_usAsmIntFlag1 |=LCD_3D_MODE_RISE_INT1 ;
 1698   3                  DBG_INT1("\nint 3D mode rise");
 1699   3              }
 1700   2          }
 1701   1      }
 1702          
C251 COMPILER V5.54.0.0,  DrvAsmCtrl                                                       26/05/17  20:21:09  PAGE 28  

 1703          
 1704          


Module Information          Static   Overlayable
------------------------------------------------
  code size            =         8     ------
  ecode size           =      6465     ------
  data size            =    ------          5
  idata size           =    ------     ------
  pdata size           =    ------     ------
  xdata size           =    ------     ------
  xdata-const size     =    ------     ------
  edata size           =         6       1330
  bit size             =    ------     ------
  ebit size            =    ------     ------
  bitaddressable size  =    ------     ------
  ebitaddressable size =    ------     ------
  far data size        =    ------     ------
  huge data size       =    ------     ------
  const size           =    ------     ------
  hconst size          =      1718     ------
End of Module Information.


C251 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
