C251 COMPILER V5.54.0.0,  Drv_CRC                                                          16/06/17  11:20:19  PAGE 1   


C251 COMPILER V5.54.0.0, COMPILATION OF MODULE Drv_CRC
OBJECT MODULE PLACED IN .\obj\Drv_CRC.obj
COMPILER INVOKED BY: D:\Program Files (x86)\keil\C251\BIN\C251.EXE ..\..\src\source\driver\Drv_CRC.c XSMALL ROM(HUGE) OP
                    -TIMIZE(9,SPEED) BROWSE INCDIR(..\..\src\include;..\..\src\include\Debug;..\..\src\include\Drv;..\..\src\include\task;..\
                    -..\src\include\config) STRING(FAR) DEBUG PRINT(.\list\Drv_CRC.lst) TABS(2) OBJECT(.\obj\Drv_CRC.obj) 

stmt  level    source

    1          
    2          /*******************************************************************************
    3          * Copyright (C) 2017-2019, FocalTech Systems (R)，All Rights Reserved.
    4          *
    5          * File Name: Drv_CRC.c
    6          *
    7          *    Author: tangsujun
    8          *
    9          *   Created: 2017-03-22
   10          *
   11          *  Abstract:
   12          *
   13          * Reference:
   14          *
   15          *   Version:
   16          *
   17          *******************************************************************************/
   18          
   19          /*******************************************************************************
   20          * 1.Included header files
   21          *******************************************************************************/
   22          #include <intrins.h>
   23          #include "CfgGlobal.h"
   24          
   25          
   26          /*******************************************************************************
   27          * 2.Private constant and macro definitions using #define
   28          *******************************************************************************/
   29          
   30          /*******************************************************************************
   31          * 3.Private enumerations, structures and unions using typedef
   32          *******************************************************************************/
   33          typedef struct
   34          {
   35              UINT16 poly;
   36              UINT16 init;
   37              UINT8  refin;
   38              UINT8  refout;
   39              UINT16 xorout;
   40              
   41          }ST_CRC_MODE_Init;
   42          
   43          typedef enum
   44          {
   45               CRC16_IBM_M,
   46               CRC16_MAXIM_M,
   47               CRC16_USB_M,
   48               CRC16_MODBUS_M,
   49               CRC16_LCD_M,
   50               CRC16_SPI0_M,    
   51               CRC16_CCITT_M,
   52              
   53          }ST_CRC_TYPE;
   54          /*******************************************************************************
   55          * 4.Static variables
   56          *******************************************************************************/
   57          
C251 COMPILER V5.54.0.0,  Drv_CRC                                                          16/06/17  11:20:19  PAGE 2   

   58          /*******************************************************************************
   59          * 5.Global variable or extern global variabls/functions
   60          *******************************************************************************/
   61          ST_CRC_MODE_Init Crc_mode;
   62          /*******************************************************************************
   63          * 6.Static function prototypes
   64          *******************************************************************************/
   65          // ---------------- POPULAR POLYNOMIALS ----------------
   66          //  CCITT:      x^16 + x^12 + x^5 + x^0                 (0x1021)
   67          //  CRC-16:     x^16 + x^15 + x^2 + x^0                 (0x8005)
   68          //  CCITT Kermit:     x^16 + x^12 + x^5 + x^0           (0x8408)
   69          #define         CRC_16_POLYNOMIALS      0x8408
   70          /*******************************************************************************
   71          * 6.Static function prototypes
   72          *******************************************************************************/
   73          
   74          
   75          
   76          
   77          /****************************************************************************/
   78          
   79          static  UINT16 XRAM wCRCTable[] = {
   80          0X0000, 0XC0C1, 0XC181, 0X0140, 0XC301, 0X03C0, 0X0280, 0XC241,
   81          0XC601, 0X06C0, 0X0780, 0XC741, 0X0500, 0XC5C1, 0XC481, 0X0440,
   82          0XCC01, 0X0CC0, 0X0D80, 0XCD41, 0X0F00, 0XCFC1, 0XCE81, 0X0E40,
   83          0X0A00, 0XCAC1, 0XCB81, 0X0B40, 0XC901, 0X09C0, 0X0880, 0XC841,
   84          0XD801, 0X18C0, 0X1980, 0XD941, 0X1B00, 0XDBC1, 0XDA81, 0X1A40,
   85          0X1E00, 0XDEC1, 0XDF81, 0X1F40, 0XDD01, 0X1DC0, 0X1C80, 0XDC41,
   86          0X1400, 0XD4C1, 0XD581, 0X1540, 0XD701, 0X17C0, 0X1680, 0XD641,
   87          0XD201, 0X12C0, 0X1380, 0XD341, 0X1100, 0XD1C1, 0XD081, 0X1040,
   88          0XF001, 0X30C0, 0X3180, 0XF141, 0X3300, 0XF3C1, 0XF281, 0X3240,
   89          0X3600, 0XF6C1, 0XF781, 0X3740, 0XF501, 0X35C0, 0X3480, 0XF441,
   90          0X3C00, 0XFCC1, 0XFD81, 0X3D40, 0XFF01, 0X3FC0, 0X3E80, 0XFE41,
   91          0XFA01, 0X3AC0, 0X3B80, 0XFB41, 0X3900, 0XF9C1, 0XF881, 0X3840,
   92          0X2800, 0XE8C1, 0XE981, 0X2940, 0XEB01, 0X2BC0, 0X2A80, 0XEA41,
   93          0XEE01, 0X2EC0, 0X2F80, 0XEF41, 0X2D00, 0XEDC1, 0XEC81, 0X2C40,
   94          0XE401, 0X24C0, 0X2580, 0XE541, 0X2700, 0XE7C1, 0XE681, 0X2640,
   95          0X2200, 0XE2C1, 0XE381, 0X2340, 0XE101, 0X21C0, 0X2080, 0XE041,
   96          0XA001, 0X60C0, 0X6180, 0XA141, 0X6300, 0XA3C1, 0XA281, 0X6240,
   97          0X6600, 0XA6C1, 0XA781, 0X6740, 0XA501, 0X65C0, 0X6480, 0XA441,
   98          0X6C00, 0XACC1, 0XAD81, 0X6D40, 0XAF01, 0X6FC0, 0X6E80, 0XAE41,
   99          0XAA01, 0X6AC0, 0X6B80, 0XAB41, 0X6900, 0XA9C1, 0XA881, 0X6840,
  100          0X7800, 0XB8C1, 0XB981, 0X7940, 0XBB01, 0X7BC0, 0X7A80, 0XBA41,
  101          0XBE01, 0X7EC0, 0X7F80, 0XBF41, 0X7D00, 0XBDC1, 0XBC81, 0X7C40,
  102          0XB401, 0X74C0, 0X7580, 0XB541, 0X7700, 0XB7C1, 0XB681, 0X7640,
  103          0X7200, 0XB2C1, 0XB381, 0X7340, 0XB101, 0X71C0, 0X7080, 0XB041,
  104          0X5000, 0X90C1, 0X9181, 0X5140, 0X9301, 0X53C0, 0X5280, 0X9241,
  105          0X9601, 0X56C0, 0X5780, 0X9741, 0X5500, 0X95C1, 0X9481, 0X5440,
  106          0X9C01, 0X5CC0, 0X5D80, 0X9D41, 0X5F00, 0X9FC1, 0X9E81, 0X5E40,
  107          0X5A00, 0X9AC1, 0X9B81, 0X5B40, 0X9901, 0X59C0, 0X5880, 0X9841,
  108          0X8801, 0X48C0, 0X4980, 0X8941, 0X4B00, 0X8BC1, 0X8A81, 0X4A40,
  109          0X4E00, 0X8EC1, 0X8F81, 0X4F40, 0X8D01, 0X4DC0, 0X4C80, 0X8C41,
  110          0X4400, 0X84C1, 0X8581, 0X4540, 0X8701, 0X47C0, 0X4680, 0X8641,
  111          0X8201, 0X42C0, 0X4380, 0X8341, 0X4100, 0X81C1, 0X8081, 0X4040 };
  112          
  113          UINT16 CRC16 (const UINT8 *nData, UINT16 wLength)
  114          {
  115   1      
  116   1          UINT8 nTemp;
  117   1          UINT16 wCRCWord = 0;//xFFFF;
  118   1      
  119   1         while (wLength--)
  120   1         {
  121   2            nTemp = *nData++ ^ wCRCWord;
  122   2            wCRCWord >>= 8;
  123   2            wCRCWord ^= wCRCTable[nTemp];
C251 COMPILER V5.54.0.0,  Drv_CRC                                                          16/06/17  11:20:19  PAGE 3   

  124   2         }
  125   1         return wCRCWord;
  126   1      
  127   1      }
  128          
  129          UINT8 InvertUint8(UINT8 val)
  130          {
  131   1          UINT8 temp=0,c=0x80,i;  
  132   1         
  133   1          for(i=0;i<8;i++)
  134   1          {
  135   2              if(val&c)
  136   2              temp|=0x01<<i;
  137   2              c>>=1;
  138   2          }
  139   1         
  140   1          return temp;
  141   1      }
  142          
  143          UINT16 InvertUint16(UINT16 val)
  144          {
  145   1          UINT8 temph,templ;
  146   1          
  147   1          temph   =val&0xff;
  148   1          templ   =val>>8;
  149   1          temph=InvertUint8(temph);
  150   1          templ=InvertUint8(templ);
  151   1      
  152   1          return ((UINT16)temph<<8|templ);
  153   1      
  154   1      }
  155          
  156          /*******************************************************************************
  157          *   Name: CRC16_mode_init
  158          *  Brief: CRC16_mode_init
  159          *  Input:
  160          * Output:
  161          * Return:
  162          *******************************************************************************/
  163          void CRC16_mode_init(ST_CRC_TYPE val,ST_CRC_MODE_Init *pCrcInit) 
  164          {
  165   1      
  166   1          switch(val)
  167   1          {
  168   2              case CRC16_IBM_M:
  169   2                              pCrcInit->init=0;
  170   2                              pCrcInit->poly=0X8005;
  171   2                              pCrcInit->refin=1;
  172   2                              pCrcInit->refout=1;
  173   2                              pCrcInit->xorout=0X0000;
  174   2              break;
  175   2              case CRC16_MAXIM_M:
  176   2                              pCrcInit->init=0;
  177   2                              pCrcInit->poly=0X8005;
  178   2                              pCrcInit->refin=1;
  179   2                              pCrcInit->refout=1;
  180   2                              pCrcInit->xorout=0XFFFF;            
  181   2              break;
  182   2              case CRC16_USB_M:
  183   2                              pCrcInit->init=0XFFFF;
  184   2                              pCrcInit->poly=0X8005;
  185   2                              pCrcInit->refin=1;
  186   2                              pCrcInit->refout=1;
  187   2                              pCrcInit->xorout=0XFFFF;           
  188   2              break;
  189   2              case CRC16_MODBUS_M:
C251 COMPILER V5.54.0.0,  Drv_CRC                                                          16/06/17  11:20:19  PAGE 4   

  190   2                              pCrcInit->init=0XFFFF;
  191   2                              pCrcInit->poly=0X8005;
  192   2                              pCrcInit->refin=1;
  193   2                              pCrcInit->refout=1;
  194   2                              pCrcInit->xorout=0X0000;           
  195   2              break;
  196   2              
  197   2              case CRC16_LCD_M:
  198   2                              pCrcInit->init=0XFFFF;
  199   2                              pCrcInit->poly=0X8005;
  200   2                              pCrcInit->refin=0;
  201   2                              pCrcInit->refout=0;
  202   2                              pCrcInit->xorout=0X0000;           
  203   2              break;
  204   2      
  205   2              case CRC16_SPI0_M:
  206   2                              pCrcInit->init=0XFFFF;
  207   2                              pCrcInit->poly=0X1021;//0X8048
  208   2                              pCrcInit->refin=1;
  209   2                              pCrcInit->refout=1;
  210   2                              pCrcInit->xorout=0X0000;           
  211   2              break;
  212   2              case CRC16_CCITT_M:
  213   2                              pCrcInit->init=0x0000;
  214   2                              pCrcInit->poly=0X1021;
  215   2                              pCrcInit->refin=1;
  216   2                              pCrcInit->refout=1;
  217   2                              pCrcInit->xorout=0X0000;           
  218   2              break;
  219   2      
  220   2              
  221   2              default:
  222   2                  break;
  223   2          }
  224   1      
  225   1      }
  226          /*******************************************************************************
  227          *   Name: CRC16_fun
  228          *  Brief: CRC16_fun
  229          *  Input:
  230          * Output:
  231          * Return:
  232          *******************************************************************************/
  233          UINT16 CRC16_fun(UINT8 *puchMsg, UINT16 usDataLen,ST_CRC_MODE_Init Crc_mode)  
  234          {  
  235   1        UINT16 wCRCin  = Crc_mode.init;  
  236   1        UINT16 wCPoly  = Crc_mode.poly;
  237   1        UINT16 wXorOut = Crc_mode.xorout;
  238   1        UINT8  wChar = 0,i;  
  239   1      #if 0    
                 while (usDataLen--)     
                 {  
                       wChar = *puchMsg++; 
                       
                       if(Crc_mode.refin==1)
                       wChar=InvertUint8(wChar); 
                       
                       wCRCin ^= (wChar << 8);  
                       for(i = 0;i < 8;i++)  
                       {  
                         if(wCRCin & 0x8000)  
                           wCRCin = (wCRCin << 1) ^ wCPoly;  
                         else  
                           wCRCin = wCRCin << 1;  
                       }  
                 }
C251 COMPILER V5.54.0.0,  Drv_CRC                                                          16/06/17  11:20:19  PAGE 5   

                 
                 if(Crc_mode.refin==1)
                 wCRCin=InvertUint16(wCRCin);    
                 
               #else
  261   1        wCPoly=InvertUint16(wCPoly);
  262   1        while (usDataLen--)     
  263   1        {  
  264   2              wChar = *puchMsg++; 
  265   2              //DBG_FLOW("\nwChar=%02x",wChar);
  266   2              
  267   2              if(Crc_mode.refin==0)
  268   2              wChar=InvertUint8(wChar); 
  269   2              
  270   2              wCRCin ^= wChar;  
  271   2              for(i = 0;i < 8;i++)  
  272   2              {  
  273   3                if(wCRCin & 0x01)  
  274   3                  wCRCin = (wCRCin >> 1) ^ wCPoly;  
  275   3                else  
  276   3                  wCRCin = wCRCin >> 1;  
  277   3              }  
  278   2        }
  279   1        
  280   1        if(Crc_mode.refin==0)
  281   1        wCRCin=InvertUint16(wCRCin);  
  282   1      #endif
  283   1      
  284   1          return (wCRCin^wXorOut) ; 
  285   1      
  286   1      }
  287          /*******************************************************************************
  288          *   Name: CRCKERMIT
  289          *  Brief: SPI0_DMA CRC算法(CRCKERMIT变种)
  290          *  Input:
  291          * Output:
  292          * Return:
  293          *******************************************************************************/
  294          void CRCKERMIT(const UINT8* pDataIn, UINT16 iLenIn, UINT16* pCRCOut)     
  295          {     
  296   1          UINT16 wTemp = 0,i=0,j=0,c=0;      
  297   1          UINT16 wCRC = 0xffff;      //原始为0，
  298   1        
  299   1          for( i = 0; i < iLenIn; i++)      
  300   1          {  
  301   2              wCRC ^=pDataIn[i];
  302   2              
  303   2              for(j = 0; j < 8; j++)      
  304   2              {      
  305   3                  if(wCRC&0x01) wCRC=(wCRC>>1)^0X8408;
  306   3                  else          wCRC=(wCRC>>1);
  307   3          
  308   3              }      
  309   2          }  
  310   1      
  311   1          *pCRCOut = wCRC;     //高低交换，原始要交换
  312   1      }
  313          
  314          
  315          
  316          /*******************************************************************************
  317          *   Name: CRC16_LCD
  318          *  Brief: LCD CRC算法(CRC_USB变种)
  319          *  Input:
  320          * Output:
  321          * Return:
C251 COMPILER V5.54.0.0,  Drv_CRC                                                          16/06/17  11:20:19  PAGE 6   

  322          *******************************************************************************/
  323          UINT16 CRC16_LCD(UINT8 *puchMsg, UINT16 usDataLen)  
  324          {  
  325   1        UINT16 wCRCin = 0xFFFF;  
  326   1        UINT16 wCPoly = 0x8005;  
  327   1        UINT8  wChar = 0,i;  
  328   1          
  329   1        while (usDataLen--)     
  330   1        {  
  331   2              wChar = *(puchMsg++);  
  332   2              wCRCin ^= (wChar << 8);  
  333   2              for(i = 0;i < 8;i++)  
  334   2              {  
  335   3                if(wCRCin & 0x8000)  
  336   3                  wCRCin = (wCRCin << 1) ^ wCPoly;  
  337   3                else  
  338   3                  wCRCin = wCRCin << 1;  
  339   3              }  
  340   2        }  
  341   1      
  342   1        return wCRCin;
  343   1      
  344   1      }  
  345          
  346          /*******************************************************************************
  347          *   Name: crc_sick
  348          *  Brief: crc_sick
  349          *  Input:
  350          * Output:
  351          * Return:
  352          *******************************************************************************/
  353          UINT16 crc_sick( const unsigned char *input_str, UINT16 num_bytes )
  354          {
  355   1      
  356   1          UINT16 crc;
  357   1          UINT16 low_byte;
  358   1          UINT16 high_byte;
  359   1          UINT16 short_c;
  360   1          UINT16 short_p;
  361   1          const UINT8 *ptr;
  362   1          UINT16 a;
  363   1      
  364   1          crc     = 0;
  365   1          ptr     = input_str;
  366   1          short_p = 0;
  367   1      
  368   1          if ( ptr != NULL ) 
  369   1              for (a=0; a<num_bytes; a++) 
  370   1              {
  371   2      
  372   2                  short_c = 0x00ff & (UINT16) *ptr;
  373   2      
  374   2                  if ( crc & 0x8000 ) crc = ( crc << 1 ) ^ CRC_POLY_16;
  375   2                  else                crc =   crc << 1;
  376   2      
  377   2                  crc    ^= ( short_c | short_p );
  378   2                  short_p = short_c << 8;
  379   2      
  380   2                  ptr++;
  381   2              }
  382   1      
  383   1          low_byte  = (crc & 0xff00) >> 8;
  384   1          high_byte = (crc & 0x00ff) << 8;
  385   1          crc       = low_byte | high_byte;
  386   1      
  387   1          return crc;
C251 COMPILER V5.54.0.0,  Drv_CRC                                                          16/06/17  11:20:19  PAGE 7   

  388   1      
  389   1      }  /* crc_sick */
  390          
  391          /******************************************************************************
  392          *
  393          *   Name: Drv_CRC16
  394          *  Brief: 
  395          *  Input:
  396          * Output:
  397          * Return:
  398          ******************************************************************************/
  399          static UINT8 Drv_CRC16(void)
  400          {
  401   1          UINT8 k=0,buf[16]={0XFF,0XE0,0X01,0X5A,0XA4,0X80,0X02,0Xe7,0X22,0X00,0X44,0X55};
  402   1          UINT16 i,len=5,temp=0,lcd_ecc,*ptr16=0;
  403   1          UINT8 Lbuf[8]={0XA4,0X67,0xA3,0xd7,0xff,0xe0};
  404   1          
  405   1          len=6;
  406   1          CRC16_mode_init(CRC16_IBM_M,&Crc_mode);    
  407   1          lcd_ecc=CRC16_fun(Lbuf,len,Crc_mode);
  408   1          DBG_FLOW("\nCRC16_IBM=%04x",lcd_ecc);
  409   1      
  410   1          CRC16_mode_init(CRC16_MAXIM_M,&Crc_mode);    
  411   1          lcd_ecc=CRC16_fun(Lbuf,len,Crc_mode);
  412   1          DBG_FLOW("\nCRC16_MAXIM_M=%04x",lcd_ecc);
  413   1      
  414   1          CRC16_mode_init(CRC16_USB_M,&Crc_mode);    
  415   1          lcd_ecc=CRC16_fun(Lbuf,len,Crc_mode);
  416   1          DBG_FLOW("\nCRC16_USB_M=%04x",lcd_ecc);
  417   1      
  418   1          CRC16_mode_init(CRC16_MODBUS_M,&Crc_mode);    
  419   1          lcd_ecc=CRC16_fun(Lbuf,len,Crc_mode);
  420   1          DBG_FLOW("\nCRC16_MODBUS_M=%04x",lcd_ecc);
  421   1      
  422   1      
  423   1          CRC16_mode_init(CRC16_LCD_M,&Crc_mode);    
  424   1          lcd_ecc=CRC16_fun(Lbuf,len,Crc_mode);
  425   1          DBG_FLOW("\nCRC16_LCD_M=%04x",lcd_ecc);
  426   1      
  427   1          CRC16_mode_init(CRC16_SPI0_M,&Crc_mode);    
  428   1          lcd_ecc=CRC16_fun(Lbuf,len,Crc_mode);
  429   1          DBG_FLOW("\nCRC16_SPI0_M=%04x",lcd_ecc);
  430   1      
  431   1          CRC16_mode_init(CRC16_CCITT_M,&Crc_mode);    
  432   1          lcd_ecc=CRC16_fun(Lbuf,len,Crc_mode);
  433   1          DBG_FLOW("\nCRC16_CCITT_M=%04x",lcd_ecc);
  434   1          
  435   1          lcd_ecc=crc_sick(Lbuf,len);
  436   1          DBG_FLOW("\nsickcrc[2]=%04x",lcd_ecc);
  437   1      
  438   1      
  439   1      
  440   1          lcd_ecc=CRC16(Lbuf,len);
  441   1          DBG_FLOW("\ncrc16[4]=%04x",lcd_ecc);
  442   1          
  443   1      
  444   1      
  445   1          CRCKERMIT(Lbuf,len,&lcd_ecc);   
  446   1          DBG_FLOW("\nCRCKERMIT=%04x",lcd_ecc);
  447   1      
  448   1      
  449   1      
  450   1          return 1;
  451   1      }
*** WARNING C47 IN LINE 402 OF ..\..\src\source\driver\Drv_CRC.c: 'i': unreferenced local variable
  452          
C251 COMPILER V5.54.0.0,  Drv_CRC                                                          16/06/17  11:20:19  PAGE 8   

  453          
  454          /*******************************************************************************
  455          *   Name: Test_Xbus()
  456          *  Brief:
  457          *  Input:
  458          * Output:
  459          * Return:
  460          *******************************************************************************/
  461          void Test_CRC(void)
  462          {
  463   1          UINT8 test_cnt=1;   
  464   1      
  465   1          while(test_cnt--)
  466   1          {
  467   2              Drv_CRC16();
  468   2          }
  469   1          //HOLD;
  470   1      }
  471          
  472          
  473          


Module Information          Static   Overlayable
------------------------------------------------
  code size            =    ------     ------
  ecode size           =      1235     ------
  data size            =    ------     ------
  idata size           =    ------     ------
  pdata size           =    ------     ------
  xdata size           =    ------     ------
  xdata-const size     =    ------     ------
  edata size           =       520         38
  bit size             =    ------     ------
  ebit size            =    ------     ------
  bitaddressable size  =    ------     ------
  ebitaddressable size =    ------     ------
  far data size        =    ------     ------
  huge data size       =    ------     ------
  const size           =    ------     ------
  hconst size          =       720     ------
End of Module Information.


C251 COMPILATION COMPLETE.  1 WARNING(S),  0 ERROR(S)
