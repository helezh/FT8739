C251 COMPILER V5.54.0.0,  uart                                                             16/06/17  11:20:19  PAGE 1   


C251 COMPILER V5.54.0.0, COMPILATION OF MODULE uart
OBJECT MODULE PLACED IN .\obj\uart.obj
COMPILER INVOKED BY: D:\Program Files (x86)\keil\C251\BIN\C251.EXE ..\..\src\source\Debug\uart.c XSMALL ROM(HUGE) OPTIMI
                    -ZE(9,SPEED) BROWSE INCDIR(..\..\src\include;..\..\src\include\Debug;..\..\src\include\Drv;..\..\src\include\task;..\..\s
                    -rc\include\config) STRING(FAR) DEBUG PRINT(.\list\uart.lst) TABS(2) OBJECT(.\obj\uart.obj) 

stmt  level    source

    1          /*******************************************************************************
    2          * Copyright (C) 2012-2013, FocalTech Systems (R)，All Rights Reserved.
    3          *
    4          * File Name: uart.c
    5          *
    6          *    Author: linjianjun
    7          *
    8          *   Created: 2013-06-05
    9          *
   10          *  Abstract:
   11          *
   12          * Reference: test Uart introduction:
   13          *******************************************************************************/
   14          
   15          /*******************************************************************************
   16          * 1.Included header files
   17          *******************************************************************************/
   18          #include <string.h>
   19          #include "uart.h"
   20          
   21          #if _BLK_DBG_EN
   22          /*******************************************************************************
   23          * 2.Private constant and macro definitions using #define
   24          *******************************************************************************/
   25          #define CHAR_NOF   0x00
   26          
   27          #define U1_ON    (EC = 1)
   28          #define U1_OFF   (EC = 0)
   29          
   30          #define UBUF_OUT_LEN 250        //size of serial transimit buffer
   31          #define UBUF_IN_LEN  32         //size of serial receiving buffer 
   32          
   33          //#define UART_CLK  (48000000/16/(MAIN_CLK+1))
   34          #define UART_CLK  (48000000/16/CLK_DIV(MAIN_CLK))
   35          /*******************************************************************************
   36          * 3.Private enumerations, structures and unions using typedef
   37          *******************************************************************************/
   38          
   39          /*******************************************************************************
   40          * 4.Static variables
   41          *******************************************************************************/
   42          UINT8 XRAM s_aucUartOutBuf[UBUF_OUT_LEN];  // transmit buffer
   43          
   44          UINT8 XRAM s_ucUartTxPos = 0;              // transmit current pos
   45          volatile UINT8 XRAM s_ucUartTxStore = 0;   // mcu store
   46          volatile UINT8 XRAM s_ucUartTxLen = 0;     // length of transmit
   47          
   48          #if _UART_RECEIVE_EN
               UINT8 XRAM s_aucUartInBuf[UBUF_IN_LEN];    // receiving buffer
               
               UINT8 XRAM s_ucUartRxPos = 0;              // receive current pos
               volatile UINT8 XRAM s_ucUartRxStore = 0;   // host store
               volatile UINT8 XRAM s_ucUartRxLen = 0;     // length of receive
               #endif
   55          
   56          /*******************************************************************************
   57          * 5.Global variable or extern global variabls/functions
C251 COMPILER V5.54.0.0,  uart                                                             16/06/17  11:20:19  PAGE 2   

   58          *******************************************************************************/
   59          
   60          /*******************************************************************************
   61          * 6.Static function prototypes
   62          *******************************************************************************/
   63          UINT8 CLK_DIV(UINT8 div)
   64          {
   65   1          switch(div)
   66   1          {
   67   2              case 0:
   68   2                  return 1;
   69   2              case 1:
   70   2                  return 2;
   71   2              case 2:
   72   2                  return 4;
   73   2              case 3:
   74   2                  return 8;
   75   2              default:
   76   2                  return 1;
   77   2          }
   78   1      }
   79          
   80          
   81          /*******************************************************************************
   82          * Name: putchar
   83          * Brief:
   84          * Input:
   85          * Output: None
   86          * Return: None
   87          *******************************************************************************/
   88          SINT8 putchar(SINT8 ch)
   89          {
   90   1          U1_ON;
   91   1          while (s_ucUartTxLen >= UBUF_OUT_LEN);    //缓冲区满时，等待
   92   1          //暂停串行输出中断，以免数据比较时出错
   93   1          U1_OFF;
   94   1          s_ucUartTxLen++;                          //长度+1
   95   1          if (s_ucUartTxLen == 1)                   //第一个数据，直接发送,不进入缓冲区
   96   1          {
   97   2              UARTBUF = ch;
   98   2          }
   99   1          else
  100   1          {
  101   2              s_aucUartOutBuf[s_ucUartTxStore++] = ch;  //数据放入缓冲区,先入后加
  102   2              if (s_ucUartTxStore >= UBUF_OUT_LEN)
  103   2              {
  104   3                  s_ucUartTxStore = 0;                //环形缓冲区
  105   3              }
  106   2          }
  107   1          U1_ON;
  108   1          return 0;
  109   1      }
  110          
  111          #if _UART_RECEIVE_EN
               /*******************************************************************************
               * Name: getbyte
               * Brief:
               * Input:
               * Output: None
               * Return: None
               *******************************************************************************/
               UINT8 getbyte(UINT16 timeout)
               {
                   UINT8 ch;
                   // 接收缓冲区为空时，等待数据或超时处理
                   while (s_ucUartRxLen == 0)
C251 COMPILER V5.54.0.0,  uart                                                             16/06/17  11:20:19  PAGE 3   

                   {
                       if (timeout-- == 0)
                       {
                           return CHAR_NOF;
                       }
                   }
                   // 暂停串行接收中断，以免数据比较时出错
                   U1_OFF;
                   ch = s_aucUartInBuf[s_ucUartRxPos++];
                   if (s_ucUartRxPos >= UBUF_IN_LEN)
                   {
                       s_ucUartRxPos = 0;        // 环形缓冲区
                   }
                   s_ucUartRxLen--;
                   // 恢复串口接收功能
                   U1_ON;
                   return (ch);
               }
               #endif
  143          
  144          /*******************************************************************************
  145          * Name: ISR_Uart
  146          * Brief:
  147          * Input:
  148          * Output: None
  149          * Return: None
  150          *******************************************************************************/
  151          void ISR_Uart(void) interrupt 6
  152          {
  153   1      #if _UART_RECEIVE_EN
                   if (UART_RI)
                   {
                       UART_RI = 0;
                       // 溢出，则放弃该数据
                       if (s_ucUartRxLen >= UBUF_IN_LEN)
                       {
                           s_ucUartRxLen = UBUF_IN_LEN;
                       }
                       else
                       {
                           s_ucUartRxLen++;
                           s_aucUartInBuf[s_ucUartRxStore++] = UARTBUF;
                           if (s_ucUartRxStore >= UBUF_IN_LEN)
                           {
                               s_ucUartRxStore = 0;
                           }
                       }
                   }
               #endif
  173   1          if (UART_TI)
  174   1          {
  175   2              UART_TI = 0;
  176   2              if (s_ucUartTxLen)  // 长度不为0，继续发送
  177   2              {
  178   3                  s_ucUartTxLen--;
  179   3                  if (s_ucUartTxLen != 0)
  180   3                  {
  181   4                      // 未发送完继续发送
  182   4                      UARTBUF = s_aucUartOutBuf[s_ucUartTxPos++];
  183   4                      if (s_ucUartTxPos >= UBUF_OUT_LEN)
  184   4                      {
  185   5                          s_ucUartTxPos = 0;
  186   5                      }
  187   4                  }
  188   3              }
  189   2          }
C251 COMPILER V5.54.0.0,  uart                                                             16/06/17  11:20:19  PAGE 4   

  190   1      }
  191          
  192          /*******************************************************************************
  193          * Name: DrvUartInit
  194          * Brief:
  195          * baud =48M/(16X(2^10-uartrel)) = 3 000 000/(2^10 - uartrel)
  196          * uartrel = 2^10 - 3000000/baud = 0x400 - 3000000/baud
  197          * Input:
  198          * Output: None
  199          * Return: None
  200          *******************************************************************************/
  201          void DrvUartInit(void)
  202          {
  203   1          UINT16 cnt;
  204   1          
  205   1      #if _UART_OUT_GPIO3
  206   1          UART1  = 1;
  207   1          UART0  = 0;
  208   1          P0MOD |= BITn(7);  // UART: P0.7
  209   1      #endif
  210   1      
  211   1      #if _UART_OUT_GPIO2
                   UART1  = 0;
                   UART0  = 1;
                   P0MOD |= BITn(6);  // UART: P0.6
               #endif
  216   1      
  217   1      #if _UART_OUT_GPIO4
                   UART1  = 1;
                   UART0  = 1;
               
                 if(BUS_SEL == 1)
                 {
                     P1MOD |= BITn(7);  // UART: P1.7    
                 }
                 else if(SPI_REPLACE_EN == 0)
                 {
                   P0MOD |= BITn(3);
                 }
                 
               
               #endif
  232   1      
  233   1      
  234   1      #if _UART_RECEIVE_EN   //接收使能
                 UART_REN1 = 1;
               
               #if _UART_OUT_GPIO3
                 UART_INH = 0;
                 UART_INL = 1;
                 P0MOD |= BITn(6);  //uart rx p0.6
               #else
                 UART_INH = 1;
                 UART_INL = 0;
                 P0MOD |= BITn(7);  //uart rx p0.7
               #endif
               #endif
  247   1          Uart_IPH = 1;
  248   1          Uart_IPL = 1;
  249   1      
  250   1          UARTCKEN = 1;                        //开启UART时钟
  251   1          UARTCON |= BITn(7);                  //工作方式为8位
  252   1      
  253   1          cnt = (0x400 - UART_CLK/BAUD_RATE);  //波特率设置
  254   1          UART_RELH = cnt/256;
  255   1          UART_RELL = cnt%256;  
C251 COMPILER V5.54.0.0,  uart                                                             16/06/17  11:20:19  PAGE 5   

  256   1      
  257   1      }
  258          void wait_printf_done(void)
  259          {
  260   1          while(s_ucUartTxLen);
  261   1      
  262   1      }
  263          #endif //_U_DEBUG
  264          


Module Information          Static   Overlayable
------------------------------------------------
  code size            =         4     ------
  ecode size           =       236     ------
  data size            =    ------     ------
  idata size           =    ------     ------
  pdata size           =    ------     ------
  xdata size           =    ------     ------
  xdata-const size     =    ------     ------
  edata size           =       253     ------
  bit size             =    ------     ------
  ebit size            =    ------     ------
  bitaddressable size  =    ------     ------
  ebitaddressable size =    ------     ------
  far data size        =    ------     ------
  huge data size       =    ------     ------
  const size           =    ------     ------
  hconst size          =        15     ------
End of Module Information.


C251 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
