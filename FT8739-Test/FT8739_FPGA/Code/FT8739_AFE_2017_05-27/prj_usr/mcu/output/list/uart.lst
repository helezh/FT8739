C251 COMPILER V5.54.0.0,  uart                                                             26/05/17  20:22:53  PAGE 1   


C251 COMPILER V5.54.0.0, COMPILATION OF MODULE uart
OBJECT MODULE PLACED IN ..\output\obj\uart.obj
COMPILER INVOKED BY: D:\software\Keil\C251\BIN\C251.EXE ..\..\src\source\Debug\uart.c SMALL ROM(HUGE) OPTIMIZE(9,SPEED) 
                    -REGFILE(..\output\obj\mcu.ORC) BROWSE INCDIR(..\..\src\include;..\..\src\include\app;..\..\src\include\flow;..\..\src\in
                    -clude\driver\;..\..\src\include\lib_drv\;..\..\src\include\config;..\..\src\include\Debug) DEFINE(__FT8836__) DEBUG PRIN
                    -T(..\output\list\uart.lst) TABS(2) OBJECT(..\output\obj\uart.obj) 

stmt  level    source

    1          /*******************************************************************************
    2          * Copyright (C) 2012-2014, FocalTech Systems (R)，All Rights Reserved.
    3          *
    4          * File Name: uart.c
    5          *
    6          *    Author: xinkunpeng
    7          *
    8          *   Created: 2013-05-26
    9          *
   10          *  Abstract:             
   11          *
   12          * Reference:
   13          *
   14          *******************************************************************************/
   15          
   16          /*******************************************************************************
   17          * 1.Included header files
   18          *******************************************************************************/
   19          #include "uart.h"
   20          #include "DrvSysCtrl.h"
   21          #include <string.h>
   22          
   23          #if _BLK_DBG_EN
   24          /*******************************************************************************
   25          * 2.Private constant and macro definitions using #define
   26          *******************************************************************************/
   27          #define CHAR_NOF   0x00
   28          
   29          #define U1_ON    (EC = 1)
   30          #define U1_OFF   (EC = 0)
   31          
   32          #define UBUF_OUT_LEN 1024        //size of serial transimit buffer
   33          #define UBUF_IN_LEN  32         //size of serial receiving buffer 
   34          
   35          #define UART_CLK  (48000000/16/(MAIN_CLK+1))
   36          
   37          /*******************************************************************************
   38          * 3.Private enumerations, structures and unions using typedef
   39          *******************************************************************************/
   40          
   41          /*******************************************************************************
   42          * 4.Static variables
   43          *******************************************************************************/
   44          UINT8 XRAM s_aucUartOutBuf[UBUF_OUT_LEN];  // transmit buffer
   45          
   46          UINT16 XRAM s_ucUartTxPos = 0;              // transmit current pos
   47          VOLATILE UINT16 XRAM s_ucUartTxStore = 0;   // mcu store 
   48          VOLATILE UINT16 XRAM s_ucUartTxLen = 0;     // length of transmit
   49          
   50          #ifdef UART_RECEIVE_OPEN
   51          UINT8 XRAM s_aucUartInBuf[UBUF_IN_LEN];    // receiving buffer
   52          
   53          UINT8 XRAM s_ucUartRxPos = 0;              // receive current pos
   54          VOLATILE UINT8 XRAM s_ucUartRxStore = 0;   // host store
   55          VOLATILE UINT8 XRAM s_ucUartRxLen = 0;     // length of receive
   56          #endif
C251 COMPILER V5.54.0.0,  uart                                                             26/05/17  20:22:53  PAGE 2   

   57          
   58          /*******************************************************************************
   59          * 5.Global variable or extern global variabls/functions
   60          *******************************************************************************/
   61          
   62          /*******************************************************************************
   63          * 6.Static function prototypes
   64          *******************************************************************************/
   65          
   66          /*******************************************************************************
   67          *   Name: putchar
   68          *  Brief: 
   69          *  Input: 
   70          * Output: None
   71          * Return: None
   72          *******************************************************************************/ 
   73          SINT8 putchar(SINT8 ch)
   74          { 
   75   1          U1_ON;
   76   1          while (s_ucUartTxLen >= UBUF_OUT_LEN)         //缓冲区满时，等待
   77   1          {
   78   2          }
   79   1          //暂停串行输出中断，以免数据比较时出错    
   80   1          U1_OFF;
   81   1      
   82   1          s_ucUartTxLen++;                              //长度+1
   83   1          if (s_ucUartTxLen == 1)                       //第一个数据，直接发送,不进入缓冲区   
   84   1          {
   85   2              UARTBUF = ch; 
   86   2          }    
   87   1          else
   88   1          {
   89   2              s_aucUartOutBuf[s_ucUartTxStore++] = ch;  //数据放入缓冲区,先入后加
   90   2              if (s_ucUartTxStore >= UBUF_OUT_LEN) 
   91   2              {
   92   3                  s_ucUartTxStore = 0;                  //环形缓冲区
   93   3              }
   94   2          }    
   95   1      
   96   1          U1_ON;
   97   1          return 0;
   98   1      } 
   99          
  100          #ifdef UART_RECEIVE_OPEN
  101          /*******************************************************************************
  102          *   Name: getbyte
  103          *  Brief: 
  104          *  Input: 
  105          * Output: None
  106          * Return: None
  107          *******************************************************************************/
  108          UINT8 getbyte(UINT16 timeout)
  109          { 
  110   1          UINT8 XRAM ch; 
  111   1      
  112   1          // 接收缓冲区为空时，等待数据或超时处理
  113   1          while (s_ucUartRxLen == 0)
  114   1          {
  115   2              if (timeout-- == 0) 
  116   2              {
  117   3                  return CHAR_NOF;
  118   3              }
  119   2          }                                       
  120   1          // 暂停串行接收中断，以免数据比较时出错
  121   1          U1_OFF;
  122   1          ch = s_aucUartInBuf[s_ucUartRxPos++];        
C251 COMPILER V5.54.0.0,  uart                                                             26/05/17  20:22:53  PAGE 3   

  123   1          if (s_ucUartRxPos >= UBUF_IN_LEN) 
  124   1          {   
  125   2              s_ucUartRxPos = 0;        // 环形缓冲区
  126   2          }
  127   1          s_ucUartRxLen--;
  128   1      
  129   1          // 恢复串口接收功能
  130   1          U1_ON;
  131   1      
  132   1          return (ch);
  133   1      } 
  134          #endif
  135          
  136          /*******************************************************************************
  137          *   Name: ISR_Uart
  138          *  Brief: 
  139          *  Input: 
  140          * Output: None
  141          * Return: None
  142          *******************************************************************************/
  143          void ISR_Uart(void) interrupt 6
  144          { 
  145   1      #ifdef UART_RECEIVE_OPEN
  146   1          if (UART_RI)  
  147   1          {
  148   2              UART_RI = 0;
  149   2      
  150   2              // 溢出，则放弃该数据
  151   2              if (s_ucUartRxLen >= UBUF_IN_LEN) 
  152   2              {    
  153   3                  s_ucUartRxLen = UBUF_IN_LEN;
  154   3              }
  155   2              else
  156   2              {
  157   3                  s_ucUartRxLen++;    
  158   3                  s_aucUartInBuf[s_ucUartRxStore++] = UARTBUF;    
  159   3                  if (s_ucUartRxStore >= UBUF_IN_LEN) 
  160   3                  {
  161   4                      s_ucUartRxStore = 0;
  162   4                  }
  163   3              }    
  164   2          }
  165   1      #endif
  166   1      
  167   1          if (UART_TI)
  168   1          { 
  169   2              UART_TI = 0;
  170   2              if (s_ucUartTxLen)  // 长度不为0，继续发送
  171   2              { 
  172   3                  s_ucUartTxLen--;
  173   3                  if (s_ucUartTxLen != 0)
  174   3                  {
  175   4                      // 未发送完继续发送
  176   4                      UARTBUF = s_aucUartOutBuf[s_ucUartTxPos++]; 
  177   4                      if (s_ucUartTxPos >= UBUF_OUT_LEN) 
  178   4                      {
  179   5                          s_ucUartTxPos = 0;
  180   5                      }
  181   4                  }
  182   3              }
  183   2          }
  184   1      }
  185           
  186          /*******************************************************************************
  187          *   Name: DrvUartInit
  188          *  Brief: 
C251 COMPILER V5.54.0.0,  uart                                                             26/05/17  20:22:53  PAGE 4   

  189          *
  190          * baud =48M/(16X(2^10-uartrel)) = 3 000 000/(2^10 - uartrel)
  191          * uartrel = 2^10 - 3000000/baud = 0x400 - 3000000/baud
  192          *
  193          *  Input: 
  194          * Output: None
  195          * Return: None
  196          *******************************************************************************/
  197          void DrvUartInit(void)
  198          {
  199   1          UINT16 XRAM cnt;
  200   1      
  201   1        UART_REN1 = 1;  
  202   1      #if 1
  203   1          UART1 = 1;
  204   1          UART0 = 0; //P07
  205   1          // IO
  206   1          P0MOD |= BITn(7);
  207   1      
  208   1        UART_INH = 0;
  209   1        UART_INL = 1;
  210   1        P0MOD |= BITn(6);
  211   1      #else
                   UART1 = 0;
                   UART0 = 1; //P06
                   // IO
                   P0MOD |= BITn(6);
               
                 UART_INH = 1;
                 UART_INL = 0;
                 P0MOD |= BITn(7); 
               #endif
  221   1          /* 开启UART时钟 */
  222   1          // CLK_WP   = 1;
  223   1          UARTCKEN = 1;    
  224   1      
  225   1      
  226   1          // 工作方式8位
  227   1          UARTCON |= BITn(7);
  228   1      
  229   1          // 波特率
  230   1          cnt = (0x400 - UART_CLK/BAUD_RATE);
  231   1          UART_RELH = cnt/256;
  232   1          UART_RELL = cnt%256;
  233   1      }
  234          
  235          #ifdef UART_RECEIVE_OPEN
  236          void uart0_putc(SINT8 ch)
  237          {
  238   1          while(!UART_TI);
  239   1          UART_TI = 0;
  240   1          UARTBUF = ch;
  241   1      }
  242          
  243          void uart0_puts(const UINT8*buf)
  244          {
  245   1          UINT8 XRAM i = 0;
  246   1          
  247   1          while(buf[i]!= 0)
  248   1          {
  249   2              while(UART_TI)
  250   2              {
  251   3                  if(buf[i] == '\n' )
  252   3                  {
  253   4                      UARTBUF = '\r';
  254   4                      while(!UART_TI);
C251 COMPILER V5.54.0.0,  uart                                                             26/05/17  20:22:53  PAGE 5   

  255   4                      UART_RI = 0;
  256   4                  }
  257   3              
  258   3                  UARTBUF = buf[i++];
  259   3                  if(buf[i] == 0)
  260   3                      return;
  261   3              }
  262   2              while(!UART_TI);
  263   2              UART_TI = 0;
  264   2          }
  265   1      }
  266          
  267          SINT8 uart0_getc(void)
  268          {
  269   1          SINT8 XRAM rec_ch = -1;
  270   1          
  271   1          while(!UART_RI);
  272   1        UART_RI = 0;
  273   1          rec_ch = UARTBUF;
  274   1          
  275   1          return rec_ch;
  276   1      }
  277          
  278          void Uart_GetString(SINT8 *string)
  279          {
  280   1          SINT8 XRAM c;
  281   1          SINT8 XRAM node = 0;
  282   1          
  283   1          while(1)
  284   1          {
  285   2              c = uart0_getc();
  286   2              string[node] = c;
  287   2                    
  288   2              if((string[node-1]==92)&&(string[node]=='n'))
  289   2              {
  290   3              node--;
  291   3              break;
  292   3              }
  293   2              else if(string[node]== 0xd)
  294   2              {
  295   3              uart0_putc('\r');
  296   3              uart0_putc('\n');
  297   3              break;
  298   3              }
  299   2              else
  300   2              uart0_putc(c);
  301   2              
  302   2              node++;
  303   2          }
  304   1          string[node]='\0';
  305   1      }
  306          
  307          SINT8 Uart_GetIntNum(SINT8 *string)
  308          {
  309   1          SINT8 XRAM LastIndex;
  310   1          SINT8 XRAM i;
  311   1          SINT8 XRAM Result = 0;
  312   1          SINT8 XRAM Base = 10;
  313   1          
  314   1          
  315   1          if(string[0]=='0' && (string[1]=='x' || string[1]=='X'))
  316   1          {
  317   2             Base = 16;
  318   2             string += 2;
  319   2          }
  320   1          
C251 COMPILER V5.54.0.0,  uart                                                             26/05/17  20:22:53  PAGE 6   

  321   1          LastIndex = strlen(string) - 1;
  322   1          if(LastIndex < 0)
  323   1              return -1;
  324   1          
  325   1          if(string[LastIndex]=='h' || string[LastIndex]=='H' )
  326   1          {
  327   2              Base = 16;
  328   2              string[LastIndex] = 0;
  329   2              LastIndex--;
  330   2          }
  331   1          
  332   1          if(Base==10)        //decimalist
  333   1          {
  334   2              Result = atoi(string);
  335   2          }
  336   1          else        //Hex
  337   1          {
  338   2              for(i=0;i<=LastIndex;i++)
  339   2              {
  340   3                  if(isalpha(string[i]))
  341   3                  {
  342   4                      if(isupper(string[i]))
  343   4                          Result = (Result<<4) + string[i] - 'A' + 10;
  344   4                      else
  345   4                          Result = (Result<<4) + string[i] - 'a' + 10;
  346   4                  }
  347   3                  else
  348   3                      Result = (Result<<4) + string[i] - '0';
  349   3              }
  350   2          }
  351   1          
  352   1          return Result;
  353   1      }
  354          
  355          void TestFun1(void)
  356          {
  357   1          DBG_FLOW(" RUN Fun1\n");
  358   1      }
  359          
  360          void TestFun2(void)
  361          {
  362   1          DBG_FLOW(" RUN Fun2\n");
  363   1      }
  364          
  365          
  366          SINT8  XRAM string[50];
  367          
  368          void XRAM *function[][2] =
  369          {
  370            (void XRAM *)TestFun1, (void XRAM *)"Test APP1", 
  371            (void XRAM *)TestFun2, (void XRAM *)"Test APP2", 
  372            (void XRAM *)0,(void XRAM *)0
  373          };
  374          
  375          
  376          #if 1
  377          
  378          void TestUart(void)
  379          {
  380   1          UINT8 XRAM ch;
  381   1          UINT8 XRAM i = 0;
  382   1        DBG_FLOW("\nDSV_CON:%02x",DSV_CON);
  383   1        DBG_FLOW("\nSYS_CON:%02x",SYSCON);
  384   1        DBG_FLOW("\nP0MOD:%02x",P0MOD);
  385   1        DBG_FLOW("\nUARTCON:%02x",UARTCON);
  386   1      
C251 COMPILER V5.54.0.0,  uart                                                             26/05/17  20:22:53  PAGE 7   

  387   1        DelayMs(2000);
  388   1        
  389   1        EC = 0;
  390   1          while(1)
  391   1          {
  392   2      #if 0    
                   while(UART_RI == 0);//等待接收
                   UART_RI = 0;
                   ch = UARTBUF;
               
                   UARTBUF = ch;
                   while(UART_TI == 0);//等待发送
                   UART_TI = 0;
               #else
  401   2        
  402   2              ch = uart0_getc();
  403   2          UARTBUF = ch;
  404   2          while(UART_TI == 0);//等待发送
  405   2          UART_TI = 0;
  406   2      
  407   2              if(ch=='s' || ch=='S')
  408   2              break;
  409   2      #endif    
  410   2          }
  411   1        EC = 1;
  412   1      #if 0
                   while(1)
                   {
                       DBG_FLOW("\n\n Test Program Ver1.00\n") ;
                
                       while(1)
                       {
                           DBG_FLOW("  %2d:%s",i,function[i][1]);
                           i++;
                           if((int)(function[i][0])==0)
                           {
                               DBG_FLOW("\n");
                               break;
                           }     
                       }
                   }
               #endif    
  429   1          DBG_FLOW("\nSelect the function to test : \n");
  430   1          Uart_GetString(string);
  431   1          i=Uart_GetIntNum(string);
  432   1          
  433   1          if(i>=0 && (i<(sizeof(function)/8)) )
  434   1              ( (void (*)(void)) (function[i][0]) )();
  435   1      }
  436          #endif
  437          #endif
  438          
  439          
  440          
  441          #endif //_U_DEBUG
  442          


Module Information          Static   Overlayable
------------------------------------------------
  code size            =         4     ------
  ecode size           =       922     ------
  data size            =        12     ------
  idata size           =    ------     ------
  pdata size           =    ------     ------
  xdata size           =    ------     ------
  xdata-const size     =    ------     ------
C251 COMPILER V5.54.0.0,  uart                                                             26/05/17  20:22:53  PAGE 8   

  edata size           =      1115     ------
  bit size             =    ------     ------
  ebit size            =    ------     ------
  bitaddressable size  =    ------     ------
  ebitaddressable size =    ------     ------
  far data size        =    ------     ------
  huge data size       =    ------     ------
  const size           =    ------     ------
  hconst size          =       178     ------
End of Module Information.


C251 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
