C251 COMPILER V5.54.0.0,  DrvAfePara                                                       26/05/17  20:21:06  PAGE 1   


C251 COMPILER V5.54.0.0, COMPILATION OF MODULE DrvAfePara
OBJECT MODULE PLACED IN ..\output\obj\DrvAfePara.obj
COMPILER INVOKED BY: D:\software\Keil\C251\BIN\C251.EXE ..\..\src\source\driver\DrvAfePara.c SMALL ROM(HUGE) OPTIMIZE(9,
                    -SPEED) REGFILE(..\output\obj\mcu.ORC) BROWSE INCDIR(..\..\src\include;..\..\src\include\app;..\..\src\include\flow;..\..
                    -\src\include\driver\;..\..\src\include\lib_drv\;..\..\src\include\config;..\..\src\include\Debug) DEFINE(__FT8836__) DEB
                    -UG PRINT(..\output\list\DrvAfePara.lst) TABS(2) OBJECT(..\output\obj\DrvAfePara.obj) 

stmt  level    source

    1          /*******************************************************************************
    2          * Copyright (C) 2013-2014, FocalTech Systems (R)£¬All Rights Reserved.
    3          *
    4          * File Name: DrvAfePara.c
    5          *
    6          *    Author: linjianjun
    7          *
    8          *   Created: 2014-10-30
    9          *
   10          *  Abstract:
   11          *
   12          * Reference:
   13          *
   14          * Version:   V0.1
   15          *
   16          *******************************************************************************/
   17          
   18          /*******************************************************************************
   19          * 1.Included header files
   20          *******************************************************************************/
   21          #include "CfgGlobal.h"
   22          
   23          //#include "DrvAfePara.h"
   24          //#include "DrvAfeCtrl.h"
   25          #include "DrvSysCtrl.h"
   26          //#include "DrvClb.h"
   27          
   28          #include "libDrv.h"
   29          
   30          //#include "AppAfeCtrl.h"
   31          //#include "AppDataStruct.h"
   32          #include "AppHostComm.h"
   33          //#include "DrvMonDet.h"
   34          #include "DrvAfe.h"
   35          /*******************************************************************************
   36          * 2.Private constant and macro definitions using #define
   37          *******************************************************************************/
   38          
   39          
   40          /*******************************************************************************
   41          * 3.Private enumerations, structures and unions using typedef
   42          *******************************************************************************/
   43          
   44          
   45          /*******************************************************************************
   46          * 4.Static variables
   47          *******************************************************************************/
   48          
   49          /*******************************************************************************
   50          * 5.Global variable or extern global variabls/functions
   51          *******************************************************************************/
   52          ST_McapParameter XRAM g_pMcapData;
   53          ST_McapParameter XRAM *g_pMcapPara = &g_pMcapData;
   54          ST_AfeTabList XRAM g_pAfeTab;
   55          ST_AfeTabList XRAM *g_pAfeTabPara = &g_pAfeTab;
   56          /******************************************************************************
C251 COMPILER V5.54.0.0,  DrvAfePara                                                       26/05/17  20:21:06  PAGE 2   

   57          * 6.Static function prototypes
   58          *******************************************************************************/
   59          
   60          /*******************************************************************************
   61          *   Name:  DrvAfeSelACCRam
   62          *  Brief:  
   63          *  Input: ucbit:  0:1-15bit;   1:16-31bit   2: 32-47bit  3:48-63bit
   64          * Output: 
   65          * Return: 
   66          *******************************************************************************/
   67          void DrvAfeSelACCRam(UINT8 ucbit)
   68          {
   69   1          UINT16 XSI0RegValue = 0;
   70   1          UINT16 XSI1RegValue = 0;
   71   1      
   72   1          XSI0RegValue = Drv_XsiReadReg(pXSI0Regs,ID_AFE_BASE + 0x05,AFE_REG);
   73   1          XSI1RegValue = Drv_XsiReadReg(pXSI1Regs,ID_AFE_BASE + 0x05,AFE_REG);
   74   1          
   75   1          XSI0RegValue = XSI0RegValue&0xFF87;
   76   1          XSI1RegValue = XSI1RegValue&0xFF87;
   77   1          
   78   1          XSI0RegValue|= (1<<3)+(ucbit<<5);  
   79   1          XSI1RegValue|= (1<<3)+(ucbit<<5);  
   80   1         
   81   1          Drv_XsiWriteReg(pXSI0Regs,ID_AFE_BASE + 0x05, XSI0RegValue,AFE_REG);
   82   1          Drv_XsiWriteReg(pXSI1Regs,ID_AFE_BASE + 0x05, XSI1RegValue,AFE_REG);   
   83   1      }
   84          
   85          void DebugReadAFEReg(void)
   86          {
   87   1          UINT16 XRAM ReadRegs0;
   88   1          UINT16 XRAM ReadRegs1;
   89   1          UINT16 XRAM addr;
   90   1      
   91   1          for(addr = 0; addr < 75; addr++)
   92   1          {
   93   2              ReadRegs0 = Drv_XsiReadReg(pXSI0Regs,addr,AFE_REG);
   94   2              ReadRegs1 = Drv_XsiReadReg(pXSI1Regs,addr,AFE_REG);
   95   2              DBG_FLOW("\nReg%d 0x%x  0x%x ",addr,ReadRegs0,ReadRegs1);
   96   2          }
   97   1      }
   98          
   99          UINT16 DebugReadAFEOneReg(UINT16 ucAddr)
  100          {
  101   1          UINT16 XRAM ReadRegs0;
  102   1          UINT16 XRAM ReadRegs1;
  103   1      
  104   1          ReadRegs0 = Drv_XsiReadReg(pXSI0Regs,ucAddr,AFE_REG);
  105   1          ReadRegs1 = Drv_XsiReadReg(pXSI1Regs,ucAddr,AFE_REG);
  106   1      
  107   1          if(ReadRegs0 == ReadRegs1)
  108   1          {
  109   2              return ReadRegs0;
  110   2          }
  111   1          else
  112   1          {
  113   2              DBG_FLOW("\nReg Error");
  114   2              return 0;
  115   2          }
  116   1      }
  117          
  118          /*******************************************************************************
  119          *   Name: DrvAfeSelTaborRepRam
  120          *  Brief: MCUÑ¡ÔñÒª·ÃÎÊµÄMemory
  121          *  Input: 
  122          * Output: 
C251 COMPILER V5.54.0.0,  DrvAfePara                                                       26/05/17  20:21:06  PAGE 3   

  123          * Return: 
  124          *******************************************************************************/
  125          void DrvAfeSelTaborRepRam(UINT8 RamSelect)
  126          {
  127   1          UINT16 XSI0RegValue = 0;
  128   1          UINT16 XSI1RegValue = 0;
  129   1      
  130   1          XSI0RegValue = Drv_XsiReadReg(pXSI0Regs,ID_AFE_BASE + 0x05,AFE_REG);
  131   1          XSI1RegValue = Drv_XsiReadReg(pXSI1Regs,ID_AFE_BASE + 0x05,AFE_REG);
  132   1          
  133   1          XSI0RegValue = XSI0RegValue&0xFF87;
  134   1          XSI1RegValue = XSI1RegValue&0xFF87;
  135   1          
  136   1          if(RamSelect == AREA_TBL_RAM)
  137   1          {
  138   2              XSI0RegValue|= (0<<3);  
  139   2              XSI1RegValue|= (0<<3);  
  140   2          }
  141   1          else if(RamSelect == AREA_BASE_ORDER) //RPT Memory
  142   1          {
  143   2              XSI0RegValue|= (2<<3);  
  144   2              XSI1RegValue|= (2<<3);  
  145   2          }
  146   1          else if(RamSelect == AREA_BASE_ACC)
  147   1          {
  148   2              XSI0RegValue|= (1<<3);  
  149   2              XSI1RegValue|= (1<<3);  
  150   2          }
  151   1      
  152   1          Drv_XsiWriteReg(pXSI0Regs,ID_AFE_BASE + 0x05, XSI0RegValue,AFE_REG);
  153   1          Drv_XsiWriteReg(pXSI1Regs,ID_AFE_BASE + 0x05, XSI1RegValue,AFE_REG);   
  154   1      }
  155          
  156          
  157          /*******************************************************************************
  158          *   Name: DrvAFEGroupSelReg1
  159          *  Brief: 5×éMux, GroupA,GroupBÑ¡Ôñ
  160          *  [G1 G2 G3 G4]| [G5 G6 G7 G8 G9]
  161          *     Group A   |    Group B            
  162          *  Input: 
  163          * Output: 
  164          * Return: 
  165          *******************************************************************************/
  166          void DrvAFEGroupSelReg1(UINT8 ucMux1_GA,UINT8 ucMux1_GB,UINT8 ucMux2_GA,UINT8 ucMux2_GB,UINT8 ucMux3_GA,U
             -INT8 ucMux3_GB)
  167          {
  168   1          UINT16 XRAM usPanelMode;
  169   1      
  170   1          usPanelMode = ((ucMux3_GB<<BIT_PANEL_MUX3_GROUPB_SEL)   //12                       
  171   1                        +(ucMux3_GA<<BIT_PANEL_MUX3_GROUPA_SEL)   //10
  172   1                        +(ucMux2_GB<<BIT_PANEL_MUX2_GROUPB_SEL)   //7
  173   1                        +(ucMux2_GA<<BIT_PANEL_MUX2_GROUPA_SEL)   //5
  174   1                        +(ucMux1_GB<<BIT_PANEL_MUX1_GROUPB_SEL)   //2
  175   1                        +(ucMux1_GA<<BIT_PANEL_MUX1_GROUPA_SEL)); //0
  176   1      
  177   1          Drv_XsiWriteReg(pXSI0Regs, Addr_PANEL_MODE_CFG0, usPanelMode, AFE_REG);
  178   1          Drv_XsiWriteReg(pXSI1Regs, Addr_PANEL_MODE_CFG0, usPanelMode, AFE_REG);
  179   1      }
  180          
  181          
  182          /*******************************************************************************
  183          *   Name: DrvAFEGroupSelReg2
  184          *  Brief: 5×éMux, GroupA,GroupBÑ¡Ôñ
  185          *  [G1 G2 G3 G4]| [G5 G6 G7 G8 G9]
  186          *     Group A   |    Group B            
  187          *  Input: 
C251 COMPILER V5.54.0.0,  DrvAfePara                                                       26/05/17  20:21:06  PAGE 4   

  188          * Output: 
  189          * Return: 
  190          *******************************************************************************/
  191          void DrvAFEGroupSelReg2(UINT8 ucMux4_GA,UINT8 ucMux4_GB,UINT8 ucMux5_GA,UINT8 ucMux5_GB)
  192          {
  193   1          UINT16 XRAM usPanelMode;
  194   1      
  195   1          usPanelMode = ((ucMux5_GB<<BIT_PANEL_MUX5_GROUPB_SEL)    //8                                  
  196   1                        +(ucMux5_GA<<BIT_PANEL_MUX5_GROUPA_SEL)    //5
  197   1                        +(ucMux4_GB<<BIT_PANEL_MUX4_GROUPB_SEL)    //2
  198   1                        +(ucMux4_GA<<BIT_PANEL_MUX4_GROUPA_SEL));  //0
  199   1      
  200   1          Drv_XsiWriteReg(pXSI0Regs, Addr_PANEL_MODE_CFG1, usPanelMode, AFE_REG);
  201   1          Drv_XsiWriteReg(pXSI1Regs, Addr_PANEL_MODE_CFG1, usPanelMode, AFE_REG);
  202   1      }
  203          
  204          
  205          /*******************************************************************************
  206          *   Name: DrvGetRptRamOrder
  207          *  Brief: µØÖ·: 0-323: TpÍ¨µÀÓëKey¼üÉÏ±¨RawdataËùÐèµÄOrder
  208          *         µØÖ·  324-325: key diff Noise max, TP diff Noise max.
  209          *         µØÖ·: 326-653: TpÍ¨µÀÓëKey¼ü Rawdata/Base
  210          *  Input: 
  211          * Output: 
  212          * Return: 
  213          *******************************************************************************/
  214          void DrvGetRptRamOrder(void)
  215          {
  216   1          UINT16 XRAM j;
  217   1          UINT16 XRAM ausBaseBuf[CH_LEN];
  218   1      
  219   1          DrvAfeSelTaborRepRam(AREA_BASE_ORDER);
  220   1          
  221   1          Drv_XsiRead(pXSI0Regs, BASE_RAM_START_ADDR, ausBaseBuf, CH_LEN, AFE_REG); 
  222   1          for(j = 0;j < CH_LEN;j++)
  223   1          {
  224   2              //if(j<10)
  225   2              {
  226   3                  DBG_FLOW("\n[%d] %d ",j,ausBaseBuf[j]);
  227   3              }
  228   2          }   
  229   1      }
  230          
  231          void DrvInitRptRam(void)
  232          {
  233   1          UINT16 XRAM j;
  234   1      
  235   1          UINT16 XRAM ausBaseBufL[BASE_RAM_BASE_LEN + BASE_RAM_KEY_LEN]; // Base + 4key
  236   1          UINT16 XRAM ausBaseBufR[BASE_RAM_BASE_LEN + BASE_RAM_KEY_LEN]; // Base + 4key
  237   1      
  238   1          for(j = 0;j <CH_LEN_MAX;j++)
  239   1          {
  240   2              ausBaseBufL[j] = 0;
  241   2              ausBaseBufR[j] = 0;
  242   2          } 
  243   1      
  244   1          DrvAfeSelTaborRepRam(AREA_BASE_ORDER);
  245   1          
  246   1          Drv_XsiWrite(pXSI0Regs, BASE_RAM_START_ADDR + BASE_RAM_TP_RAWBASE_ADDR, ausBaseBufL,CH_LEN_MAX, AFE_R
             -EG);  
  247   1          Drv_XsiWrite(pXSI1Regs, BASE_RAM_START_ADDR + BASE_RAM_TP_RAWBASE_ADDR, ausBaseBufR,CH_LEN_MAX, AFE_R
             -EG);  
  248   1      }
  249          
  250          
  251          
C251 COMPILER V5.54.0.0,  DrvAfePara                                                       26/05/17  20:21:06  PAGE 5   

  252          
  253          
  254          
  255          /*******************************************************************************
  256          *   Name: DrvAfeScanMode
  257          *  Brief:          
  258          *  Input: 
  259          * Output: 
  260          * Return: 
  261          *******************************************************************************/
  262          void DrvAfeScanMode(UINT8 ucMode,UINT16 usScantimes)
  263          {
  264   1          UINT16 XRAM usScanCfg0;
  265   1          
  266   1          usScanCfg0 = ((usScantimes<<BIT_AFE_SCAN_TIMES)                                          
  267   1                       +(ucMode<<BIT_AFE_SCAN_MODE<<0));
  268   1          Drv_XsiWriteReg(pXSI0Regs, Addr_AFE_SCAN_CFG0, usScanCfg0, AFE_REG);
  269   1          Drv_XsiWriteReg(pXSI1Regs, Addr_AFE_SCAN_CFG0, usScanCfg0, AFE_REG);
  270   1      }
  271          
  272          /*******************************************************************************
  273          *   Name: DrvAfeSofeReset
  274          *  Brief:  AFEÈí¸´Î»Âß¼­  
  275          *  Input: 
  276          * Output: 
  277          * Return: 
  278          *******************************************************************************/
  279          void DrvAfeSofeReset(void)
  280          {
  281   1          DBG_FLOW("\nDrvAfeSofeReset: ");  
  282   1          AFE_RST = 1;   
  283   1          AFE_RST = 0; 
  284   1      }
  285          
  286          void DrvAfeEnCOF(void)
  287          {
  288   1          UINT16 XRAM usConfigValue;
  289   1      
  290   1          usConfigValue = (rAFE_SYS_CFG0|(1<<8));
  291   1          Drv_XsiWriteReg(pXSI0Regs, Addr_AFE_SYS_CFG0, usConfigValue, AFE_REG);
  292   1          Drv_XsiWriteReg(pXSI1Regs, Addr_AFE_SYS_CFG0, usConfigValue, AFE_REG);
  293   1      
  294   1          DBG_FLOW("\nReg4 0x%x ",DebugReadAFEOneReg(4));
  295   1      //    while(1);
  296   1      }
  297          
  298          void DrvAfeEnRawdataNum(UINT16 ucRptRawdataNum)
  299          {
  300   1          Drv_XsiWriteReg(pXSI0Regs, Addr_RPT_RAWDATA_NUM, ucRptRawdataNum, AFE_REG); //rRPT_RAWDATA_NUM
  301   1          Drv_XsiWriteReg(pXSI1Regs, Addr_RPT_RAWDATA_NUM, ucRptRawdataNum, AFE_REG);
  302   1          DBG_FLOW("\nReg49 0x%x ",DebugReadAFEOneReg(49));
  303   1      //    while(1);    
  304   1      }
  305          
  306          void DrvAfeEn4mux(void)
  307          {
  308   1          UINT16 XRAM usConfigValue;
  309   1      
  310   1          usConfigValue = (rAFE_SYS_CFG0|(1<<2));
  311   1          Drv_XsiWriteReg(pXSI0Regs, Addr_AFE_SYS_CFG0, usConfigValue, AFE_REG);
  312   1          Drv_XsiWriteReg(pXSI1Regs, Addr_AFE_SYS_CFG0, usConfigValue, AFE_REG);
  313   1      
  314   1          DBG_FLOW("\nReg4 0x%x ",DebugReadAFEOneReg(4));
  315   1      }
  316          
  317          void DrvGetTabRam(void)
C251 COMPILER V5.54.0.0,  DrvAfePara                                                       26/05/17  20:21:06  PAGE 6   

  318          {
  319   1          UINT8 i;
  320   1          UINT8 ucLen;
  321   1          UINT16 usAddr;
  322   1          UINT16 XRAM Buf[TAB_RAM_LEN];
  323   1      
  324   1          usAddr = TAB_RAM_START_ADDR;
  325   1          ucLen  = TAB_RAM_LEN;
  326   1      
  327   1          XSICKEN = 1;
  328   1          
  329   1          /* set ram buf as tab ram: */
  330   1          DrvAfeSelTaborRepRam(AREA_TBL_RAM);
  331   1      
  332   1          memset(Buf,0xff,TAB_RAM_LEN*2);
  333   1          Drv_XsiRead(pXSI0Regs,usAddr,Buf,ucLen,AFE_REG);
  334   1          for (i = 0; i < ucLen; i++)
  335   1          {
  336   2              if (Buf[i] != 0x00)
  337   2              {
  338   3                  DBG_FLOW("\n\rRam_Tab1[%02d] = 0x%04x",i,Buf[i]);
  339   3              }
  340   2          }
  341   1          DBG_FLOW("\n\rRead Ram_Tab1 is ok!");
  342   1      
  343   1          usAddr += TAB_RAM_LEN;
  344   1          memset(Buf,0xff,TAB_RAM_LEN*2);
  345   1          Drv_XsiRead(pXSI0Regs,usAddr,Buf,ucLen,AFE_REG);
  346   1          for (i = 0; i < ucLen; i++)
  347   1          {
  348   2              if (Buf[i] != 0x00)
  349   2              {
  350   3                  DBG_FLOW("\n\rRam_Tab2[%02d] = 0x%04x",i,Buf[i]);
  351   3              }
  352   2          }
  353   1          DBG_FLOW("\n\rRead Ram_Tab2 is ok!");
  354   1      
  355   1          usAddr += TAB_RAM_LEN;
  356   1          memset(Buf,0xff,TAB_RAM_LEN*2);
  357   1          Drv_XsiRead(pXSI0Regs,usAddr,Buf,ucLen,AFE_REG);
  358   1          for (i = 0; i < ucLen; i++)
  359   1          {
  360   2              if (Buf[i] != 0x00)
  361   2              {
  362   3                  DBG_FLOW("\n\rRam_Tab3[%02d] = 0x%04x",i,Buf[i]);
  363   3              }
  364   2          }
  365   1          DBG_FLOW("\n\rRead Ram_Tab3 is ok!");
  366   1      
  367   1          usAddr += TAB_RAM_LEN;
  368   1          memset(Buf,0xff,TAB_RAM_LEN*2);
  369   1          Drv_XsiRead(pXSI0Regs,usAddr,Buf,ucLen,AFE_REG);
  370   1          for (i = 0; i < ucLen; i++)
  371   1          {
  372   2              if (Buf[i] != 0x00)
  373   2              {
  374   3                  DBG_FLOW("\n\rRam_Tab4[%02d] = 0x%04x",i,Buf[i]);
  375   3              }
  376   2          }
  377   1          DBG_FLOW("\n\rRead Ram_Tab4 is ok!");
  378   1      }
  379          
  380          
  381          
  382          
  383          
C251 COMPILER V5.54.0.0,  DrvAfePara                                                       26/05/17  20:21:06  PAGE 7   

  384          /*******************************************************************************
  385          *   Name: DrvAfeSetOneChannelTestMode
  386          *  Brief:  É¨Ãè´ÎÊý¾ö¶¨ÉÏ±¨Ô­Ê¼ADC¸öÊý£¬Ä£ÄâÏà¼õÃ¿´Î±¨2¸öÊý¾Ý¡£
  387          *           DAT_TEST_MODE_KEY_NUM       0x00    //[11:10]²âÊÔÄ£Ê½£¬Ñ¡Ôñkey¼üºÅ                           
             -         
  388          *           DAT_TEST_MODE_TP_CH_NUM             0x000   //[9:1]  ²âÊÔÄ£Ê½£¬Ñ¡ÔñtpÍ¨µÀºÅ
  389          *           DAT_TEST_MODE_TP_KEY_SEL            0x0     //[0], Í¨µÀÑ¡Ôñ, 0:tp; 1:key
  390          *  Input: 
  391          * Output: 
  392          * Return: 
  393          *******************************************************************************/
  394          void DrvAfeSetOneChannelTestMode(UINT8 ucKeyNum,UINT16 usTpNum,UINT8 ucTp_Key_Sel)
  395          {
  396   1          UINT16 XRAM  Reg;
  397   1                                       
  398   1          Reg = rAFE_SYS_CFG0&0xFFFE;
  399   1      
  400   1          Drv_XsiWriteReg(pXSI0Regs, Addr_AFE_SYS_CFG0, Reg, AFE_REG);
  401   1          Drv_XsiWriteReg(pXSI1Regs, Addr_AFE_SYS_CFG0, Reg, AFE_REG);   
  402   1      
  403   1          Reg = ((ucKeyNum<<10)|(usTpNum<<1)|(ucTp_Key_Sel<<0));
  404   1           
  405   1          Drv_XsiWriteReg(pXSI0Regs, Addr_TEST_MODE_FLAG, Reg, AFE_REG);
  406   1          Drv_XsiWriteReg(pXSI1Regs, Addr_TEST_MODE_FLAG, Reg, AFE_REG);
  407   1      }
  408          
  409          
  410          /*******************************************************************************
  411          *   Name: DrvAfeSetBaseTrack
  412          *  Brief: MonitorÄ£Ê½£¬Base¸ú×ÙÉèÖÃ 
  413          *  Input: 
  414          * Output: 
  415          * Return: 
  416          *******************************************************************************/
  417          void DrvAfeSetBaseTrack(UINT8 ucBaseMode,UINT8 ucStep)
  418          {
  419   1          UINT16 XRAM usBaseTrackReg;
  420   1                                       
  421   1          usBaseTrackReg = ((ucStep<<BIT_BASE_TRACK_STEP)          //[9:2]MonitorÄ£Ê½£¬Base¸ú×Ù£¬²½½ø¸ú×Ù²½³¤  
             -                                               
  422   1                           +(ucBaseMode<<BIT_BASE_TRACK_MODE)      //[1] MonitorÄ£Ê½£¬Base¸ú×Ù·½Ê½: 0:²½½ø¸ú×Ù;
             - 1:Ô­Öµ¸ú×Ù
  423   1                           +(1<<BIT_BASE_TRACK_ENABLE));           //[0] MontiorÄ£Ê½£¬Base¸ú×ÙÊ¹ÄÜ£¬1:Ê¹ÄÜ 
  424   1      
  425   1          Drv_XsiWriteReg(pXSI0Regs, Addr_AFE_BASE_TRACK_CFG, usBaseTrackReg, AFE_REG);
  426   1          Drv_XsiWriteReg(pXSI1Regs, Addr_AFE_BASE_TRACK_CFG, usBaseTrackReg, AFE_REG);               
  427   1      }
  428          
  429          
  430          /*******************************************************************************
  431          *   Name: DrvAfeSetBaseTrack
  432          *  Brief: MonitorÄ£Ê½£¬Base¸ú×ÙÉèÖÃ 
  433          *  Input: 
  434          * Output: 
  435          * Return: 
  436          *******************************************************************************/
  437          void DrvAfeSetTabBaseTrack(UINT8 ucBaseMode,UINT8 ucStep,UINT8 ucId)
  438          {
  439   1          UINT16 XRAM usBaseTrackReg;
  440   1      
  441   1              /* set ram buf as tab ram: */
  442   1          DrvAfeSelTaborRepRam(AREA_TBL_RAM);
  443   1              
  444   1        usBaseTrackReg = Drv_XsiReadReg(pXSI0Regs,TAB_START_ADDR+TAB_RAM_LEN*ucId+4,AFE_REG);
  445   1                                       
  446   1          usBaseTrackReg |= ((ucStep<<BIT_BASE_TRACK_STEP)          //[9:2]MonitorÄ£Ê½£¬Base¸ú×Ù£¬²½½ø¸ú×Ù²½³¤ 
C251 COMPILER V5.54.0.0,  DrvAfePara                                                       26/05/17  20:21:06  PAGE 8   

             -                                                
  447   1                           +(ucBaseMode<<BIT_BASE_TRACK_MODE)      //[1] MonitorÄ£Ê½£¬Base¸ú×Ù·½Ê½: 0:²½½ø¸ú×Ù;
             - 1:Ô­Öµ¸ú×Ù
  448   1                           +(1<<BIT_BASE_TRACK_ENABLE));           //[0] MontiorÄ£Ê½£¬Base¸ú×ÙÊ¹ÄÜ£¬1:Ê¹ÄÜ 
  449   1      
  450   1      
  451   1          Drv_XsiWriteReg(pXSI0Regs,TAB_START_ADDR+TAB_RAM_LEN*ucId+4,usBaseTrackReg,AFE_REG);
  452   1          Drv_XsiWriteReg(pXSI1Regs,TAB_START_ADDR+TAB_RAM_LEN*ucId+4,usBaseTrackReg,AFE_REG);
  453   1      }
  454          
  455          
  456          /*******************************************************************************
  457          *   Name: DrvAfeSetHCBTarget
  458          *  Brief: Ó²¼þCBÐ£ÕýµÄÄ¿±êÖµ
  459          *  Input: 
  460          * Output: 
  461          * Return: 
  462          *******************************************************************************/
  463          void DrvAfeSetHCBTarget(UINT16 usTpCbTarget,UINT16 usKeyCbTarget)
  464          {                                                              
  465   1          Drv_XsiWriteReg(pXSI0Regs,Addr_CB_ADJUST_THLD_TP, usTpCbTarget, AFE_REG);
  466   1          Drv_XsiWriteReg(pXSI1Regs,Addr_CB_ADJUST_THLD_TP, usTpCbTarget, AFE_REG);
  467   1          Drv_XsiWriteReg(pXSI0Regs,Addr_CB_ADJUST_THLD_TP, usKeyCbTarget, AFE_REG);
  468   1          Drv_XsiWriteReg(pXSI1Regs,Addr_CB_ADJUST_THLD_TP, usKeyCbTarget, AFE_REG);  
  469   1      }
  470          
  471          /*******************************************************************************
  472          *   Name:  DrvAfeSetHCBThld
  473          *  Brief:  ´¥Ãþ¼ì²âtp,keyÃÅÏÞ
  474          *  Input: 
  475          * Output: 
  476          * Return: 
  477          *******************************************************************************/
  478          void DrvAfeSetHCBThld(UINT16 usTpThld,UINT16 usKeyThld)
  479          {                                                              
  480   1          Drv_XsiWriteReg(pXSI0Regs,Addr_TP_MONITOR_THRESHOLD,usTpThld, AFE_REG);
  481   1          Drv_XsiWriteReg(pXSI1Regs,Addr_TP_MONITOR_THRESHOLD,usTpThld, AFE_REG);   
  482   1      
  483   1          Drv_XsiWriteReg(pXSI0Regs,Addr_KEY_MONITOR_THRESHOLD,usKeyThld, AFE_REG);
  484   1          Drv_XsiWriteReg(pXSI1Regs,Addr_KEY_MONITOR_THRESHOLD,usKeyThld, AFE_REG);    
  485   1      }
  486          
  487          /*******************************************************************************
  488          *   Name: DrvAfeInitBase
  489          *  Brief:
  490          *  Input:
  491          * Output:
  492          * Return:
  493          *******************************************************************************/
  494          void DrvAfeInitBase(void)
  495          {
  496   1          UINT16 XRAM i;
  497   1          UINT16 XRAM usBaseBuff[CH_LEN_MAX];
  498   1      
  499   1          DBG_FLOW("\nDrvAfeInitBase begin");
  500   1          /* set ram  as  BaseRam */
  501   1          DrvAfeSelTaborRepRam(AREA_BASE_ORDER);
  502   1      
  503   1      // Write Base    
  504   1          for (i = 0; i < CH_LEN_MAX; i++)
  505   1          {
  506   2             usBaseBuff[i] = 1024;     
  507   2          }
  508   1          
  509   1      #if TEMP_CLOSE_KEY
                   usBaseBuff[CH_LEN_MAX-1] = 0;
C251 COMPILER V5.54.0.0,  DrvAfePara                                                       26/05/17  20:21:06  PAGE 9   

                   usBaseBuff[CH_LEN_MAX-2] = 0;
                   usBaseBuff[CH_LEN_MAX-3] = 0;
                   usBaseBuff[CH_LEN_MAX-4] = 0;
               #endif
  515   1          
  516   1          Drv_XsiWrite(pXSI0Regs,BASE_RAM_START_ADDR + BASE_RAM_TP_RAWBASE_ADDR,usBaseBuff,CH_LEN_MAX,AFE_REG);
  517   1          Drv_XsiWrite(pXSI1Regs,BASE_RAM_START_ADDR + BASE_RAM_TP_RAWBASE_ADDR,usBaseBuff,CH_LEN_MAX,AFE_REG);
  518   1          
  519   1      // read Base    
  520   1          //DrvGetRptRamRawBase();
  521   1          DBG_FLOW("\nDrvAfeInitBase finished");
  522   1      //    while(1);
  523   1      }
  524          
  525          /*******************************************************************************
  526          *  Brief: ÔÚTab±íÖÐ£¬ÉèÖÃCB³õÖµ£¬Í¨µÀÊ¹ÄÜ
  527          *  Input: ucTabID: 0±íÊ¾µÚ1¸ö±í; 3±íÊ¾µÚ4¸ö±í¡£
  528          * Output: 
  529          * Return: 
  530          *******************************************************************************/
  531          void Afe_SetTabCBChEN(UINT8 ucTabID)
  532          {
  533   1          UINT16 XRAM i;
  534   1          UINT16 XRAM aus_tabbuf[TAB_RAM_LEN];
  535   1          
  536   1          memset(aus_tabbuf, 0, TAB_RAM_LEN*2);
  537   1      
  538   1          /* set Ch enable, set CB 0*/ 
  539   1          for(i = TAB_TP_KEY_CB_START_ADDR ;i<TAB_RAM_LEN;i++)
  540   1          {
  541   2              aus_tabbuf[i] = 0x4040;   // [6]:EN  [5:0]:CB
  542   2          }
  543   1      #if TEMP_CLOSE_KEY 
                   aus_tabbuf[TAB_TP_KEY_CB_START_ADDR + 0] = 0x0;      //4¸ö°´¼ü:  Key0-3  [8]:EN [7:0]:CB
                   aus_tabbuf[TAB_TP_KEY_CB_START_ADDR + 1] = 0x0;      
                   aus_tabbuf[TAB_TP_KEY_CB_START_ADDR + 2] = 0x0;
                   aus_tabbuf[TAB_TP_KEY_CB_START_ADDR + 3] = 0x0;
               #else
  549   1          aus_tabbuf[TAB_TP_KEY_CB_START_ADDR + 0] = 0x0100;      //4¸ö°´¼ü:  Key0-3  [8]:EN [7:0]:CB
  550   1          aus_tabbuf[TAB_TP_KEY_CB_START_ADDR + 1] = 0x0100;      
  551   1          aus_tabbuf[TAB_TP_KEY_CB_START_ADDR + 2] = 0x0100;
  552   1          aus_tabbuf[TAB_TP_KEY_CB_START_ADDR + 3] = 0x0100;
  553   1      #endif    
  554   1          Drv_XsiWrite(pXSI0Regs,256+ucTabID*TAB_RAM_LEN+TAB_TP_KEY_CB_START_ADDR,&aus_tabbuf[TAB_TP_KEY_CB_STA
             -RT_ADDR],TAB_RAM_LEN,AFE_REG);
  555   1          Drv_XsiWrite(pXSI1Regs,256+ucTabID*TAB_RAM_LEN+TAB_TP_KEY_CB_START_ADDR,&aus_tabbuf[TAB_TP_KEY_CB_STA
             -RT_ADDR],TAB_RAM_LEN,AFE_REG);
  556   1      #if TEST_KEY_DET
                   aus_tabbuf[TAB_TP_KEY_CB_START_ADDR + 0] = 0x0;      //4¸ö°´¼ü:  Key0-3  [8]:EN [7:0]:CB
                   aus_tabbuf[TAB_TP_KEY_CB_START_ADDR + 1] = 0x0;      
                   aus_tabbuf[TAB_TP_KEY_CB_START_ADDR + 2] = 0x0;
                   aus_tabbuf[TAB_TP_KEY_CB_START_ADDR + 3] = 0x0;
                   Drv_XsiWrite(pXSI0Regs,256+ucTabID*TAB_RAM_LEN+TAB_TP_KEY_CB_START_ADDR,&aus_tabbuf[TAB_TP_KEY_CB_STA
             -RT_ADDR],TAB_RAM_LEN,AFE_REG);
               #endif
  563   1      }
  564          
  565          
  566          
  567          
  568          /*******************************************************************************
  569          *  Brief: ±íÏî0ÅäÖÃ¡£Ò»¹²ÓÐ4¸ö±íÏî , FreeRun ²âÊÔ
  570          *  Input: 
  571          * Output: 
  572          * Return: 
  573          *******************************************************************************/
C251 COMPILER V5.54.0.0,  DrvAfePara                                                       26/05/17  20:21:06  PAGE 10  

  574          void Afe_Config_Tab0(void)
  575          {
  576   1      //    UINT16 XRAM i;
  577   1      //    UINT16 XRAM usTblBaseAddr;
  578   1          UINT16 XRAM usReg0;
  579   1          UINT16 XRAM usReg1;
  580   1          UINT16 XRAM usReg2;
  581   1          UINT16 XRAM usReg3;
  582   1          UINT16 XRAM usReg4;
  583   1          UINT16 XRAM usReg5;
  584   1          UINT16 XRAM usReg6;
  585   1          UINT16 XRAM usReg7;
  586   1          UINT16 XRAM usReg8;
  587   1          UINT16 XRAM usReg9;
  588   1      
  589   1      //    usReg0 = rAFE_SYS_CFG1|(1<<7);  //DAT_ACC_ASR ²âÊÔÀÛºÍÓÒÒÆ
  590   1          usReg0 = rAFE_SYS_CFG1|(0<<7);  //DAT_ACC_ASR
  591   1          
  592   1          usReg1 = rAFE_SCAN_CFG0;
  593   1          usReg1 =((1<<BIT_AFE_SCAN_TIMES) +(4<<BIT_AFE_SCAN_MODE));  //·½Ê½5 µ¥¸ö¿ÓÄÚÉ¨Ãè5¸ö1/5,É¨Ãè´ÎÊý£¬Êµ¼Ê
             -ÖµÎªÅäÖÃÖµ¼Ó1; Êä³öÊý¾Ý´ÎÊý²»¼Ó1.¼´: ÅäÖÃÎª1£¬Êµ¼ÊÉ¨Ãè2´Î£¬Êý¾ÝÖ»³ö1´Î¡£Åä0£¬É¨Ãè1´Î£¬ÎÞÖµÊä³ö¡£ 
  594   1      //    usReg1 =((1<<BIT_AFE_SCAN_TIMES) +(7<<BIT_AFE_SCAN_MODE));  //·½Ê½8 5¸ö½ÓÒ»Æð,Êý¾ÝÍ¨¹ýµÚÒ»¸ömux1Ñ¡Ô
             -ñÊä³ö£¬Èç:mux1:G1,G9, ³öG1,G9Êý¾Ý£¬µ«´¥ÃþÈÎÒâÎ»ÖÃ¿É½øDETÖÐ¶Ï¡£ 
  595   1                            
  596   1      #if TEST_ONE_CHANNEL_ADC
                   usReg1 =((5<<BIT_AFE_SCAN_TIMES)             //É¨Ãè´ÎÊý£¬Êµ¼ÊÖµÎªÅäÖÃÖµ¼Ó1; Êä³öÊý¾Ý´ÎÊý²»¼Ó1.¼´: ÅäÖ
             -ÃÎª1£¬Êµ¼ÊÉ¨Ãè2´Î£¬Êý¾ÝÖ»³ö1´Î¡£Åä0£¬É¨Ãè1´Î£¬ÎÞÖµÊä³ö¡£ ²¨ÐÎÖ»ÓÐÒ»¸ömux.
                           +(4<<BIT_AFE_SCAN_MODE));             //·½Ê½5 µ¥¸ö¿ÓÄÚÉ¨Ãè5¸ö1/5
               #endif
  600   1          
  601   1          usReg2 = rAFE_SCAN_CFG1;
  602   1          usReg2 =((0<<9)               //[10:9] ²ÉÑùÄ£Ê½: 0:Ë«±ß²ÉÑù£¬Ä£ÄâÏà¼õ; 1:¸º±ß²ÉÑù; 2:Õý±ß²ÉÑù; 3:Ë«±ß
             -²ÉÑù£¬Êý×ÖÏà¼õ      
  603   1                  +(0<<8)               //[8] SXÉ¨Ãè·½Ê½:  0:Ë«±ßÉ¨Ãè(4ÖÖ²ÉÑùmode); 1: µ¥±ßÉ¨Ãè(½ö1ÖÖµ¥±ß²ÉÑù)
  604   1                  +(4<<0));             //[0] ·½Ê½6£¬É¨Ãè¶ÎÊý  
  605   1      
  606   1      #if 1 //Ë«±ß3ÖÖÄ£Ê½
  607   1      #if TEST_2SAMPLE_ANA_SUB
  608   1           usReg2 =((0<<9)+(0<<8)+(4<<0));               //[10:9] ²ÉÑùÄ£Ê½: 0:Ë«±ß²ÉÑù£¬Ä£ÄâÏà¼õ;     [8]Ë«±ßÉ¨
             -Ãè
  609   1      #endif
  610   1      #if TEST_2SAMPLE_POSITIVE
                    usReg2 =((1<<9)+(0<<8)+(4<<0));               //[10:9] ²ÉÑùÄ£Ê½: 1:¸º±ß²ÉÑù;     [8]Ë«±ßÉ¨Ãè
               #endif
  613   1      #if TEST_2SAMPLE_NEGATIVE
                    usReg2 =((2<<9)+(0<<8)+(4<<0));               //[10:9] ²ÉÑùÄ£Ê½: 2:Õý±ß²ÉÑù;     [8]Ë«±ßÉ¨Ãè
               #endif
  616   1           usReg8 = rAFE_ANA_K1_CFG0;
  617   1           usReg9 = rAFE_ANA_K2_CFG1;
  618   1      #endif     
  619   1                
  620   1          usReg3 = rAFE_DUMMY_SCAN_CFG;
  621   1          usReg3 =((1<<10)               //[14:10]MuxÇÐ»»Ö®¼äDummy´ÎÊý    
  622   1                  +(0<<5)                //[9:5]¿ÓÇ°Dummy´ÎÊý
  623   1                  +(2<<0));              //[4:0]TpÖ¡Ç°Dummy´ÎÊý    
  624   1                  
  625   1          usReg4 = rAFE_BASE_TRACK_CFG;
  626   1          usReg4 = ((80<<BIT_BASE_TRACK_STEP)             //[9:2]MonitorÄ£Ê½£¬Base¸ú×Ù£¬²½½ø¸ú×Ù²½³¤           
             -                                      
  627   1                   +(0<<BIT_BASE_TRACK_MODE)              //[1] MonitorÄ£Ê½£¬Base¸ú×Ù·½Ê½: 0:²½½ø¸ú×Ù; 1:Ô­Öµ¸ú
             -×Ù
  628   1                   +(1<<BIT_BASE_TRACK_ENABLE));          //[0] MontiorÄ£Ê½£¬Base¸ú×ÙÊ¹ÄÜ£¬1:Ê¹ÄÜ 
  629   1      
  630   1          usReg5 = 0x100; //rACC_OFFSET;        //²âÊÔACC OffsetÖµ 
  631   1      #if IS_4_MUX_MODE
                   usReg5 = 256;                //keyÖ»Ö§³ÖÊý×ÖÏà¼õ£¬ÀíÂÛÖµÎª0£¬Òª¼ÓOffset.
C251 COMPILER V5.54.0.0,  DrvAfePara                                                       26/05/17  20:21:06  PAGE 11  

               #endif
  634   1          
  635   1      #if TEST_2SAMPLE_DIG_SUB //Ë«±ßÉ¨Ãè, Ë«±ß²ÉÑù£¬Êý×ÖÏà¼õ   
                   usReg2 =((3<<9)+(0<<8)+(4<<0));               //[10:9] ²ÉÑùÄ£Ê½: 3:Ë«±ß²ÉÑù£¬Êý×ÖÏà¼õ   [8]Ë«±ßÉ¨Ãè
                   usReg5 = 256;       //²âÊÔACC OffsetÖµ
                   usReg8 = rAFE_ANA_K1_CFG0*2;
                   usReg9 = rAFE_ANA_K2_CFG1*3;
               #endif    
  641   1      
  642   1          usReg6 = rTP_MONITOR_THRESHOLD;
  643   1          usReg7 = rKEY_MONITOR_THRESHOLD;
  644   1      
  645   1      #if TEST_1SAMPLE //µ¥±ßÉ¨Ãè,µ¥±ß²ÉÑù
                   usReg2 =((0<<9)+(1<<8)+(4<<0));               //[8]µ¥±ßÉ¨Ãè(½ö1ÖÖµ¥±ß²ÉÑù)  
               
                   usReg8 = rAFE_ANA_K1_CFG0*2;
                   usReg9 = rAFE_ANA_K2_CFG1*3;
               #endif
  651   1      
  652   1          /* set ram buf as tab ram: */
  653   1          DrvAfeSelTaborRepRam(AREA_TBL_RAM);
  654   1      
  655   1          //tab 0
  656   1          Drv_XsiWriteReg(pXSI0Regs,TAB_START_ADDR+0,usReg0,AFE_REG);
  657   1          Drv_XsiWriteReg(pXSI1Regs,TAB_START_ADDR+0,usReg0,AFE_REG);
  658   1          Drv_XsiWriteReg(pXSI0Regs,TAB_START_ADDR+1,usReg1,AFE_REG); 
  659   1          Drv_XsiWriteReg(pXSI1Regs,TAB_START_ADDR+1,usReg1,AFE_REG);
  660   1          Drv_XsiWriteReg(pXSI0Regs,TAB_START_ADDR+2,usReg2,AFE_REG); 
  661   1          Drv_XsiWriteReg(pXSI1Regs,TAB_START_ADDR+2,usReg2,AFE_REG);
  662   1          Drv_XsiWriteReg(pXSI0Regs,TAB_START_ADDR+3,usReg3,AFE_REG);
  663   1          Drv_XsiWriteReg(pXSI1Regs,TAB_START_ADDR+3,usReg3,AFE_REG);
  664   1          Drv_XsiWriteReg(pXSI0Regs,TAB_START_ADDR+4,usReg4,AFE_REG);
  665   1          Drv_XsiWriteReg(pXSI1Regs,TAB_START_ADDR+4,usReg4,AFE_REG);
  666   1          Drv_XsiWriteReg(pXSI0Regs,TAB_START_ADDR+5,usReg5,AFE_REG); 
  667   1          Drv_XsiWriteReg(pXSI1Regs,TAB_START_ADDR+5,usReg5,AFE_REG);
  668   1          Drv_XsiWriteReg(pXSI0Regs,TAB_START_ADDR+6,usReg6,AFE_REG); 
  669   1          Drv_XsiWriteReg(pXSI1Regs,TAB_START_ADDR+6,usReg6,AFE_REG);
  670   1          Drv_XsiWriteReg(pXSI0Regs,TAB_START_ADDR+7,usReg7,AFE_REG); 
  671   1          Drv_XsiWriteReg(pXSI1Regs,TAB_START_ADDR+7,usReg7,AFE_REG);
  672   1          Drv_XsiWriteReg(pXSI0Regs,TAB_START_ADDR+8,usReg8,AFE_REG); 
  673   1          Drv_XsiWriteReg(pXSI1Regs,TAB_START_ADDR+8,usReg8,AFE_REG);
  674   1          Drv_XsiWriteReg(pXSI0Regs,TAB_START_ADDR+9,usReg9,AFE_REG); 
  675   1          Drv_XsiWriteReg(pXSI1Regs,TAB_START_ADDR+9,usReg9,AFE_REG);
  676   1          
  677   1      #if 1
  678   1          Afe_SetTabCBChEN(0);
  679   1      #else
               //    DrvClbCB(0);
               #endif
  682   1      }
  683          
  684          /*******************************************************************************
  685          *  Brief: ±íÏî1ÅäÖÃ¡£Ò»¹²ÓÐ4¸ö±íÏî , 120hz ²âÊÔ
  686          *  Input: 
  687          * Output: 
  688          * Return: 
  689          *******************************************************************************/
  690          void Afe_Config_Tab1(void)
  691          {
  692   1      //    UINT16 XRAM i;
  693   1          UINT8 XRAM ucScanMode;
  694   1          UINT16 XRAM usReg0;
  695   1          UINT16 XRAM usReg1;
  696   1          UINT16 XRAM usReg2;
  697   1          UINT16 XRAM usReg3;
  698   1          UINT16 XRAM usReg4;
C251 COMPILER V5.54.0.0,  DrvAfePara                                                       26/05/17  20:21:06  PAGE 12  

  699   1          UINT16 XRAM usReg5;
  700   1          UINT16 XRAM usReg6;
  701   1          UINT16 XRAM usReg7;
  702   1          UINT16 XRAM usReg8;
  703   1          UINT16 XRAM usReg9;
  704   1      
  705   1          ucScanMode = SCAN_MODE_1;   //²âÊÔÉ¨Ãè·½Ê½
  706   1      
  707   1      #if TEST_MUX_ABC_SACN    
                   ucScanMode = SCAN_MODE_2;   //²âÊÔÉ¨Ãè·½Ê½2_2_1
               #endif
  710   1      
  711   1      #if TEST_MUX_ABCD_SACN    
                   ucScanMode = SCAN_MODE_3;   //²âÊÔÉ¨Ãè·½Ê½3_2
               #endif
  714   1      
  715   1      #if TEST_60HZ_SCAN_MODE
  716   1          ucScanMode = SCAN_MODE_5;   //²âÊÔÉ¨Ãè·½Ê½
  717   1      #endif
  718   1      
  719   1      
  720   1          usReg0 = rAFE_SYS_CFG1;
  721   1          
  722   1          usReg1 = rAFE_SCAN_CFG0;
  723   1      
  724   1          usReg2 = rAFE_SCAN_CFG1;
  725   1          usReg2 =((0<<9)               //[10:9] ²ÉÑùÄ£Ê½: 0:Ë«±ß²ÉÑù£¬Ä£ÄâÏà¼õ; 1:¸º±ß²ÉÑù; 2:Õý±ß²ÉÑù; 3:Ë«±ß
             -²ÉÑù£¬Êý×ÖÏà¼õ      
  726   1                  +(0<<8)               //[8] SXÉ¨Ãè·½Ê½:  0:Ë«±ßÉ¨Ãè(4ÖÖ²ÉÑùmode); 1: µ¥±ßÉ¨Ãè(½ö1ÖÖµ¥±ß²ÉÑù)
  727   1                  +(4<<0));             //[0] ·½Ê½6£¬É¨Ãè¶ÎÊý  
  728   1      //   usReg2 =((0<<9)+(0<<8)+(4<<0));               //[10:9] ²ÉÑùÄ£Ê½: 0:Ë«±ß²ÉÑù£¬Ä£ÄâÏà¼õ;     [8]Ë«±ßÉ¨
             -Ãè
  729   1      //   usReg2 =((1<<9)+(0<<8)+(4<<0));               //[10:9] ²ÉÑùÄ£Ê½: 1:¸º±ß²ÉÑù;     [8]Ë«±ßÉ¨Ãè
  730   1      //   usReg2 =((2<<9)+(0<<8)+(4<<0));               //[10:9] ²ÉÑùÄ£Ê½: 2:Õý±ß²ÉÑù;    [8]Ë«±ßÉ¨Ãè
  731   1      //   usReg2 =((3<<9)+(0<<8)+(4<<0));               //[10:9] ²ÉÑùÄ£Ê½: 3:Ë«±ß²ÉÑù£¬Êý×ÖÏà¼õ   [8]Ë«±ßÉ¨Ãè
  732   1      //   usReg2 =((0<<9)+(1<<8)+(4<<0));               //[8]µ¥±ßÉ¨Ãè(½ö1ÖÖµ¥±ß²ÉÑù) 
  733   1      
  734   1          switch(ucScanMode)
  735   1          {
  736   2              case SCAN_MODE_1:
  737   2                  usReg1 =((1<<BIT_AFE_SCAN_TIMES)+(0<<BIT_AFE_SCAN_MODE));       //·½Ê½1: µ¥¸ö¿ÓÄÚÖ»É¨Ãè1¸ö1/5
             -ÆÁµÄÍ¨µÀ
  738   2                  usReg3 = rAFE_DUMMY_SCAN_CFG;
  739   2                  usReg3 =((0<<10)               //[14:10]MuxÇÐ»»Ö®¼äDummy´ÎÊý    
  740   2                          +(2<<5)                //[9:5]¿ÓÇ°Dummy´ÎÊý
  741   2                          +(0<<0));              //[4:0]TpÖ¡Ç°Dummy´ÎÊý   
  742   2                  break;
  743   2              case SCAN_MODE_2:
  744   2                  usReg1 =((4<<BIT_AFE_SCAN_TIMES)+(1<<BIT_AFE_SCAN_MODE));     //·½Ê½2: µ¥¸ö¿ÓÄÚÖ»É¨Ãè2»ò1¸ö1/
             -5ÆÁµÄÍ¨µÀ ¼´:A:2_2_1+B:2_2_1
  745   2                  usReg3 = rAFE_DUMMY_SCAN_CFG;
  746   2                  usReg3 =((0<<10)               //[14:10]MuxÇÐ»»Ö®¼äDummy´ÎÊý    
  747   2                          +(2<<5)                //[9:5]¿ÓÇ°Dummy´ÎÊý
  748   2                          +(0<<0));              //[4:0]TpÖ¡Ç°Dummy´ÎÊý   
  749   2                  break;
  750   2              case SCAN_MODE_3:
  751   2                  usReg1 =((2<<BIT_AFE_SCAN_TIMES)+(2<<BIT_AFE_SCAN_MODE));     //·½Ê½3: µ¥¸ö¿ÓÄÚÖ»É¨Ãè3»ò2¸ö1/
             -5ÆÁµÄÍ¨µÀ ¼´:A:3_2+B:3_2
  752   2                  usReg3 = rAFE_DUMMY_SCAN_CFG;
  753   2                  usReg3 =((0<<10)               //[14:10]MuxÇÐ»»Ö®¼äDummy´ÎÊý    
  754   2                          +(1<<5)                //[9:5]¿ÓÇ°Dummy´ÎÊý
  755   2                          +(1<<0));              //[4:0]TpÖ¡Ç°Dummy´ÎÊý   
  756   2                  break;
  757   2              case SCAN_MODE_4:
  758   2                  usReg1 =((2<<BIT_AFE_SCAN_TIMES)+(3<<BIT_AFE_SCAN_MODE));     //·½Ê½4: µ¥¸ö¿ÓÄÚÖ»É¨Ãè2»ò3¸ö1/
             -5ÆÁµÄÍ¨µÀ ¼´:A:2_3+B:2_3
C251 COMPILER V5.54.0.0,  DrvAfePara                                                       26/05/17  20:21:06  PAGE 13  

  759   2                  usReg3 = rAFE_DUMMY_SCAN_CFG;
  760   2                  usReg3 =((0<<10)               //[14:10]MuxÇÐ»»Ö®¼äDummy´ÎÊý    
  761   2                         +(2<<5)                 //[9:5]¿ÓÇ°Dummy´ÎÊý
  762   2                         +(0<<0));               //[4:0]TpÖ¡Ç°Dummy´ÎÊý   
  763   2                  break;
  764   2              case SCAN_MODE_5:
  765   2                  usReg1 =((1<<BIT_AFE_SCAN_TIMES)+(4<<BIT_AFE_SCAN_MODE));     //·½Ê½5: 
  766   2                  usReg3 = rAFE_DUMMY_SCAN_CFG;
  767   2                  usReg3 =((0<<10)               //[14:10]MuxÇÐ»»Ö®¼äDummy´ÎÊý    
  768   2                          +(0<<5)                //[9:5]¿ÓÇ°Dummy´ÎÊý
  769   2                          +(0<<0));              //[4:0]TpÖ¡Ç°Dummy´ÎÊý   
  770   2                  break;
  771   2              case SCAN_MODE_6:
  772   2                  usReg1 =((1<<BIT_AFE_SCAN_TIMES)+(5<<BIT_AFE_SCAN_MODE));     //·½Ê½6: µ¥¸ö¿ÓÄÚÖ»É¨Ãè5¸ö1/5ÆÁ
             -µÄÍ¨µÀ£¬ÇÒ¶à¿ÓÀÛ¼Ó£¬¶ÎÊ½ 
  773   2                  usReg3 = rAFE_DUMMY_SCAN_CFG;
  774   2                  usReg3 =((0<<10)               //[14:10]MuxÇÐ»»Ö®¼äDummy´ÎÊý    
  775   2                          +(0<<5)                //[9:5]¿ÓÇ°Dummy´ÎÊý
  776   2                          +(0<<0));              //[4:0]TpÖ¡Ç°Dummy´ÎÊý   
  777   2                  usReg2 =((0<<9)                //[10:9] ²ÉÑùÄ£Ê½: 0:Ë«±ß²ÉÑù£¬Ä£ÄâÏà¼õ; 1:¸º±ß²ÉÑù; 2:Õý±ß²ÉÑ
             -ù; 3:Ë«±ß²ÉÑù£¬Êý×ÖÏà¼õ      
  778   2                          +(0<<8)                //[8] SXÉ¨Ãè·½Ê½:  0:Ë«±ßÉ¨Ãè(4ÖÖ²ÉÑùmode); 1: µ¥±ßÉ¨Ãè(½ö1ÖÖµ
             -¥±ß²ÉÑù)
  779   2                          +(4<<0));              //[0] ·½Ê½6£¬É¨Ãè¶ÎÊý                     
  780   2                  break;
  781   2              case SCAN_MODE_7:
  782   2                 usReg1 =((1<<BIT_AFE_SCAN_TIMES)+(6<<BIT_AFE_SCAN_MODE));     //·½Ê½7: µ¥¸ö¿ÓÄÚÖ»É¨Ãè2»ò1¸ömux
             -,¼´mux9Ä£Ê½¼´:A:2_2_2_2_1+B:2_2_2_2_1
  783   2                 usReg3 = rAFE_DUMMY_SCAN_CFG;                                 //9¸ömuxÒÀ´ÎÉ¨Ãè£¬9¸ömuxºó£¬Íê³É
             -È«ÆÁÉ¨Ãè¡£
  784   2                 usReg3 =((0<<10)               //[14:10]MuxÇÐ»»Ö®¼äDummy´ÎÊý    
  785   2                         +(2<<5)                //[9:5]¿ÓÇ°Dummy´ÎÊý
  786   2                         +(0<<0));              //[4:0]TpÖ¡Ç°Dummy´ÎÊý   
  787   2                  break;
  788   2              case SCAN_MODE_8:
  789   2                 usReg1 =((2<<BIT_AFE_SCAN_TIMES)+(7<<BIT_AFE_SCAN_MODE));     //·½Ê½8: ½öÉ¨Ãè1¸öMux,Íê³ÉÈ«ÆÁÉ¨
             -Ãè£¬¼´Monitor,5¸öSXÏàÁ¬Ä£Ê½£¬G1234 G56789, 
  790   2                 usReg3 = rAFE_DUMMY_SCAN_CFG;                                 //Ö»ÓÐmux1 G1G9Êý¾Ý»á·¢Éú±ä»¯£¬Ó
             -¦ÓÃÔÚ´¥Ãþ»½ÐÑ¡£
  791   2                 usReg3 =((0<<10)               //[14:10]MuxÇÐ»»Ö®¼äDummy´ÎÊý    
  792   2                         +(2<<5)                //[9:5]¿ÓÇ°Dummy´ÎÊý
  793   2                         +(0<<0));              //[4:0]TpÖ¡Ç°Dummy´ÎÊý   
  794   2                  break;
  795   2              default:
  796   2                  break;
  797   2          }
  798   1                                              
  799   1          usReg4 = rAFE_BASE_TRACK_CFG;
  800   1          usReg4 = ((80<<BIT_BASE_TRACK_STEP)             //[9:2]MonitorÄ£Ê½£¬Base¸ú×Ù£¬²½½ø¸ú×Ù²½³¤           
             -                                      
  801   1                    +(0<<BIT_BASE_TRACK_MODE)             //[1] MonitorÄ£Ê½£¬Base¸ú×Ù·½Ê½: 0:²½½ø¸ú×Ù; 1:Ô­Öµ¸ú
             -×Ù
  802   1                    +(1<<BIT_BASE_TRACK_ENABLE));         //[0] MontiorÄ£Ê½£¬Base¸ú×ÙÊ¹ÄÜ£¬1:Ê¹ÄÜ 
  803   1          
  804   1          usReg5 = rACC_OFFSET;
  805   1          usReg5 = 0x100; 
  806   1          usReg6 = 188; //rTP_MONITOR_THRESHOLD;
  807   1          usReg7 = 188; //rKEY_MONITOR_THRESHOLD;
  808   1          usReg8 = rAFE_ANA_K1_CFG0;
  809   1          usReg9 = rAFE_ANA_K2_CFG1;
  810   1      
  811   1          /* set ram buf as tab ram: */
  812   1          DrvAfeSelTaborRepRam(AREA_TBL_RAM);
  813   1      
  814   1          //tab 1
  815   1          Drv_XsiWriteReg(pXSI0Regs,TAB_START_ADDR+TAB_RAM_LEN+0,usReg0,AFE_REG);
C251 COMPILER V5.54.0.0,  DrvAfePara                                                       26/05/17  20:21:06  PAGE 14  

  816   1          Drv_XsiWriteReg(pXSI1Regs,TAB_START_ADDR+TAB_RAM_LEN+0,usReg0,AFE_REG);
  817   1          Drv_XsiWriteReg(pXSI0Regs,TAB_START_ADDR+TAB_RAM_LEN+1,usReg1,AFE_REG); 
  818   1          Drv_XsiWriteReg(pXSI1Regs,TAB_START_ADDR+TAB_RAM_LEN+1,usReg1,AFE_REG);
  819   1          Drv_XsiWriteReg(pXSI0Regs,TAB_START_ADDR+TAB_RAM_LEN+2,usReg2,AFE_REG); 
  820   1          Drv_XsiWriteReg(pXSI1Regs,TAB_START_ADDR+TAB_RAM_LEN+2,usReg2,AFE_REG);
  821   1          Drv_XsiWriteReg(pXSI0Regs,TAB_START_ADDR+TAB_RAM_LEN+3,usReg3,AFE_REG);
  822   1          Drv_XsiWriteReg(pXSI1Regs,TAB_START_ADDR+TAB_RAM_LEN+3,usReg3,AFE_REG);
  823   1          Drv_XsiWriteReg(pXSI0Regs,TAB_START_ADDR+TAB_RAM_LEN+4,usReg4,AFE_REG);
  824   1          Drv_XsiWriteReg(pXSI1Regs,TAB_START_ADDR+TAB_RAM_LEN+4,usReg4,AFE_REG);
  825   1          Drv_XsiWriteReg(pXSI0Regs,TAB_START_ADDR+TAB_RAM_LEN+5,usReg5,AFE_REG); 
  826   1          Drv_XsiWriteReg(pXSI1Regs,TAB_START_ADDR+TAB_RAM_LEN+5,usReg5,AFE_REG);
  827   1          Drv_XsiWriteReg(pXSI0Regs,TAB_START_ADDR+TAB_RAM_LEN+6,usReg6,AFE_REG); 
  828   1          Drv_XsiWriteReg(pXSI1Regs,TAB_START_ADDR+TAB_RAM_LEN+6,usReg6,AFE_REG);
  829   1          Drv_XsiWriteReg(pXSI0Regs,TAB_START_ADDR+TAB_RAM_LEN+7,usReg7,AFE_REG); 
  830   1          Drv_XsiWriteReg(pXSI1Regs,TAB_START_ADDR+TAB_RAM_LEN+7,usReg7,AFE_REG);
  831   1          Drv_XsiWriteReg(pXSI0Regs,TAB_START_ADDR+TAB_RAM_LEN+8,usReg8,AFE_REG); 
  832   1          Drv_XsiWriteReg(pXSI1Regs,TAB_START_ADDR+TAB_RAM_LEN+8,usReg8,AFE_REG);
  833   1          Drv_XsiWriteReg(pXSI0Regs,TAB_START_ADDR+TAB_RAM_LEN+9,usReg9,AFE_REG); 
  834   1          Drv_XsiWriteReg(pXSI1Regs,TAB_START_ADDR+TAB_RAM_LEN+9,usReg9,AFE_REG);
  835   1          
  836   1      #if 1
  837   1          Afe_SetTabCBChEN(1);
  838   1      #else
               //    DrvClbCB(0);
               #endif
  841   1      }
  842          
  843          /*******************************************************************************
  844          *  Brief: ±íÏî2ÅäÖÃ¡£Ò»¹²ÓÐ4¸ö±íÏî ,  monitor ²âÊÔ
  845          *  Input: 
  846          * Output: 
  847          * Return: 
  848          *******************************************************************************/
  849          void Afe_Config_Tab2(void)
  850          {
  851   1          UINT16 XRAM usReg0;
  852   1          UINT16 XRAM usReg1;
  853   1          UINT16 XRAM usReg2;
  854   1          UINT16 XRAM usReg3;
  855   1          UINT16 XRAM usReg4;
  856   1          UINT16 XRAM usReg5;
  857   1          UINT16 XRAM usReg6;
  858   1          UINT16 XRAM usReg7;
  859   1          UINT16 XRAM usReg8;
  860   1          UINT16 XRAM usReg9;
  861   1      
  862   1          usReg0 = rAFE_SYS_CFG1;
  863   1      
  864   1      #if TEST_FREERUN_MONITOR //freerun monitor    
                   usReg1 = rAFE_SCAN_CFG0;
                   usReg1 =((1<<BIT_AFE_SCAN_TIMES)                //É¨Ãè´ÎÊý£¬Êµ¼ÊÖµÎªÅäÖÃÖµ¼Ó1;  
                           +(4<<BIT_AFE_SCAN_MODE));               //·½Ê½5
               
                   usReg3 = rAFE_DUMMY_SCAN_CFG;
                   usReg3 =((1<<10)                                //[11:8]MuxÇÐ»»Ö®¼äDummy´ÎÊý    
                           +(0<<5)                                 //[7:4]¿ÓÇ°Dummy´ÎÊý
                           +(2<<0));                               //[3:0]TpÖ¡Ç°Dummy´ÎÊý    
               
                   //ÉèÖÃ´¥Ãþ¼ì²âÊ±£¬TP,keyÍ¨µÀµÄ´¥ÃþãÐÖµ     
                   usReg6 = 100; //rTP_MONITOR_THRESHOLD;
                   usReg7 = 2000; //rKEY_MONITOR_THRESHOLD;          //×ÔÈÝkeyÖ»ÓÐÊý×ÖÏà¼õÄ£Ê½
               #endif
  878   1      
  879   1      #if TEST_120HZ_MONTIOR// normal 120hz  
                   usReg1 = rAFE_SCAN_CFG0;
                   usReg1 =((1<<BIT_AFE_SCAN_TIMES)               //É¨Ãè´ÎÊý£¬Êµ¼ÊÖµÎªÅäÖÃÖµ¼Ó1;  
C251 COMPILER V5.54.0.0,  DrvAfePara                                                       26/05/17  20:21:06  PAGE 15  

                           +(0<<BIT_AFE_SCAN_MODE));              //·½Ê½1
               
                   usReg3 = rAFE_DUMMY_SCAN_CFG;
                   usReg3 =((1<<10)               //[11:8]MuxÇÐ»»Ö®¼äDummy´ÎÊý    
                           +(0<<5)               //[7:4]¿ÓÇ°Dummy´ÎÊý
                           +(2<<0));             //[3:0]TpÖ¡Ç°Dummy´ÎÊý  
                   //ÉèÖÃ´¥Ãþ¼ì²âÊ±£¬TP,keyÍ¨µÀµÄ´¥ÃþãÐÖµ     
                   usReg6 = 18; //rTP_MONITOR_THRESHOLD;
                   usReg7 = 18; //rKEY_MONITOR_THRESHOLD;
               #endif
  892   1      
  893   1                  
  894   1          usReg2 = rAFE_SCAN_CFG1; 
  895   1          usReg2 =((0<<9)               //[10:9] ²ÉÑùÄ£Ê½: 0:Ë«±ß²ÉÑù£¬Ä£ÄâÏà¼õ; 1:¸º±ß²ÉÑù; 2:Õý±ß²ÉÑù; 3:Ë«±ß
             -²ÉÑù£¬Êý×ÖÏà¼õ      
  896   1                  +(0<<8)               //[8] SXÉ¨Ãè·½Ê½:  0:Ë«±ßÉ¨Ãè(4ÖÖ²ÉÑùmode); 1: µ¥±ßÉ¨Ãè(½ö1ÖÖµ¥±ß²ÉÑù)
  897   1                  +(4<<0));             //[0] ·½Ê½6£¬É¨Ãè¶ÎÊý             
  898   1      
  899   1          //ÉèÖÃ³É²½½ø¸ú×Ù,    ¸ú×Ù²½³¤32(0x20)        
  900   1          usReg4 = rAFE_BASE_TRACK_CFG;
  901   1          usReg4 = ((32<<BIT_BASE_TRACK_STEP)             //[9:2]MonitorÄ£Ê½£¬Base¸ú×Ù£¬²½½ø¸ú×Ù²½³¤           
             -                                      
  902   1                   // +(0<<BIT_BASE_TRACK_MODE)             //[1] MonitorÄ£Ê½£¬Base¸ú×Ù·½Ê½: 0:²½½ø¸ú×Ù; 
  903   1                    +(1<<BIT_BASE_TRACK_MODE)             //[1] MonitorÄ£Ê½£¬Base¸ú×Ù·½Ê½:   1:Ô­Öµ¸ú×Ù
  904   1                    +(1<<BIT_BASE_TRACK_ENABLE));         //[0] MontiorÄ£Ê½£¬Base¸ú×ÙÊ¹ÄÜ£¬1:Ê¹ÄÜ 
  905   1                    
  906   1          usReg5 = 100;//rACC_OFFSET;
  907   1          
  908   1          
  909   1          usReg8 = rAFE_ANA_K1_CFG0;
  910   1          usReg9 = rAFE_ANA_K2_CFG1;
  911   1      
  912   1          /* set ram buf as tab ram: */
  913   1          DrvAfeSelTaborRepRam(AREA_TBL_RAM);
  914   1      
  915   1          //tab 2
  916   1          Drv_XsiWriteReg(pXSI0Regs,TAB_START_ADDR+TAB_RAM_LEN*2+0,usReg0,AFE_REG);
  917   1          Drv_XsiWriteReg(pXSI1Regs,TAB_START_ADDR+TAB_RAM_LEN*2+0,usReg0,AFE_REG);
  918   1          Drv_XsiWriteReg(pXSI0Regs,TAB_START_ADDR+TAB_RAM_LEN*2+1,usReg1,AFE_REG); 
  919   1          Drv_XsiWriteReg(pXSI1Regs,TAB_START_ADDR+TAB_RAM_LEN*2+1,usReg1,AFE_REG);
  920   1          Drv_XsiWriteReg(pXSI0Regs,TAB_START_ADDR+TAB_RAM_LEN*2+2,usReg2,AFE_REG); 
  921   1          Drv_XsiWriteReg(pXSI1Regs,TAB_START_ADDR+TAB_RAM_LEN*2+2,usReg2,AFE_REG);
  922   1          Drv_XsiWriteReg(pXSI0Regs,TAB_START_ADDR+TAB_RAM_LEN*2+3,usReg3,AFE_REG);
  923   1          Drv_XsiWriteReg(pXSI1Regs,TAB_START_ADDR+TAB_RAM_LEN*2+3,usReg3,AFE_REG);
  924   1          Drv_XsiWriteReg(pXSI0Regs,TAB_START_ADDR+TAB_RAM_LEN*2+4,usReg4,AFE_REG);
  925   1          Drv_XsiWriteReg(pXSI1Regs,TAB_START_ADDR+TAB_RAM_LEN*2+4,usReg4,AFE_REG);
  926   1          Drv_XsiWriteReg(pXSI0Regs,TAB_START_ADDR+TAB_RAM_LEN*2+5,usReg5,AFE_REG); 
  927   1          Drv_XsiWriteReg(pXSI1Regs,TAB_START_ADDR+TAB_RAM_LEN*2+5,usReg5,AFE_REG);
  928   1          Drv_XsiWriteReg(pXSI0Regs,TAB_START_ADDR+TAB_RAM_LEN*2+6,usReg6,AFE_REG); 
  929   1          Drv_XsiWriteReg(pXSI1Regs,TAB_START_ADDR+TAB_RAM_LEN*2+6,usReg6,AFE_REG);
  930   1          Drv_XsiWriteReg(pXSI0Regs,TAB_START_ADDR+TAB_RAM_LEN*2+7,usReg7,AFE_REG); 
  931   1          Drv_XsiWriteReg(pXSI1Regs,TAB_START_ADDR+TAB_RAM_LEN*2+7,usReg7,AFE_REG);
  932   1          Drv_XsiWriteReg(pXSI0Regs,TAB_START_ADDR+TAB_RAM_LEN*2+8,usReg8,AFE_REG); 
  933   1          Drv_XsiWriteReg(pXSI1Regs,TAB_START_ADDR+TAB_RAM_LEN*2+8,usReg8,AFE_REG);
  934   1          Drv_XsiWriteReg(pXSI0Regs,TAB_START_ADDR+TAB_RAM_LEN*2+9,usReg9,AFE_REG); 
  935   1          Drv_XsiWriteReg(pXSI1Regs,TAB_START_ADDR+TAB_RAM_LEN*2+9,usReg9,AFE_REG);
  936   1          
  937   1      #if 1
  938   1          Afe_SetTabCBChEN(2);
  939   1      #else
               //    DrvClbCB(0);
               #endif
  942   1      }
  943          /*******************************************************************************
  944          *  Brief: ±íÏî3ÅäÖÃ¡£Ò»¹²ÓÐ4¸ö±íÏî , Ó²¼þCBÐ£Õý ²âÊÔ
  945          *  Input: 
C251 COMPILER V5.54.0.0,  DrvAfePara                                                       26/05/17  20:21:06  PAGE 16  

  946          * Output: 
  947          * Return: 
  948          *******************************************************************************/
  949          void Afe_Config_Tab3(void)
  950          {
  951   1      //    UINT16 XRAM i;
  952   1      //    UINT16 XRAM usTblBaseAddr;
  953   1          UINT16 XRAM usReg0;
  954   1          UINT16 XRAM usReg1;
  955   1          UINT16 XRAM usReg2;
  956   1          UINT16 XRAM usReg3;
  957   1          UINT16 XRAM usReg4;
  958   1          UINT16 XRAM usReg5;
  959   1          UINT16 XRAM usReg6;
  960   1          UINT16 XRAM usReg7;
  961   1          UINT16 XRAM usReg8;
  962   1          UINT16 XRAM usReg9;
  963   1      
  964   1          usReg0 = rAFE_SYS_CFG1;
  965   1          
  966   1          usReg1 = rAFE_SCAN_CFG0;
  967   1          usReg1 =((2<<BIT_AFE_SCAN_TIMES)               //É¨Ãè´ÎÊý£¬Êµ¼ÊÖµÎªÅäÖÃÖµ¼Ó1;  
  968   1                  +(4<<BIT_AFE_SCAN_MODE));             //·½Ê½0
  969   1                  
  970   1          usReg2 = rAFE_SCAN_CFG1;
  971   1          usReg2 =((0<<9)               //[10:9] ²ÉÑùÄ£Ê½: 0:Ë«±ß²ÉÑù£¬Ä£ÄâÏà¼õ; 1:¸º±ß²ÉÑù; 2:Õý±ß²ÉÑù; 3:Ë«±ß
             -²ÉÑù£¬Êý×ÖÏà¼õ      
  972   1                  +(0<<8)               //[8] SXÉ¨Ãè·½Ê½:  0:Ë«±ßÉ¨Ãè(4ÖÖ²ÉÑùmode); 1: µ¥±ßÉ¨Ãè(½ö1ÖÖµ¥±ß²ÉÑù)
  973   1                  +(4<<0));             //[0] ·½Ê½6£¬É¨Ãè¶ÎÊý  
  974   1                  
  975   1          usReg3 = rAFE_DUMMY_SCAN_CFG;
  976   1          usReg3 =((1<<10)               //[14:10]MuxÇÐ»»Ö®¼äDummy´ÎÊý    
  977   1                  +(0<<5)               //[9:5]¿ÓÇ°Dummy´ÎÊý
  978   1                  +(2<<0));             //[4:0]TpÖ¡Ç°Dummy´ÎÊý   
  979   1                  
  980   1          usReg4 = rAFE_BASE_TRACK_CFG;
  981   1          usReg4 = ((80<<BIT_BASE_TRACK_STEP)             //[9:2]MonitorÄ£Ê½£¬Base¸ú×Ù£¬²½½ø¸ú×Ù²½³¤           
             -                                      
  982   1                    +(0<<BIT_BASE_TRACK_MODE)             //[1] MonitorÄ£Ê½£¬Base¸ú×Ù·½Ê½: 0:²½½ø¸ú×Ù; 1:Ô­Öµ¸ú
             -×Ù
  983   1                    +(1<<BIT_BASE_TRACK_ENABLE));         //[0] MontiorÄ£Ê½£¬Base¸ú×ÙÊ¹ÄÜ£¬1:Ê¹ÄÜ 
  984   1                    
  985   1          usReg5 = rACC_OFFSET;
  986   1          usReg6 = rTP_MONITOR_THRESHOLD;
  987   1          usReg7 = rKEY_MONITOR_THRESHOLD;
  988   1          usReg8 = rAFE_ANA_K1_CFG0;
  989   1          usReg9 = rAFE_ANA_K2_CFG1;
  990   1      
  991   1          /* set ram buf as tab ram: */
  992   1          DrvAfeSelTaborRepRam(AREA_TBL_RAM);
  993   1      
  994   1          //tab 3
  995   1          Drv_XsiWriteReg(pXSI0Regs,TAB_START_ADDR+TAB_RAM_LEN*3+0,usReg0,AFE_REG);
  996   1          Drv_XsiWriteReg(pXSI1Regs,TAB_START_ADDR+TAB_RAM_LEN*3+0,usReg0,AFE_REG);
  997   1          Drv_XsiWriteReg(pXSI0Regs,TAB_START_ADDR+TAB_RAM_LEN*3+1,usReg1,AFE_REG); 
  998   1          Drv_XsiWriteReg(pXSI1Regs,TAB_START_ADDR+TAB_RAM_LEN*3+1,usReg1,AFE_REG);
  999   1          Drv_XsiWriteReg(pXSI0Regs,TAB_START_ADDR+TAB_RAM_LEN*3+2,usReg2,AFE_REG); 
 1000   1          Drv_XsiWriteReg(pXSI1Regs,TAB_START_ADDR+TAB_RAM_LEN*3+2,usReg2,AFE_REG);
 1001   1          Drv_XsiWriteReg(pXSI0Regs,TAB_START_ADDR+TAB_RAM_LEN*3+3,usReg3,AFE_REG);
 1002   1          Drv_XsiWriteReg(pXSI1Regs,TAB_START_ADDR+TAB_RAM_LEN*3+3,usReg3,AFE_REG);
 1003   1          Drv_XsiWriteReg(pXSI0Regs,TAB_START_ADDR+TAB_RAM_LEN*3+4,usReg4,AFE_REG);
 1004   1          Drv_XsiWriteReg(pXSI1Regs,TAB_START_ADDR+TAB_RAM_LEN*3+4,usReg4,AFE_REG);
 1005   1          Drv_XsiWriteReg(pXSI0Regs,TAB_START_ADDR+TAB_RAM_LEN*3+5,usReg5,AFE_REG); 
 1006   1          Drv_XsiWriteReg(pXSI1Regs,TAB_START_ADDR+TAB_RAM_LEN*3+5,usReg5,AFE_REG);
 1007   1          Drv_XsiWriteReg(pXSI0Regs,TAB_START_ADDR+TAB_RAM_LEN*3+6,usReg6,AFE_REG); 
 1008   1          Drv_XsiWriteReg(pXSI1Regs,TAB_START_ADDR+TAB_RAM_LEN*3+6,usReg6,AFE_REG);
C251 COMPILER V5.54.0.0,  DrvAfePara                                                       26/05/17  20:21:06  PAGE 17  

 1009   1          Drv_XsiWriteReg(pXSI0Regs,TAB_START_ADDR+TAB_RAM_LEN*3+7,usReg7,AFE_REG); 
 1010   1          Drv_XsiWriteReg(pXSI1Regs,TAB_START_ADDR+TAB_RAM_LEN*3+7,usReg7,AFE_REG);
 1011   1          Drv_XsiWriteReg(pXSI0Regs,TAB_START_ADDR+TAB_RAM_LEN*3+8,usReg8,AFE_REG); 
 1012   1          Drv_XsiWriteReg(pXSI1Regs,TAB_START_ADDR+TAB_RAM_LEN*3+8,usReg8,AFE_REG);
 1013   1          Drv_XsiWriteReg(pXSI0Regs,TAB_START_ADDR+TAB_RAM_LEN*3+9,usReg9,AFE_REG); 
 1014   1          Drv_XsiWriteReg(pXSI1Regs,TAB_START_ADDR+TAB_RAM_LEN*3+9,usReg9,AFE_REG);
 1015   1          
 1016   1      #if 1
 1017   1          Afe_SetTabCBChEN(3);
 1018   1      #else
                   DrvClbCB(0);
               #endif
 1021   1      }
 1022          
 1023          
 1024          /*******************************************************************************
 1025          *  Brief: ±íÏî3ÅäÖÃ¡£Ò»¹²ÓÐ4¸ö±íÏî , Ó²¼þCBÐ£Õý ²âÊÔ
 1026          *  Input: 
 1027          * Output: 
 1028          * Return: 
 1029          *******************************************************************************/
 1030          void Afe_Change_Tab3(UINT8 ucTestMode,UINT8 ucScanMode,UINT8 usScanNum)
 1031          {
 1032   1      //    UINT16 XRAM i;
 1033   1      //    UINT16 XRAM usTblBaseAddr;
 1034   1          UINT16 XRAM usReg0;
 1035   1          UINT16 XRAM usReg1;
 1036   1          UINT16 XRAM usReg2;
 1037   1          UINT16 XRAM usReg3;
 1038   1          UINT16 XRAM usReg4;
 1039   1          UINT16 XRAM usReg5;
 1040   1          UINT16 XRAM usReg6;
 1041   1          UINT16 XRAM usReg7;
 1042   1          UINT16 XRAM usReg8;
 1043   1          UINT16 XRAM usReg9;
 1044   1      
 1045   1          switch(ucTestMode)
 1046   1          {
 1047   2              case 0:                 //CB
 1048   2              {
 1049   3                  usReg0 = rAFE_SYS_CFG1;
 1050   3                  
 1051   3                  usReg1 = rAFE_SCAN_CFG0;
 1052   3      
 1053   3      
 1054   3                  usReg1 =(((usScanNum)<<BIT_AFE_SCAN_TIMES)                   //É¨Ãè´ÎÊý£¬Êµ¼ÊÖµÎªÅäÖÃÖµ¼Ó1;  
 1055   3                          +(ucScanMode<<BIT_AFE_SCAN_MODE));                   //É¨Ãè·½Ê½
 1056   3      
 1057   3                  usReg2 = rAFE_SCAN_CFG1;
 1058   3                  usReg2 =((0<<9)               //[10:9] ²ÉÑùÄ£Ê½: 0:Ë«±ß²ÉÑù£¬Ä£ÄâÏà¼õ; 1:¸º±ß²ÉÑù; 2:Õý±ß²ÉÑù
             -; 3:Ë«±ß²ÉÑù£¬Êý×ÖÏà¼õ      
 1059   3                          +(0<<8)               //[8] SXÉ¨Ãè·½Ê½:  0:Ë«±ßÉ¨Ãè(4ÖÖ²ÉÑùmode); 1: µ¥±ßÉ¨Ãè(½ö1ÖÖµ¥
             -±ß²ÉÑù)
 1060   3                          +(4<<0));             //[0] ·½Ê½6£¬É¨Ãè¶ÎÊý  
 1061   3                          
 1062   3                  usReg3 = rAFE_DUMMY_SCAN_CFG;
 1063   3                  usReg3 =((1<<10)               //[14:10]MuxÇÐ»»Ö®¼äDummy´ÎÊý    
 1064   3                          +(0<<5)               //[9:5]¿ÓÇ°Dummy´ÎÊý
 1065   3                          +(2<<0));             //[4:0]TpÖ¡Ç°Dummy´ÎÊý   
 1066   3                          
 1067   3                  usReg4 = rAFE_BASE_TRACK_CFG;
 1068   3                  usReg4 = ((80<<BIT_BASE_TRACK_STEP)             //[9:2]MonitorÄ£Ê½£¬Base¸ú×Ù£¬²½½ø¸ú×Ù²½³¤   
             -                                              
 1069   3                            +(0<<BIT_BASE_TRACK_MODE)             //[1] MonitorÄ£Ê½£¬Base¸ú×Ù·½Ê½: 0:²½½ø¸ú×Ù; 
             -1:Ô­Öµ¸ú×Ù
 1070   3                            +(1<<BIT_BASE_TRACK_ENABLE));         //[0] MontiorÄ£Ê½£¬Base¸ú×ÙÊ¹ÄÜ£¬1:Ê¹ÄÜ 
C251 COMPILER V5.54.0.0,  DrvAfePara                                                       26/05/17  20:21:06  PAGE 18  

 1071   3                            
 1072   3                  usReg5 = rACC_OFFSET;
 1073   3                  usReg6 = rTP_MONITOR_THRESHOLD;
 1074   3                  usReg7 = rKEY_MONITOR_THRESHOLD;
 1075   3                  usReg8 = rAFE_ANA_K1_CFG0;
 1076   3                  usReg9 = rAFE_ANA_K2_CFG1;            
 1077   3                  break;
 1078   3              }
 1079   2      
 1080   2              case 1:             // hw monitor
 1081   2              {
 1082   3                  usReg0 = rAFE_SYS_CFG1;
 1083   3        
 1084   3                  usReg1 = rAFE_SCAN_CFG0;
 1085   3                  usReg1 =(((usScanNum)<<BIT_AFE_SCAN_TIMES)      //É¨Ãè´ÎÊý£¬Êµ¼ÊÖµÎªÅäÖÃÖµ¼Ó1;  
 1086   3                          +(ucScanMode<<BIT_AFE_SCAN_MODE));      //É¨Ãè·½Ê½
 1087   3      
 1088   3      
 1089   3                  usReg3 = rAFE_DUMMY_SCAN_CFG;
 1090   3                  usReg3 =((1<<10)                                //[11:8]MuxÇÐ»»Ö®¼äDummy´ÎÊý    
 1091   3                          +(0<<5)                                 //[7:4]¿ÓÇ°Dummy´ÎÊý
 1092   3                          +(2<<0));                               //[3:0]TpÖ¡Ç°Dummy´ÎÊý    
 1093   3      
 1094   3                  //ÉèÖÃ´¥Ãþ¼ì²âÊ±£¬TP,keyÍ¨µÀµÄ´¥ÃþãÐÖµ     
 1095   3                  usReg6 = 20; //rTP_MONITOR_THRESHOLD;
 1096   3                  usReg7 = 20; //rKEY_MONITOR_THRESHOLD;  
 1097   3      
 1098   3                          
 1099   3                  usReg2 = rAFE_SCAN_CFG1; 
 1100   3                  usReg2 =((0<<9)               //[10:9] ²ÉÑùÄ£Ê½: 0:Ë«±ß²ÉÑù£¬Ä£ÄâÏà¼õ; 1:¸º±ß²ÉÑù; 2:Õý±ß²ÉÑù
             -; 3:Ë«±ß²ÉÑù£¬Êý×ÖÏà¼õ      
 1101   3                          +(0<<8)               //[8] SXÉ¨Ãè·½Ê½:  0:Ë«±ßÉ¨Ãè(4ÖÖ²ÉÑùmode); 1: µ¥±ßÉ¨Ãè(½ö1ÖÖµ¥
             -±ß²ÉÑù)
 1102   3                          +(4<<0));             //[0] ·½Ê½6£¬É¨Ãè¶ÎÊý             
 1103   3      
 1104   3                  //ÉèÖÃ³É²½½ø¸ú×Ù,    ¸ú×Ù²½³¤32(0x20)        
 1105   3                  usReg4 = rAFE_BASE_TRACK_CFG;
 1106   3                  usReg4 = ((32<<BIT_BASE_TRACK_STEP)             //[9:2]MonitorÄ£Ê½£¬Base¸ú×Ù£¬²½½ø¸ú×Ù²½³¤   
             -                                              
 1107   3                           // +(0<<BIT_BASE_TRACK_MODE)             //[1] MonitorÄ£Ê½£¬Base¸ú×Ù·½Ê½: 0:²½½ø¸ú×Ù
             -; 
 1108   3                            +(1<<BIT_BASE_TRACK_MODE)             //[1] MonitorÄ£Ê½£¬Base¸ú×Ù·½Ê½:   1:Ô­Öµ¸ú×Ù
 1109   3                            +(1<<BIT_BASE_TRACK_ENABLE));         //[0] MontiorÄ£Ê½£¬Base¸ú×ÙÊ¹ÄÜ£¬1:Ê¹ÄÜ 
 1110   3                            
 1111   3                  usReg5 = rACC_OFFSET;
 1112   3                  
 1113   3                  
 1114   3                  usReg8 = rAFE_ANA_K1_CFG0;
 1115   3                  usReg9 = rAFE_ANA_K2_CFG1;            
 1116   3                  
 1117   3                  break;
 1118   3              }
 1119   2      
 1120   2              case 2:           //mcap
 1121   2              {
 1122   3                  usReg0 = rAFE_SYS_CFG1|(0<<7);  //DAT_ACC_ASR
 1123   3                  usReg1 =((usScanNum<<BIT_AFE_SCAN_TIMES)        //É¨Ãè´ÎÊý£¬Êµ¼ÊÖµÎªÅäÖÃÖµ¼Ó1,µ«µÚ1¸ötx¹Ì¶¨Îª
             -dummy;  
 1124   3                          +(ucScanMode<<BIT_AFE_SCAN_MODE));      //É¨Ãè·½Ê½
 1125   3      
 1126   3                  
 1127   3                  usReg2 =((0<<9)+(0<<8)+(4<<0));               //[10:9] ²ÉÑùÄ£Ê½: 0:Ë«±ß²ÉÑù£¬Ä£ÄâÏà¼õ;     [8
             -]Ë«±ßÉ¨Ãè
 1128   3      
 1129   3                  usReg3 = rAFE_DUMMY_SCAN_CFG;
 1130   3                  usReg3 =((0<<10)               //[14:10]MuxÇÐ»»Ö®¼äDummy´ÎÊý    
C251 COMPILER V5.54.0.0,  DrvAfePara                                                       26/05/17  20:21:06  PAGE 19  

 1131   3                          +(0<<5)                //[9:5]¿ÓÇ°Dummy´ÎÊý
 1132   3                          +(0<<0));              //[4:0]TpÖ¡Ç°Dummy´ÎÊý  
 1133   3      
 1134   3                  usReg4 = rAFE_BASE_TRACK_CFG;
 1135   3                  usReg4 = ((0<<BIT_BASE_TRACK_STEP)             //[9:2]MonitorÄ£Ê½£¬Base¸ú×Ù£¬²½½ø¸ú×Ù²½³¤    
             -                                             
 1136   3                           +(0<<BIT_BASE_TRACK_MODE)              //[1] MonitorÄ£Ê½£¬Base¸ú×Ù·½Ê½: 0:²½½ø¸ú×Ù; 
             -1:Ô­Öµ¸ú×Ù
 1137   3                           +(1<<BIT_BASE_TRACK_ENABLE));          //[0] MontiorÄ£Ê½£¬Base¸ú×ÙÊ¹ÄÜ£¬1:Ê¹ÄÜ 
 1138   3      
 1139   3                  usReg5 = rACC_OFFSET;        //²âÊÔACC OffsetÖµ             
 1140   3      
 1141   3                  usReg6 = rTP_MONITOR_THRESHOLD;
 1142   3                  usReg7 = rKEY_MONITOR_THRESHOLD;
 1143   3      
 1144   3            /*Ë«±ßÉ¨ÃèÊ±×î¿ìÉ¨ÃèÆµÂÊÊÇ120KHz,µ¥±ß²ÉÑù×î¿ìÉ¨ÃèÆµÂÊÊÇ60KHz*/
 1145   3      
 1146   3      #if 1                    //120khz 
 1147   3                   usReg8 = 0x9B;
 1148   3                   usReg9 = 0x2E;
 1149   3      #elif 1                      //60k
                     usReg8 = 0xC2;
                     usReg9 = 0xD2;
               #else                        //100k
                     usReg8 = 0xC2;
                     usReg9 = 0x2E;    
               #endif
 1156   3                   break;
 1157   3              }
 1158   2      
 1159   2              default:
 1160   2                  break;
 1161   2          }
 1162   1      
 1163   1      
 1164   1          /* set ram buf as tab ram: */
 1165   1          DrvAfeSelTaborRepRam(AREA_TBL_RAM);
 1166   1      
 1167   1          //tab 3
 1168   1          Drv_XsiWriteReg(pXSI0Regs,TAB_START_ADDR+TAB_RAM_LEN*3+0,usReg0,AFE_REG);
 1169   1          Drv_XsiWriteReg(pXSI1Regs,TAB_START_ADDR+TAB_RAM_LEN*3+0,usReg0,AFE_REG);
 1170   1          Drv_XsiWriteReg(pXSI0Regs,TAB_START_ADDR+TAB_RAM_LEN*3+1,usReg1,AFE_REG); 
 1171   1          Drv_XsiWriteReg(pXSI1Regs,TAB_START_ADDR+TAB_RAM_LEN*3+1,usReg1,AFE_REG);
 1172   1          Drv_XsiWriteReg(pXSI0Regs,TAB_START_ADDR+TAB_RAM_LEN*3+2,usReg2,AFE_REG); 
 1173   1          Drv_XsiWriteReg(pXSI1Regs,TAB_START_ADDR+TAB_RAM_LEN*3+2,usReg2,AFE_REG);
 1174   1          Drv_XsiWriteReg(pXSI0Regs,TAB_START_ADDR+TAB_RAM_LEN*3+3,usReg3,AFE_REG);
 1175   1          Drv_XsiWriteReg(pXSI1Regs,TAB_START_ADDR+TAB_RAM_LEN*3+3,usReg3,AFE_REG);
 1176   1          Drv_XsiWriteReg(pXSI0Regs,TAB_START_ADDR+TAB_RAM_LEN*3+4,usReg4,AFE_REG);
 1177   1          Drv_XsiWriteReg(pXSI1Regs,TAB_START_ADDR+TAB_RAM_LEN*3+4,usReg4,AFE_REG);
 1178   1          Drv_XsiWriteReg(pXSI0Regs,TAB_START_ADDR+TAB_RAM_LEN*3+5,usReg5,AFE_REG); 
 1179   1          Drv_XsiWriteReg(pXSI1Regs,TAB_START_ADDR+TAB_RAM_LEN*3+5,usReg5,AFE_REG);
 1180   1          Drv_XsiWriteReg(pXSI0Regs,TAB_START_ADDR+TAB_RAM_LEN*3+6,usReg6,AFE_REG); 
 1181   1          Drv_XsiWriteReg(pXSI1Regs,TAB_START_ADDR+TAB_RAM_LEN*3+6,usReg6,AFE_REG);
 1182   1          Drv_XsiWriteReg(pXSI0Regs,TAB_START_ADDR+TAB_RAM_LEN*3+7,usReg7,AFE_REG); 
 1183   1          Drv_XsiWriteReg(pXSI1Regs,TAB_START_ADDR+TAB_RAM_LEN*3+7,usReg7,AFE_REG);
 1184   1          Drv_XsiWriteReg(pXSI0Regs,TAB_START_ADDR+TAB_RAM_LEN*3+8,usReg8,AFE_REG); 
 1185   1          Drv_XsiWriteReg(pXSI1Regs,TAB_START_ADDR+TAB_RAM_LEN*3+8,usReg8,AFE_REG);
 1186   1          Drv_XsiWriteReg(pXSI0Regs,TAB_START_ADDR+TAB_RAM_LEN*3+9,usReg9,AFE_REG); 
 1187   1          Drv_XsiWriteReg(pXSI1Regs,TAB_START_ADDR+TAB_RAM_LEN*3+9,usReg9,AFE_REG);
 1188   1          
 1189   1      #if 1
 1190   1          Afe_SetTabCBChEN(3);
 1191   1      #else
               //    DrvClbCB(0);
               #endif
 1194   1      }
C251 COMPILER V5.54.0.0,  DrvAfePara                                                       26/05/17  20:21:06  PAGE 20  

 1195          
 1196          
 1197          
 1198          /*******************************************************************************
 1199          *   Name: DrvSetCbDir
 1200          *  Brief: 
 1201          *  Input: 
 1202          * Output: 
 1203          * Return: 
 1204          *******************************************************************************/
 1205          void DrvSetCbDir(UINT8 ucTpDir,UINT8 ucKeyDir)
 1206          {
 1207   1          UINT16 XRAM Reg4;
 1208   1          Reg4 = Drv_XsiReadReg(pXSI0Regs, Addr_AFE_SYS_CFG0, AFE_REG);
 1209   1      
 1210   1          Reg4 &= 0xF9FF;
 1211   1        Reg4 |= (ucKeyDir<<10)|(ucTpDir<<9);
 1212   1        
 1213   1          Drv_XsiWriteReg(pXSI0Regs, Addr_AFE_SYS_CFG0, Reg4, AFE_REG);
 1214   1          Drv_XsiWriteReg(pXSI1Regs, Addr_AFE_SYS_CFG0, Reg4, AFE_REG);    
 1215   1      }
 1216          
 1217          
 1218          /*******************************************************************************
 1219          *   Name: DrvGetTabRamCb
 1220          *  Brief: 
 1221          *  Input: 
 1222          * Output: 
 1223          * Return: 
 1224          *******************************************************************************/
 1225          void DrvGetTabRamCb(void)
 1226          {
 1227   1          UINT16 XRAM i;
 1228   1          UINT16 XRAM aus_tabbuf[TAB_RAM_LEN - 10];
 1229   1      
 1230   1          DBG_FLOW("\nRead CB from TabRam");
 1231   1          DBG_FLOW("\nAFE_L CB:");
 1232   1          DrvAfeSelTaborRepRam(AREA_TBL_RAM);
 1233   1          Drv_XsiRead(pXSI0Regs,TAB_RAM_START_ADDR+3*TAB_RAM_LEN + 10,aus_tabbuf,TAB_RAM_LEN - 10,AFE_REG);
 1234   1      
 1235   1          for(i = 4; i < TAB_RAM_LEN - 10;i++)
 1236   1          {
 1237   2              if((i%18) == 4)
 1238   2              {
 1239   3                  DBG_FLOW("\n");
 1240   3              }
 1241   2              
 1242   2              DBG_FLOW("%04x  ",aus_tabbuf[i]);    
 1243   2          }
 1244   1          
 1245   1          DBG_FLOW("\n\n");
 1246   1          DBG_FLOW("\nAFE_R CB:");    
 1247   1          Drv_XsiRead(pXSI1Regs,TAB_RAM_START_ADDR+3*TAB_RAM_LEN + 10,aus_tabbuf,TAB_RAM_LEN - 10,AFE_REG);
 1248   1          for(i = 4; i < TAB_RAM_LEN - 10;i++)
 1249   1          {    
 1250   2              if((i%18) == 4)
 1251   2              {
 1252   3                  DBG_FLOW("\n");
 1253   3              }        
 1254   2              DBG_FLOW("%04x  ",aus_tabbuf[i]);     
 1255   2          }
 1256   1      
 1257   1          DBG_FLOW("\n\n");
 1258   1          DBG_FLOW("AFE_KEY CB:\n");
 1259   1          Drv_XsiRead(pXSI0Regs,TAB_RAM_START_ADDR+3*TAB_RAM_LEN + 10,aus_tabbuf,4,AFE_REG); 
 1260   1          for(i = 0; i < 4; i++)
C251 COMPILER V5.54.0.0,  DrvAfePara                                                       26/05/17  20:21:06  PAGE 21  

 1261   1          {
 1262   2              DBG_FLOW("%04x  ",aus_tabbuf[i]); 
 1263   2          }
 1264   1          Drv_XsiRead(pXSI1Regs,TAB_RAM_START_ADDR+3*TAB_RAM_LEN + 10,aus_tabbuf,4,AFE_REG); 
 1265   1          for(i = 0; i < 4; i++)
 1266   1          {
 1267   2              DBG_FLOW("%04x  ",aus_tabbuf[i]); 
 1268   2          }    
 1269   1      }
 1270          
 1271          
 1272          
 1273          /*******************************************************************************
 1274          *   Name: DrvSetTabMonThr
 1275          *  Brief: 
 1276          *  Input: 
 1277          * Output: 
 1278          * Return: 
 1279          *******************************************************************************/
 1280          void DrvSetTabMonThr(UINT16 usTpMonThr,UINT16 usKeyMonThr,UINT8 usTabId)
 1281          {
 1282   1              /* set ram buf as tab ram: */
 1283   1          DrvAfeSelTaborRepRam(AREA_TBL_RAM);
 1284   1              
 1285   1          Drv_XsiWriteReg(pXSI0Regs,TAB_START_ADDR+TAB_RAM_LEN*usTabId+6,usTpMonThr,AFE_REG);
 1286   1          Drv_XsiWriteReg(pXSI1Regs,TAB_START_ADDR+TAB_RAM_LEN*usTabId+6,usTpMonThr,AFE_REG);
 1287   1          Drv_XsiWriteReg(pXSI0Regs,TAB_START_ADDR+TAB_RAM_LEN*usTabId+7,usKeyMonThr,AFE_REG); 
 1288   1          Drv_XsiWriteReg(pXSI1Regs,TAB_START_ADDR+TAB_RAM_LEN*usTabId+7,usKeyMonThr,AFE_REG);
 1289   1      }
 1290          
 1291          /*******************************************************************************
 1292          *   Name: DrvMcapSetMode
 1293          *  Brief: »¥ÈÝ°´¼üÆô¶¯ÉèÖÃ 
 1294          *  Input: ucModeEn  0:¹Ø±Õ»¥ÈÝ°´¼ü;1:¿ªÆô»¥ÈÝ°´¼ü
 1295          * Output: 
 1296          * Return: 
 1297          *******************************************************************************/
 1298          void DrvMcapSetMode(UINT8 ucModeEn)
 1299          {
 1300   1          UINT16 XRAM Reg64 = 0;
 1301   1      
 1302   1          Reg64 = Drv_XsiReadReg(pXSIREG,Addr_MCAP_SCAN_CFG,AFE_REG);
 1303   1          Reg64 &= ~(1<<15);
 1304   1          if(ucModeEn)           //¿ªÆô»¥ÈÝ°´¼ü 
 1305   1          {
 1306   2              Reg64 |= (1<<15);             
 1307   2          }
 1308   1      
 1309   1          Drv_XsiWriteReg(pXSI0Regs,Addr_MCAP_SCAN_CFG,Reg64,AFE_REG);
 1310   1          Drv_XsiWriteReg(pXSI1Regs,Addr_MCAP_SCAN_CFG,Reg64,AFE_REG);    
 1311   1      }
 1312          
 1313          /*******************************************************************************
 1314          *   Name: DrvMcapSetFir
 1315          *  Brief: »¥ÈÝ°´¼ü²ÉÑùÂÊÅäÖÃ 
 1316          *  Input: ucMode  0:6±¶²ÉÑùÂÊ;1:8±¶²ÉÑùÂÊ
 1317          * Output: 
 1318          * Return: 
 1319          *******************************************************************************/
 1320          void DrvMcapSetFir(ST_McapParameter * pMcapPara)
 1321          {
 1322   1          UINT16 XRAM Reg79 = 0,Reg66 = 0;
 1323   1      
 1324   1          //Reg79 = Drv_XsiReadReg(pXSI0Regs,0x4F,AFE_REG);
 1325   1      
 1326   1          //Reg79 &= 0x7FE0;           //Çå³ýmcap_hbfir_en/mcap_lpfir_en/mcap_lipfir_tap
C251 COMPILER V5.54.0.0,  DrvAfePara                                                       26/05/17  20:21:06  PAGE 22  

 1327   1      
 1328   1          if(pMcapPara->usHbFirEn)
 1329   1          {
 1330   2              //Reg79 |= (1<<15);        //¿ªÆômcap_hbfir_en 
 1331   2              ;
 1332   2          }
 1333   1          else
 1334   1          {
 1335   2              pMcapPara->usLpFirEn = 0;//¹Ø±Õmcap_hbfir_en£¬ÐèÍ¬Ê±¹Ø±Õmcap_lpfir_en
 1336   2          }
 1337   1      
 1338   1      #if 0    
                   if(pMcapPara->usLpFirEn)
                   {
                       Reg79 |=(1<<4);         //¿ªÆômcap_lpfir_en
                   }
               #endif
 1344   1      
 1345   1          //Reg79 |=(0x0F&pMcapPara->usLpFirTap);   //mcap_lpfir_tap
 1346   1      
 1347   1          DBG_FLOW("\nLpFirTap:%d",pMcapPara->usLpFirTap);
 1348   1          DBG_FLOW("\nLpFirStart:%d",pMcapPara->usLpFirStart);
 1349   1      
 1350   1          if(pMcapPara->usLpFirTap > pMcapPara->usLpFirStart)
 1351   1          {
 1352   2              DBG_FLOW("\nLpFirStart should be not smaller than LpFirTap");
 1353   2              //pMcapPara->usLpFirStart = pMcapPara->usLpFirTap;
 1354   2          }
 1355   1      #if 0
                   Reg79 |= (((0x1F&pMcapPara->usLpFirStart)<<10)\         
                         +  ((pMcapPara->usHbFirEn)<<15)\
                         +  ((pMcapPara->usLpFirEn)<<4)\
                         +  (0x0F&pMcapPara->usLpFirTap)\                  
                         +  ((0x1F&pMcapPara->usLpFirSumNum)<<5));         
               #else
 1362   1          Reg79 = (((0x1F&pMcapPara->usLpFirStart)<<10)\         
 1363   1                +  ((pMcapPara->usHbFirEn)<<15)\
 1364   1                +  ((pMcapPara->usLpFirEn)<<4)\
 1365   1                +  (0x0F&pMcapPara->usLpFirTap));
 1366   1      
 1367   1          Reg66 = (0x1FF&pMcapPara->usLpFirSumNum);
 1368   1          Drv_XsiWriteReg(pXSI0Regs,Addr_MCAP_LPFIR_SUM_NUM,Reg66,AFE_REG);
 1369   1          Drv_XsiWriteReg(pXSI1Regs,Addr_MCAP_LPFIR_SUM_NUM,Reg66,AFE_REG);
 1370   1      
 1371   1      #endif
 1372   1          Drv_XsiWriteReg(pXSI0Regs,Addr_MCAP_LPFIR_CFG,Reg79,AFE_REG);
 1373   1          Drv_XsiWriteReg(pXSI1Regs,Addr_MCAP_LPFIR_CFG,Reg79,AFE_REG);     
 1374   1      
 1375   1      
 1376   1      #if 0        
                   Drv_XsiWriteReg(pXSI0Regs,0x50,pMcapPara->usLpFirCof0,AFE_REG);
                   Drv_XsiWriteReg(pXSI1Regs,0x50,pMcapPara->usLpFirCof0,AFE_REG); 
               
                   Drv_XsiWriteReg(pXSI0Regs,0x51,pMcapPara->usLpFirCof1,AFE_REG);
                   Drv_XsiWriteReg(pXSI1Regs,0x51,pMcapPara->usLpFirCof1,AFE_REG); 
               
                   Drv_XsiWriteReg(pXSI0Regs,0x52,pMcapPara->usLpFirCof2,AFE_REG);
                   Drv_XsiWriteReg(pXSI1Regs,0x52,pMcapPara->usLpFirCof2,AFE_REG);
               
                   Drv_XsiWriteReg(pXSI0Regs,0x53,pMcapPara->usLpFirCof3,AFE_REG);
                   Drv_XsiWriteReg(pXSI1Regs,0x53,pMcapPara->usLpFirCof3,AFE_REG);
               
                   Drv_XsiWriteReg(pXSI0Regs,0x54,pMcapPara->usLpFirCof4,AFE_REG);
                   Drv_XsiWriteReg(pXSI1Regs,0x54,pMcapPara->usLpFirCof4,AFE_REG);
               
                   Drv_XsiWriteReg(pXSI0Regs,0x55,pMcapPara->usLpFirCof5,AFE_REG);
C251 COMPILER V5.54.0.0,  DrvAfePara                                                       26/05/17  20:21:06  PAGE 23  

                   Drv_XsiWriteReg(pXSI1Regs,0x55,pMcapPara->usLpFirCof5,AFE_REG); 
               
                   Drv_XsiWriteReg(pXSI0Regs,0x56,pMcapPara->usLpFirCof6,AFE_REG);
                   Drv_XsiWriteReg(pXSI1Regs,0x56,pMcapPara->usLpFirCof6,AFE_REG);
               
                   Drv_XsiWriteReg(pXSI0Regs,0x57,pMcapPara->usLpFirCof7,AFE_REG);
                   Drv_XsiWriteReg(pXSI1Regs,0x57,pMcapPara->usLpFirCof7,AFE_REG);
               #endif    
 1401   1      }
 1402          
 1403          
 1404          
 1405          /*******************************************************************************
 1406          *   Name: DrvMcapSetSampleRate
 1407          *  Brief: »¥ÈÝ°´¼ü²ÉÑùÂÊÅäÖÃ 
 1408          *  Input: ucMode  0:6±¶²ÉÑùÂÊ;1:8±¶²ÉÑùÂÊ
 1409          * Output: 
 1410          * Return: 
 1411          *******************************************************************************/
 1412          void DrvMcapSetSampleRate(ST_McapParameter * pMcapPara,ST_AfeTabList * pAfeTabPara,UINT8 ucTabId)
 1413          {
 1414   1          UINT16 XRAM Reg1 = pAfeTabPara->usScanCfg0;
 1415   1          UINT16 XRAM Reg2 = pAfeTabPara->usScanCfg1;
 1416   1          UINT16 XRAM Reg3 = pAfeTabPara->usDummyScanCfg;
 1417   1          UINT16 XRAM Reg64 = 0;
 1418   1          UINT16 XRAM ucTemp;
 1419   1          
 1420   1          Reg64 = Drv_XsiReadReg(pXSIREG,Addr_MCAP_SCAN_CFG,AFE_REG);
 1421   1      
 1422   1          if(pMcapPara->usSampl_6 == 0)
 1423   1          {
 1424   2              Reg64 |= (1<<4);      //8±¶²ÉÑùÂÊ         
 1425   2          }
 1426   1          else
 1427   1          {
 1428   2              Reg64 &= ~(1<<4);    //6±¶²ÉÑùÂÊ
 1429   2      
 1430   2              ucTemp = (pMcapPara->usK1+pMcapPara->usK2+2)/3;
 1431   2      
 1432   2              DBG_FLOW("\nkey_sampl_6:%04x",ucTemp);
 1433   2      
 1434   2              DrvAfeSelTaborRepRam(AREA_TBL_RAM);
 1435   2      
 1436   2              Reg1 |= (((ucTemp&0x07C0) >>6)<<11);  //key_sampl_interval_6[10:6]        
 1437   2              Reg2 |= (((ucTemp&0x003E) >>1)<<11);  //key_sampl_interval_6[5:1]
 1438   2              Reg3 |= (((ucTemp&0x0001) >>0)<<15);  //key_sampl_interval_6[0]
 1439   2      
 1440   2              DBG_FLOW("\nReg1:%04x",Reg1);
 1441   2              DBG_FLOW("\nReg2:%04x",Reg2);
 1442   2              DBG_FLOW("\nReg3:%04x",Reg3);
 1443   2      
 1444   2              Drv_XsiWriteReg(pXSI0Regs,TAB_START_ADDR+TAB_RAM_LEN*ucTabId+1,Reg1,AFE_REG);
 1445   2              Drv_XsiWriteReg(pXSI1Regs,TAB_START_ADDR+TAB_RAM_LEN*ucTabId+1,Reg1,AFE_REG);
 1446   2              Drv_XsiWriteReg(pXSI0Regs,TAB_START_ADDR+TAB_RAM_LEN*ucTabId+2,Reg2,AFE_REG);
 1447   2              Drv_XsiWriteReg(pXSI1Regs,TAB_START_ADDR+TAB_RAM_LEN*ucTabId+2,Reg2,AFE_REG); 
 1448   2              Drv_XsiWriteReg(pXSI0Regs,TAB_START_ADDR+TAB_RAM_LEN*ucTabId+3,Reg3,AFE_REG);
 1449   2              Drv_XsiWriteReg(pXSI1Regs,TAB_START_ADDR+TAB_RAM_LEN*ucTabId+3,Reg3,AFE_REG); 
 1450   2              pAfeTabPara->usScanCfg0 = Reg1;
 1451   2              pAfeTabPara->usScanCfg1 = Reg2;
 1452   2              pAfeTabPara->usDummyScanCfg =Reg3;
 1453   2             
 1454   2          }
 1455   1          Drv_XsiWriteReg(pXSI0Regs,Addr_MCAP_SCAN_CFG,Reg64,AFE_REG);
 1456   1          Drv_XsiWriteReg(pXSI1Regs,Addr_MCAP_SCAN_CFG,Reg64,AFE_REG);        
 1457   1      }
 1458          
C251 COMPILER V5.54.0.0,  DrvAfePara                                                       26/05/17  20:21:06  PAGE 24  

 1459          
 1460          /*******************************************************************************
 1461          *   Name: DrvMcapSetSampleInit
 1462          *  Brief: »¥ÈÝ°´¼ü²ÉÑùÆðÊ¼µãÉèÖÃ 
 1463          *  Input: ucInit  [9:0] ²ÉÑùÆðÊ¼µãÅäÖÃ
 1464          * Output: 
 1465          * Return: 
 1466          *******************************************************************************/
 1467          void DrvMcapSetSampleInit(ST_McapParameter * pMcapPara)
 1468          {
 1469   1          /*²ÉÑùÆðÊ¼µãÅäÖÃmcap_int_sampl_cfg*/
 1470   1          pMcapPara->usSampl_Init &= 0x03FF;//Ö»ÓÐºó10Î»ÓÐÐ§
 1471   1          if(pMcapPara->usSampl_Init > ((pMcapPara->usK1+pMcapPara->usK2+2)*2))
 1472   1          {
 1473   2              pMcapPara->usSampl_Init = (pMcapPara->usK1+pMcapPara->usK2+2)*2;  //×î´ó²»ÄÜ³¬¹ý(K1+K2+2)*2
 1474   2          }
 1475   1          Drv_XsiWriteReg(pXSI0Regs,Addr_MCAP_INIT_SAMPL_CFG,pMcapPara->usSampl_Init,AFE_REG);
 1476   1          Drv_XsiWriteReg(pXSI1Regs,Addr_MCAP_INIT_SAMPL_CFG,pMcapPara->usSampl_Init,AFE_REG);
 1477   1      }
 1478          
 1479          /*******************************************************************************
 1480          *   Name: DrvMcapSetAnaTiming
 1481          *  Brief: »¥ÈÝ°´¼üÄ£ÄâÊ±ÐòÅäÖÃ 
 1482          *  Input: ucDataInv/ucMsbInv
 1483          * Output: 
 1484          * Return: 
 1485          *******************************************************************************/
 1486          UINT8 DrvMcapSetAnaTiming(ST_McapParameter * pMcapPara,UINT8 ucScanMode)   
 1487          {
 1488   1          UINT8 XRAM ucDummyNum;
 1489   1          UINT8 XRAM flag = 0;
 1490   1      
 1491   1          /* µ¥¸ömuxÓÃµ½µÄ×î´ódummyÊý */
 1492   1          switch(ucScanMode)
 1493   1          {
 1494   2              case 0://É¨Ãè·½Ê½1
 1495   2              case 1://É¨Ãè·½Ê½2
 1496   2              case 2://É¨Ãè·½Ê½3
 1497   2              case 3://É¨Ãè·½Ê½4
 1498   2              case 6://É¨Ãè·½Ê½7
 1499   2              case 7:
 1500   2              {
 1501   3                  if(pMcapPara->usFrmDummy > pMcapPara->usMuxDummy)
 1502   3                  {
 1503   4                      ucDummyNum = pMcapPara->usFrmDummy + pMcapPara->usSecDummy;
 1504   4                  }
 1505   3                  else
 1506   3                  {
 1507   4                      ucDummyNum = pMcapPara->usMuxDummy + pMcapPara->usSecDummy;
 1508   4                  }
 1509   3                  break;
 1510   3              }
 1511   2                      
 1512   2              case 4://É¨Ãè·½Ê½5
 1513   2              {
 1514   3                  if((pMcapPara->usFrmDummy + pMcapPara->usSecDummy) > pMcapPara->usMuxDummy)
 1515   3                  {
 1516   4                      ucDummyNum = pMcapPara->usFrmDummy + pMcapPara->usSecDummy;
 1517   4                  }
 1518   3                  else
 1519   3                  {
 1520   4                      ucDummyNum = pMcapPara->usMuxDummy;
 1521   4                  }
 1522   3                  break;
 1523   3              }
 1524   2      
C251 COMPILER V5.54.0.0,  DrvAfePara                                                       26/05/17  20:21:06  PAGE 25  

 1525   2              case 5://É¨Ãè·½Ê½6
 1526   2              {
 1527   3                  DBG_FLOW("\nMcap is nont supported to scan mode six!!!");
 1528   3                  DBG_FLOW("\nChange to Scap!!!");
 1529   3                  DrvMcapSetMode(FALSE);
 1530   3                  return 0;
 1531   3              }
 1532   2      
 1533   2              default:
 1534   2              {
 1535   3                  DBG_FLOW("\nInput Scan Mode Err");
 1536   3                  return 0;
 1537   3              }       
 1538   2          }
 1539   1      
 1540   1          if(pMcapPara->usLpFirTap == 14)//14½×
 1541   1          {
 1542   2              if((pMcapPara->usLpFirEn)&&(pMcapPara->usHbFirEn))
 1543   2              {
 1544   3                  if((pMcapPara->usSxMode == 0)&&(pMcapPara->usSampl_6 == 1))//Ë«±ßÉ¨Ãè,6±¶²ÉÑù
 1545   3                  {
 1546   4                      if(pMcapPara->usScanNum < (ucDummyNum + 13))
 1547   4                      {
 1548   5                          flag = 1;
 1549   5                          DBG_FLOW("\nScanNum is not large enough1!");
 1550   5                          DBG_FLOW("\nlast ScanNum:%d,new ScanNum:%d",pMcapPara->usScanNum,ucDummyNum + 13);
 1551   5                          pMcapPara->usScanNum = ucDummyNum + 13;
 1552   5                      } 
 1553   4                  }
 1554   3      
 1555   3                  if((pMcapPara->usSxMode == 1)&&(pMcapPara->usSampl_6 == 1))//µ¥±ßÉ¨Ãè,6±¶²ÉÑù
 1556   3                  {
 1557   4                      if(pMcapPara->usScanNum < (ucDummyNum + 13)*2)
 1558   4                      {
 1559   5                          flag = 1;
 1560   5                          DBG_FLOW("\nScanNum is not large enough2!");
 1561   5                          DBG_FLOW("\nlast ScanNum:%d,new ScanNum:%d",pMcapPara->usScanNum,(ucDummyNum + 13)*2)
             -;
 1562   5                          pMcapPara->usScanNum = (ucDummyNum + 13)*2;
 1563   5                      } 
 1564   4                  }
 1565   3      
 1566   3                  if((pMcapPara->usSxMode == 0)&&(pMcapPara->usSampl_6 == 0))//Ë«±ßÉ¨Ãè,8±¶²ÉÑù
 1567   3                  {
 1568   4                      if(pMcapPara->usScanNum < (ucDummyNum + 11))
 1569   4                      {
 1570   5                          flag = 1;
 1571   5                          DBG_FLOW("\nScanNum is not large enough3!");
 1572   5                          DBG_FLOW("\nlast ScanNum:%d,new ScanNum:%d",pMcapPara->usScanNum,(ucDummyNum + 11));
 1573   5                          pMcapPara->usScanNum = (ucDummyNum + 11);
 1574   5                      } 
 1575   4                  }
 1576   3      
 1577   3                  if((pMcapPara->usSxMode == 1)&&(pMcapPara->usSampl_6 == 0))//µ¥±ßÉ¨Ãè,8±¶²ÉÑù
 1578   3                  {
 1579   4                      if(pMcapPara->usScanNum < (ucDummyNum + 11)*2)
 1580   4                      {
 1581   5                          flag = 1;
 1582   5                          DBG_FLOW("\nScanNum is not large enough4!");
 1583   5                          DBG_FLOW("\nlast ScanNum:%d,new ScanNum:%d",pMcapPara->usScanNum,(ucDummyNum + 13)*2)
             -;
 1584   5                          pMcapPara->usScanNum = (ucDummyNum + 11)*2;
 1585   5                      }  
 1586   4                  }
 1587   3              }
 1588   2          }
C251 COMPILER V5.54.0.0,  DrvAfePara                                                       26/05/17  20:21:06  PAGE 26  

 1589   1          return flag;
 1590   1      }
 1591          
 1592          /*******************************************************************************
 1593          *   Name: DrvMcapSetDiffMax
 1594          *  Brief: »¥ÈÝ°´¼üÊÇ·ñ¼ÆËãkeyÍ¨µÀµÄdiff_max
 1595          *  Input: ucEn/ucMode
 1596          * Output: 
 1597          * Return: 
 1598          *******************************************************************************/
 1599          void DrvMcapSetDiffMax(ST_McapParameter* pMcapPara)                       
 1600          {
 1601   1          UINT16 XRAM Reg64,Reg65;
 1602   1      
 1603   1          Reg64 = Drv_XsiReadReg(pXSIREG,0x40,AFE_REG);
 1604   1      
 1605   1          Reg64 &= ~(1<<14);                                  //²»½øÐÐdiff max¼ÆËã
 1606   1      
 1607   1          if((pMcapPara->usDiffSet)&0x02) 
 1608   1          {
 1609   2              Reg64 |= (1<<14);                                  //½øÐÐdiff max¼ÆËã
 1610   2              Reg65 = Drv_XsiReadReg(pXSIREG,0x41,AFE_REG);
 1611   2              Reg65 &= ~(1<<3);                                 //¶ÔADCÊý¾Ý½øÐÐdiff_maxÔËËã
 1612   2              if(pMcapPara->usDiffSet == 0x03)
 1613   2              {
 1614   3                  Reg65 |= (1<<3);                              //¶Ô½âµ÷ºóµÄÊý¾Ý,¼´mixerÊý¾Ý½øÐÐdiff_maxÔËËã   
             -      
 1615   3              
 1616   3              Drv_XsiWriteReg(pXSI0Regs,Addr_MCAP_SCANSR,Reg65,AFE_REG);
 1617   3              Drv_XsiWriteReg(pXSI1Regs,Addr_MCAP_SCANSR,Reg65,AFE_REG);  
 1618   3          }
 1619   2      
 1620   2          Drv_XsiWriteReg(pXSI0Regs,Addr_MCAP_SCAN_CFG,Reg64,AFE_REG);
 1621   2          Drv_XsiWriteReg(pXSI1Regs,Addr_MCAP_SCAN_CFG,Reg64,AFE_REG);    
 1622   2          }
 1623   1      }
 1624          /*******************************************************************************
 1625          *   Name: DrvMcapSetRawGain
 1626          *  Brief: »¥ÈÝ°´¼üÊÇ·ñ¶ÔRAWDATA½øÐÐÔöÒæ´¦Àí
 1627          *  Input: ucEn
 1628          * Output: 
 1629          * Return: 
 1630          *******************************************************************************/
 1631          void DrvMcapSetRawGain(ST_McapParameter* pMcapPara)                         
 1632          {
 1633   1          UINT16 XRAM Reg64,Reg67,Reg68;
 1634   1      #if 0
                 UINT16 Reg69;
               #endif  
 1637   1          Reg64 = Drv_XsiReadReg(pXSIREG,Addr_MCAP_SCAN_CFG,AFE_REG);
 1638   1      
 1639   1          Reg64 &= ~(1<<2);                                  //²»¶ÔRAWDATA½øÐÐÔöÒæ´¦Àí
 1640   1      
 1641   1          Reg68 = (pMcapPara->usRawdataOffset)&0x0000FFFF;
 1642   1      
 1643   1          Drv_XsiWriteReg(pXSI0Regs,Addr_RAWDATA_OFFSET_L,Reg68,AFE_REG);
 1644   1          Drv_XsiWriteReg(pXSI1Regs,Addr_RAWDATA_OFFSET_L,Reg68,AFE_REG); 
 1645   1          
 1646   1          if(pMcapPara->usGainEn)
 1647   1          {
 1648   2              Reg64 |= (1<<2);                                  //¶ÔRAWDATA½øÐÐÔöÒæ´¦Àí
 1649   2              Reg67 = (pMcapPara->usGainCof<<8) + pMcapPara->usRawShiftCof;
 1650   2              Drv_XsiWriteReg(pXSI0Regs,Addr_RAWSHIFTCAF,Reg67,AFE_REG);
 1651   2              Drv_XsiWriteReg(pXSI1Regs,Addr_RAWSHIFTCAF,Reg67,AFE_REG); 
 1652   2              
 1653   2      #if 0
C251 COMPILER V5.54.0.0,  DrvAfePara                                                       26/05/17  20:21:06  PAGE 27  

                       Reg69 = Drv_XsiReadReg(pXSIREG,0x45,AFE_REG);
                       Reg69 &= 0xFFF7;
                       Reg69 |= ((pMcapPara->usRawdataOffset)&0x10000)>>13;
                     
                       Drv_XsiWriteReg(pXSI0Regs,0x45,Reg69,AFE_REG);
                       Drv_XsiWriteReg(pXSI1Regs,0x45,Reg69,AFE_REG); 
               #endif          
 1661   2          }
 1662   1      
 1663   1          Drv_XsiWriteReg(pXSI0Regs,Addr_MCAP_SCAN_CFG,Reg64,AFE_REG);
 1664   1          Drv_XsiWriteReg(pXSI1Regs,Addr_MCAP_SCAN_CFG,Reg64,AFE_REG);    
 1665   1      }
 1666          
 1667          /*******************************************************************************
 1668          *   Name: DrvMcapSetOverflow
 1669          *  Brief: »¥ÈÝ°´¼üÊÇ·ñ¶ÔADCÊý¾Ý½øÐÐ±¥ºÍ¼ì²â
 1670          *  Input: 
 1671          * Output: 
 1672          * Return: 
 1673          *******************************************************************************/
 1674          void DrvMcapSetOverflow(ST_McapParameter * pMcapPara)                        
 1675          {
 1676   1          UINT16 XRAM Reg64,Reg72,Reg73,Reg74,Reg75,Reg76,Reg77,Reg78;
 1677   1        
 1678   1          Reg64 = Drv_XsiReadReg(pXSIREG,Addr_MCAP_SCAN_CFG,AFE_REG);
 1679   1          Reg64 &= 0xFFFE;                             //Çå³ýoverflow_en
 1680   1          if(pMcapPara->usOvfEn)
 1681   1          {
 1682   2              Reg64 |= 0x0001;
 1683   2      
 1684   2              Reg72 = (pMcapPara->usOvfTh)&0x0FFF;
 1685   2              Reg73 = (pMcapPara->usUdwTh)&0x0FFF;
 1686   2              Reg74 = (pMcapPara->usOvfUpBound)&0x0FFF;
 1687   2              Reg75 = (pMcapPara->usOvfPointFrm)&0x0FFF;
 1688   2      
 1689   2              Reg64 &= 0xFFFD;                        //Çå³ýoverflow_clr_en
 1690   2              if(pMcapPara->usOvfClrEn)
 1691   2              {
 1692   3                  Reg64 |= 0x0002;
 1693   3                  DBG_FLOW("\nReg64:%04x",Reg64);
 1694   3                  Reg76 = (pMcapPara->usNormalUpTh)&0x0FFF;
 1695   3                  Reg77 = (pMcapPara->usNormalDwTh)&0x0FFF;
 1696   3                  Reg78 = (pMcapPara->usOvfClrFrmNum)&0x0FFF;
 1697   3                  
 1698   3                  Drv_XsiWriteReg(pXSI0Regs,Addr_NORMAL_SIGNAL_UPTHR,Reg76,AFE_REG);
 1699   3                  Drv_XsiWriteReg(pXSI1Regs,Addr_NORMAL_SIGNAL_UPTHR,Reg76,AFE_REG); 
 1700   3      
 1701   3                  Drv_XsiWriteReg(pXSI0Regs,Addr_NORMAL_SIGNAL_DWTHR,Reg77,AFE_REG);
 1702   3                  Drv_XsiWriteReg(pXSI1Regs,Addr_NORMAL_SIGNAL_DWTHR,Reg77,AFE_REG);
 1703   3      
 1704   3                  Drv_XsiWriteReg(pXSI0Regs,Addr_OVERFLOW_CLR_FRAMENUM,Reg78,AFE_REG);
 1705   3                  Drv_XsiWriteReg(pXSI1Regs,Addr_OVERFLOW_CLR_FRAMENUM,Reg78,AFE_REG);             
 1706   3              }
 1707   2      
 1708   2      
 1709   2              Drv_XsiWriteReg(pXSI0Regs,Addr_MCAP_SCAN_CFG,Reg64,AFE_REG);
 1710   2              Drv_XsiWriteReg(pXSI1Regs,Addr_MCAP_SCAN_CFG,Reg64,AFE_REG); 
 1711   2      
 1712   2              DBG_FLOW("\nREG72:%04x",Reg72);
 1713   2      
 1714   2              Drv_XsiWriteReg(pXSI0Regs,Addr_OVERFLOW_THR,Reg72,AFE_REG);
 1715   2              Drv_XsiWriteReg(pXSI1Regs,Addr_OVERFLOW_THR,Reg72,AFE_REG); 
 1716   2      
 1717   2              Drv_XsiWriteReg(pXSI0Regs,Addr_UNDERFLOW_THR,Reg73,AFE_REG);
 1718   2              Drv_XsiWriteReg(pXSI1Regs,Addr_UNDERFLOW_THR,Reg73,AFE_REG);
 1719   2      
C251 COMPILER V5.54.0.0,  DrvAfePara                                                       26/05/17  20:21:06  PAGE 28  

 1720   2              Drv_XsiWriteReg(pXSI0Regs,Addr_OVERFLOW_UPBOUND,Reg74,AFE_REG);
 1721   2              Drv_XsiWriteReg(pXSI1Regs,Addr_OVERFLOW_UPBOUND,Reg74,AFE_REG);
 1722   2      
 1723   2              Drv_XsiWriteReg(pXSI0Regs,Addr_OVER_POINT_FRAME,Reg75,AFE_REG);
 1724   2              Drv_XsiWriteReg(pXSI1Regs,Addr_OVER_POINT_FRAME,Reg75,AFE_REG);         
 1725   2          }
 1726   1      
 1727   1      }
 1728          
 1729          /*******************************************************************************
 1730          *   Name: DrvMcapSetOverflowEn
 1731          *  Brief: »¥ÈÝ°´¼üÊÇ·ñ¶ÔADCÊý¾Ý½øÐÐ±¥ºÍ¼ì²â
 1732          *  Input: ucEn
 1733          * Output: 
 1734          * Return: 
 1735          *******************************************************************************/
 1736          void DrvMcapSetPara(ST_McapParameter * pMcapPara,ST_AfeTabList * pAfeTab,UINT8 ucTabId)                  
             -       //Î´Ð´È«
 1737          {
 1738   1          UINT16 XRAM ucReg;
 1739   1      
 1740   1          /*ÇÐ»»µ½TblRam*/
 1741   1          DrvAfeSelTaborRepRam(AREA_TBL_RAM);
 1742   1      
 1743   1          /*»ñÈ¡Ê¹ÓÃtab±íµÄk1,k2*/    
 1744   1          ucReg = Drv_XsiReadReg(pXSIREG,TAB_START_ADDR+TAB_RAM_LEN*ucTabId+8,AFE_REG);
 1745   1          pAfeTab ->usAnaGenCfg0 = ucReg;
 1746   1          pMcapPara->usK1= ucReg&0x07FF;
 1747   1      
 1748   1          ucReg = Drv_XsiReadReg(pXSIREG,TAB_START_ADDR+TAB_RAM_LEN*ucTabId+9,AFE_REG);
 1749   1          pAfeTab ->usAnaGenCfg1 = ucReg;    
 1750   1          pMcapPara->usK2 = ucReg&0x07FF;
 1751   1      
 1752   1          /*É¨Ãè´ÎÊý*/
 1753   1          ucReg = Drv_XsiReadReg(pXSIREG,TAB_START_ADDR+TAB_RAM_LEN*ucTabId+1,AFE_REG);
 1754   1          pAfeTab ->usScanCfg0= ucReg;
 1755   1          pMcapPara->usScanNum = (ucReg&0x07F8)>>3;
 1756   1          pMcapPara->usScanMode = ucReg&0x0007;
 1757   1      
 1758   1          /*sxÉ¨Ãè·½Ê½*/
 1759   1          ucReg = Drv_XsiReadReg(pXSIREG,TAB_START_ADDR+TAB_RAM_LEN*ucTabId+2,AFE_REG);
 1760   1          pAfeTab ->usScanCfg1 = ucReg;
 1761   1          pMcapPara->usSxMode = (ucReg&0x0100)>>8; //0:Ë«±ßÉ¨Ãè; 1:µ¥±ßÉ¨Ãè
 1762   1      
 1763   1          /*»ñÈ¡dummy_numÅäÖÃ*/
 1764   1          ucReg = Drv_XsiReadReg(pXSIREG,TAB_START_ADDR+TAB_RAM_LEN*ucTabId+3,AFE_REG);
 1765   1          pAfeTab ->usDummyScanCfg = ucReg;
 1766   1          pMcapPara->usFrmDummy = ucReg&0x001F;
 1767   1          pMcapPara->usSecDummy = (ucReg&0x03E0)>>5;    
 1768   1          pMcapPara->usMuxDummy = (ucReg&&0x7C00)>>10;
 1769   1      
 1770   1          /*°ë´øÂË²¨£¬µÍÍ¨ÂË²¨ÉèÖÃ*/
 1771   1          pMcapPara->usLpFirEn     = 1;
 1772   1          pMcapPara->usHbFirEn     = 1;
 1773   1          pMcapPara->usLpFirTap    = 14;
 1774   1          pMcapPara->usLpFirStart  = 14;
 1775   1          pMcapPara->usLpFirSumNum = 1;//16;     //Õâ¸öµÃÇë½ÌÒªÔõÃ´Åä ÁÁÆÁÏÂÒªÔõÃ´Åä,ÈôÂË²¨Æ÷È«¹ØµÄ»°,Õâ¸ö²ÎÊýÓ
             -¦¸ÃÊÇÉ¨Ãè´ÎÊý*²ÉÑù±¶Êý
 1776   1          pMcapPara->usLpFirCof0   = 0x0104;
 1777   1          pMcapPara->usLpFirCof1   = 0x0296;
 1778   1          pMcapPara->usLpFirCof2   = 0x04e5;
 1779   1          pMcapPara->usLpFirCof3   = 0x07c3;
 1780   1          pMcapPara->usLpFirCof4   = 0x0acd;
 1781   1          pMcapPara->usLpFirCof5   = 0x0d84; 
 1782   1          pMcapPara->usLpFirCof6   = 0x0f65;
 1783   1          pMcapPara->usLpFirCof7   = 0x1011;
C251 COMPILER V5.54.0.0,  DrvAfePara                                                       26/05/17  20:21:06  PAGE 29  

 1784   1          
 1785   1          /*²ÉÑùÂÊÅäÖÃ*/
 1786   1          pMcapPara->usSampl_6 = 0;         //1:±íÊ¾6±¶²ÉÑù£¬0±íÊ¾8±¶²ÉÑù
 1787   1      
 1788   1          /*²ÉÑùÆðÊ¼µãÅäÖÃ*/
 1789   1          pMcapPara->usSampl_Init = 0;//0x42;  //¶Ô²É¼¯µ½µÄADCÓ°ÏìºÜ´ó,¿ÉÒÔÍ¨¹ý¸Ä±äÕâ¸öÖµ£¬¿´ÄÄ¸öÖµ¶ÔÓ¦µÄrawdat
             -a×î´óÀ´ÅÐ¶ÏÊÇ²»ÊÇÉèÖÃÕýÈ·.
 1790   1      
 1791   1          /*Diff_maxÉèÖÃ*/
 1792   1          pMcapPara->usDiffSet = 0x2;     //2b'0x:²»¼ÆËãdiff_max;2b'10:¶ÔADCÊý¾Ý½øÐÐdiff_maxÔËËã;2b'11:¶ÔmixerÊ
             -ý¾Ý½øÐÐdiff_maxÔËËã
 1793   1      
 1794   1          /*ÔöÒæ´¦Àí×¢ÒâÊÂÏî*/
 1795   1          /*µ±¿ªÔöÒæ´¦ÀíÊ±rawdata = ((sum_data - offset) * gaincof>>shiftCof)<<1 */
 1796   1          /*µ±¹ØÔöÒæ´¦ÀíÊ±rawdata = sum_data << 1.  sum_dataÎª¼ÆËã³öÀ´µÄ½á¹û */
 1797   1          /*ÔòÈôÃ»¿ªÔöÒæ´¦ÀíÊ±,rawdata = 0x170;¿ªÁËÔöÒæ´¦ÀíÊ±,Èôshiftcof = 0,gaincof = 1,offset = 0x10,Ôòrawdat
             -aÓ¦Îª0x150×óÓÒ */
 1798   1      
 1799   1          /*ÔöÒæ´¦ÀíÉèÖÃ*/
 1800   1          pMcapPara->usGainEn = 0;         //²»¿ªÆôÔöÒæ´¦Àí
 1801   1          pMcapPara->usGainCof = 1;        //ÔöÒæÏµÊý
 1802   1          pMcapPara->usRawShiftCof = 0;
 1803   1          pMcapPara->usRawdataOffset = 0x0;
 1804   1      
 1805   1          /*ADC±¥ºÍ¼ì²âÉèÖÃ*/
 1806   1          pMcapPara->usOvfEn = 0;
 1807   1          pMcapPara->usOvfFlg = 0;
 1808   1          pMcapPara->usOvfTh  = 0xfff;//0x03e8;
 1809   1          pMcapPara->usUdwTh  = 0;
 1810   1          pMcapPara->usOvfUpBound = 0x04;//0x0A;
 1811   1          pMcapPara->usOvfPointFrm = 0x2;//0x20;
 1812   1      
 1813   1          /*ADC±¥ºÍ¼ì²âÇå³ý±êÖ¾ÉèÖÃ*/
 1814   1          pMcapPara->usOvfClrEn = 0;
 1815   1          pMcapPara->usNormalDwTh = 0x0;//0x190;
 1816   1          pMcapPara->usNormalUpTh = 0xfff;//0xfff;//0x258;
 1817   1          pMcapPara->usOvfClrFrmNum = 0x02;//0x64;
 1818   1      
 1819   1          /*½áÊø±êÖ¾³õÊ¼»¯*/
 1820   1          pMcapPara->usErrFlg = 0;
 1821   1          pMcapPara->usErrSta = 0;
 1822   1          pMcapPara->usDoneFlg = 0;
 1823   1          
 1824   1      }
 1825          
 1826          
 1827          /*******************************************************************************
 1828          *   Name: DrvMcapInit
 1829          *  Brief: »¥ÈÝ°´¼ü³õÊ¼»¯ 
 1830          *  Input: 
 1831          * Output: 
 1832          * Return: 
 1833          *******************************************************************************/
 1834          void DrvMcapModeInit(UINT8 ucModeEn,UINT8 ucTabId)
 1835          {
 1836   1          UINT8 XRAM ucScanMode;
 1837   1          UINT8 XRAM i;
 1838   1          UINT16 XRAM ucTalReg1,ucReg;
 1839   1          if(ucModeEn == 0)//¹Ø±Õ»¥ÈÝ°´¼ü
 1840   1          {
 1841   2              DrvMcapSetMode(0);
 1842   2              return;
 1843   2          }
 1844   1          else
 1845   1          {
 1846   2              /*²ÎÊýÉèÖÃ*/
C251 COMPILER V5.54.0.0,  DrvAfePara                                                       26/05/17  20:21:06  PAGE 30  

 1847   2              DrvMcapSetPara(g_pMcapPara,g_pAfeTabPara,ucTabId);
 1848   2          
 1849   2              DrvMcapSetMode(1);//¿ªÆô»¥ÈÝ°´¼ü
 1850   2          }
 1851   1      
 1852   1      #if 1    
 1853   1          /*ÉèÖÃµÍÍ¨ÂË²¨¡¢°ë´øÂË²¨*/
 1854   1          DrvMcapSetFir(g_pMcapPara);
 1855   1      
 1856   1          /*²ÉÑùÂÊÉèÖÃ*/
 1857   1          DrvMcapSetSampleRate(g_pMcapPara,g_pAfeTabPara,ucTabId);
 1858   1      
 1859   1          /*²ÉÑù³õÊ¼µãÉèÖÃ*/
 1860   1          DrvMcapSetSampleInit(g_pMcapPara);   
 1861   1      
 1862   1          /*ANAÊ±Ðò¼ì²é*/
 1863   1          ucScanMode = g_pMcapPara->usScanMode;
 1864   1          if(DrvMcapSetAnaTiming(g_pMcapPara,ucScanMode) == 1)//tx_clkÊÇ·ñÂú×ãÒªÇó
 1865   1          {
 1866   2              ucTalReg1 = (g_pAfeTabPara->usScanCfg0)&0xF807;
 1867   2              ucTalReg1 |= ((g_pMcapPara->usScanNum)<<3);
 1868   2              DBG_FLOW("\nReg1:%04x",ucTalReg1);
 1869   2              Drv_XsiWriteReg(pXSI0Regs,TAB_START_ADDR+TAB_RAM_LEN*ucTabId+1,ucTalReg1,AFE_REG);
 1870   2              Drv_XsiWriteReg(pXSI1Regs,TAB_START_ADDR+TAB_RAM_LEN*ucTabId+1,ucTalReg1,AFE_REG);        
 1871   2          }
 1872   1      
 1873   1          /*ÉèÖÃ»¥ÈÝ°´¼üÊÇ·ñ¼ÆËãdiff_max*/
 1874   1          DrvMcapSetDiffMax(g_pMcapPara);
 1875   1      
 1876   1          /*RAWDATAÔöÒæ´¦ÀíÉèÖÃ*/
 1877   1          DrvMcapSetRawGain(g_pMcapPara);
 1878   1      
 1879   1          /*ADCÊý¾Ý±¥ºÍ¼ì²âÉèÖÃ*/
 1880   1          DrvMcapSetOverflow(g_pMcapPara);
 1881   1      
 1882   1          DBG_FLOW("\nScanMode:%d",g_pMcapPara->usScanMode);
 1883   1      #endif
 1884   1      
 1885   1      #if 1
 1886   1          DBG_FLOW("\n\nAFE REG:");
 1887   1          for(i = 0x00; i < 0x58; i++)
 1888   1          {
 1889   2              ucReg = Drv_XsiReadReg(pXSI0Regs,i,AFE_REG);
 1890   2              DBG_FLOW("\nReg[%x] = %04x",i,ucReg);
 1891   2              ucReg = Drv_XsiReadReg(pXSI1Regs,i,AFE_REG);
 1892   2              DBG_FLOW("\nReg[%x] = %04x",i,ucReg);        
 1893   2          }
 1894   1      
 1895   1          DBG_FLOW("\n\nAFE TAB REG");
 1896   1          for(i = 0x00; i < 0x0A; i++)
 1897   1          {  
 1898   2              ucReg = Drv_XsiReadReg(pXSI0Regs,TAB_START_ADDR+TAB_RAM_LEN*ucTabId+i,AFE_REG);
 1899   2              DBG_FLOW("\nTabReg[%x] = %04x",i,ucReg);
 1900   2              ucReg = Drv_XsiReadReg(pXSI1Regs,TAB_START_ADDR+TAB_RAM_LEN*ucTabId+i,AFE_REG);
 1901   2              DBG_FLOW("\nTabReg[%x] = %04x",i,ucReg);        
 1902   2          }    
 1903   1      #endif    
 1904   1      }
 1905          
 1906          
 1907          /*******************************************************************************
 1908          *   Name: DrvMcapReadSta
 1909          *  Brief: ¶ÁÈ¡»¥ÈÝ°´¼üµÄ×´Ì¬ 
 1910          *  Input: 
 1911          * Output: 
 1912          * Return: 
C251 COMPILER V5.54.0.0,  DrvAfePara                                                       26/05/17  20:21:06  PAGE 31  

 1913          *******************************************************************************/
 1914          void DrvMcapReadSta(ST_McapParameter * pMcapPara)
 1915          {
 1916   1          UINT16 XRAM Reg65;
 1917   1      
 1918   1      
 1919   1          Reg65 = Drv_XsiReadReg(pXSIREG,Addr_MCAP_SCANSR,AFE_REG);
 1920   1          pMcapPara->usErrSta = (Reg65&0x01E0)>>5;
 1921   1          pMcapPara->usErrFlg = (Reg65&0x0010)>>4;
 1922   1          pMcapPara->usOvfClrFlg = (Reg65&0x0004)>>2;
 1923   1          pMcapPara->usOvfFlg = (Reg65&0x0002)>>1;
 1924   1          pMcapPara->usDoneFlg = (Reg65&0x0001);
 1925   1      
 1926   1          DBG_FLOW("\nover flag:%04x",pMcapPara->usOvfFlg);
 1927   1          //DBG_FLOW("\ndone flag:%04x",pMcapPara->usDoneFlg);           //Èí¼þÃ»·¨¶Áµ½
 1928   1          DBG_FLOW("\nover clr flag:%04x",pMcapPara->usOvfClrFlg);
 1929   1      
 1930   1          
 1931   1      }
 1932          
 1933          /*******************************************************************************
 1934          *   Name: DrvMcapReadSta
 1935          *  Brief: ½øÈë²âÊÔÄ£Ê½ 
 1936          *  Input: 
 1937          * Output: 
 1938          * Return: 
 1939          *******************************************************************************/
 1940          void DrvMcapSetTestMode(UINT8 ucMode,UINT8 ucKeyNum)
 1941          {
 1942   1          UINT16 XRAM ucReg04,ucReg51;
 1943   1          ucReg04 = Drv_XsiReadReg(pXSIREG,0x04,AFE_REG);
 1944   1      
 1945   1          ucReg04 &= 0xFFFE;     //²âÊÔÄ£Ê½
 1946   1          if(ucMode)
 1947   1          {
 1948   2              ucReg04 |=0x0001;  //ÆÕÍ¨Ä£Ê½
 1949   2          }
 1950   1          Drv_XsiWriteReg(pXSI0Regs,Addr_AFE_SYS_CFG0,ucReg04,AFE_REG);
 1951   1          Drv_XsiWriteReg(pXSI1Regs,Addr_AFE_SYS_CFG0,ucReg04,AFE_REG);
 1952   1      
 1953   1          ucReg51 = (ucKeyNum<<10) + 1;
 1954   1      
 1955   1          Drv_XsiWriteReg(pXSI0Regs,Addr_TEST_MODE_FLAG,ucReg51,AFE_REG);
 1956   1          Drv_XsiWriteReg(pXSI1Regs,Addr_TEST_MODE_FLAG,ucReg51,AFE_REG);    
 1957   1      }
 1958          
 1959          
 1960          /*******************************************************************************
 1961          *   Name:Test_CLk48M
 1962          *  Brief:
 1963          *  Input:
 1964          * Output:
 1965          * Return:
 1966          *******************************************************************************/
 1967          void Test_CLk48M(UINT8 ucDiv)
 1968          {
 1969   1          if((SYSCON&0x0C)==0x04)
 1970   1          {
 1971   2              DBG_FLOW("\nP0_6 is used to be UART TX pad!");
 1972   2              return;
 1973   2          }
 1974   1        
 1975   1        if((UART_INH == 0)&&(UART_INL == 1))
 1976   1        {
 1977   2              DBG_FLOW("\nP0_6 is used to be UART RX pad and now is changed to be CLK Test Pin!");
 1978   2          UART_INH = 0;
C251 COMPILER V5.54.0.0,  DrvAfePara                                                       26/05/17  20:21:06  PAGE 32  

 1979   2          UART_INL = 0;
 1980   2        }
 1981   1          P0MOD |= BITn(6);
 1982   1          TEST_OUT3_EN = 0;
 1983   1          GPIO_INT_SEL = 1;//½«»½ÐÑ½ÅÑ¡Îªp0_7
 1984   1          TEST_CLK_EN = 1;
 1985   1      
 1986   1          CGUCON7 = ucDiv;   //osc_test_div
 1987   1      
 1988   1          DBG_FLOW("\nP0MOD:%02x",P0MOD);
 1989   1          DBG_FLOW("\nTESTCON3:%02x",TESTCON3);
 1990   1          DBG_FLOW("\nANACON:%02x",ANACON);
 1991   1          DBG_FLOW("\nFT_EN_REG:%02x",FT_EN_REG);
 1992   1          DBG_FLOW("\nCUGCON7:%02x",CGUCON7);    
 1993   1          DBG_FLOW("\nTest Clk 48M");
 1994   1      
 1995   1      }
 1996          
 1997          /*******************************************************************************
 1998          *   Name:Test_CLk32K
 1999          *  Brief:
 2000          *  Input:
 2001          * Output:
 2002          * Return:
 2003          *******************************************************************************/
 2004          void Test_CLk32K(UINT8 ucDiv)
 2005          {
 2006   1        UINT8 ucSrc = 3;//3:32k_from_1m;2:32k_dig;1:32k osc;0:48m
 2007   1      
 2008   1      
 2009   1          if((SYSCON&0x0C)==0x04)
 2010   1          {
 2011   2              DBG_FLOW("\nP0_6 is used to be UART TX pad!");
 2012   2              return;
 2013   2          }
 2014   1      
 2015   1        if((UART_INH == 0)&&(UART_INL == 1))
 2016   1        {
 2017   2              DBG_FLOW("\nP0_6 is used to be UART RX pad and now is changed to be CLK Test Pin!");
 2018   2          UART_INH = 0;
 2019   2          UART_INL = 0;
 2020   2        } 
 2021   1        
 2022   1          P0MOD |= BITn(6);
 2023   1          TEST_OUT3_EN = 0;
 2024   1          GPIO_INT_SEL = 1;//½«»½ÐÑ½ÅÑ¡Îªp0_7
 2025   1          TEST_CLK_EN = 1;
 2026   1      
 2027   1        if(ucSrc == 1)
 2028   1        {
 2029   2          SEL_32K_SRC = 1;         //Ð´1¿ÉÒÔ·¢³ö,
 2030   2        }
 2031   1        else if(ucSrc == 2)
 2032   1        {
 2033   2          PROBE32K_DIG_EN = 1;    
 2034   2        }
 2035   1        else if(ucSrc == 3)
 2036   1        {
 2037   2          PROBE32K_FROM1M_EN = 1;
 2038   2          SEL_32K_SRC = 0;         //FPGAÐ´1»òÕßÐ´0¶¼¿ÉÒÔ·¢³ö
 2039   2        }
 2040   1        
 2041   1        CGUCON7 = (ucSrc << 6)|(ucDiv);
 2042   1      
 2043   1          DBG_FLOW("\nP0MOD:%02x",P0MOD);
 2044   1        DBG_FLOW("\nDSVCON:%02x",DSV_CON);
C251 COMPILER V5.54.0.0,  DrvAfePara                                                       26/05/17  20:21:06  PAGE 33  

 2045   1          DBG_FLOW("\nTESTCON3:%02x",TESTCON3);
 2046   1          DBG_FLOW("\nSYSCON:%02x",SYSCON);
 2047   1          DBG_FLOW("\nFT_EN_REG:%02x",FT_EN_REG);
 2048   1          DBG_FLOW("\nCUGCON7:%02x",CGUCON7);    
 2049   1          DBG_FLOW("\nTest Clk 32K");
 2050   1      
 2051   1      }
 2052          
 2053          
 2054          /*******************************************************************************
 2055          *   Name:Test_Ca_P1
 2056          *  Brief:
 2057          *  Input:
 2058          * Output:
 2059          * Return:
 2060          *******************************************************************************/
 2061          void Test_Ca_P1(UINT8 ucPin,UINT8 ucAfePin)
 2062          {
 2063   1          UINT8 XRAM ucSfrCon;
 2064   1          UINT16 XRAM ucConfig;
 2065   1          ucConfig = (0x1<<8) + 0x1;//ca_p1,afeÓëcaÐÅºÅ
 2066   1      
 2067   1          if(ucAfePin == 0)// pin0
 2068   1          {
 2069   2              Drv_XsiWriteReg(pXSI0Regs,Addr_TEST_P0_CFG0,ucConfig,AFE_REG);  //p0
 2070   2              Drv_XsiWriteReg(pXSI1Regs,Addr_TEST_P0_CFG0,ucConfig,AFE_REG);
 2071   2              ucSfrCon = 0x80;
 2072   2          }
 2073   1          else            //pin1
 2074   1          {
 2075   2              Drv_XsiWriteReg(pXSI0Regs,Addr_TEST_P1_CFG0,ucConfig,AFE_REG);  //p1
 2076   2              Drv_XsiWriteReg(pXSI1Regs,Addr_TEST_P1_CFG0,ucConfig,AFE_REG);
 2077   2              ucSfrCon = 0x81;
 2078   2          }
 2079   1          
 2080   1          if(ucPin == 0)
 2081   1          {
 2082   2              TESTCON0 = ucSfrCon;
 2083   2          }
 2084   1          else if(ucPin == 1)
 2085   1          {
 2086   2              TESTCON1 = ucSfrCon;
 2087   2          }
 2088   1          else if(ucPin == 2)
 2089   1          {
 2090   2              TESTCON2 = ucSfrCon;
 2091   2          }
 2092   1          else if(ucPin == 3)
 2093   1          {
 2094   2              TESTCON3 = ucSfrCon;
 2095   2          }
 2096   1          DBG_FLOW("CA_P1");
 2097   1      }
 2098          
 2099          
 2100          /*******************************************************************************
 2101          *   Name:Test_Ca_P4
 2102          *  Brief:
 2103          *  Input:
 2104          * Output:
 2105          * Return:
 2106          *******************************************************************************/
 2107          void Test_Ca_P4(UINT8 ucPin,UINT8 ucAfePin)
 2108          {
 2109   1          UINT8 XRAM ucSfrCon;
 2110   1          UINT16 XRAM ucConfig;
C251 COMPILER V5.54.0.0,  DrvAfePara                                                       26/05/17  20:21:06  PAGE 34  

 2111   1          ucConfig = (0x2<<8) + 0x1;//ca_p4,afeÓëcaÐÅºÅ
 2112   1      
 2113   1          if(ucAfePin == 0)// pin0
 2114   1          {
 2115   2              Drv_XsiWriteReg(pXSI0Regs,Addr_TEST_P0_CFG0,ucConfig,AFE_REG);  //p0
 2116   2              Drv_XsiWriteReg(pXSI1Regs,Addr_TEST_P0_CFG0,ucConfig,AFE_REG);
 2117   2              ucSfrCon = 0x80;
 2118   2          }
 2119   1          else            //pin1
 2120   1          {
 2121   2              Drv_XsiWriteReg(pXSI0Regs,Addr_TEST_P1_CFG0,ucConfig,AFE_REG);  //p1
 2122   2              Drv_XsiWriteReg(pXSI1Regs,Addr_TEST_P1_CFG0,ucConfig,AFE_REG);
 2123   2              ucSfrCon = 0x81;
 2124   2          }
 2125   1          if(ucPin == 0)
 2126   1          {
 2127   2              TESTCON0 = ucSfrCon;
 2128   2          }
 2129   1          else if(ucPin == 1)
 2130   1          {
 2131   2              TESTCON1 = ucSfrCon;
 2132   2          }
 2133   1          else if(ucPin == 2)
 2134   1          {
 2135   2              TESTCON2 = ucSfrCon;
 2136   2          }
 2137   1          else if(ucPin == 3)
 2138   1          {
 2139   2              TESTCON3 = ucSfrCon;
 2140   2          } 
 2141   1          DBG_FLOW("CA_P4");    
 2142   1      }
 2143          
 2144          /*******************************************************************************
 2145          *   Name:Test_Ca_Rst
 2146          *  Brief:
 2147          *  Input:
 2148          * Output:
 2149          * Return:
 2150          *******************************************************************************/
 2151          void Test_Ca_Rst(UINT8 ucPin,UINT8 ucAfePin)
 2152          {
 2153   1          UINT8 XRAM ucSfrCon;
 2154   1          UINT16 XRAM ucConfig;
 2155   1          ucConfig = (0x0<<8) + 0x1;//ca_rst,afeÓëcaÐÅºÅ
 2156   1      
 2157   1          if(ucAfePin == 0)// pin0
 2158   1          {
 2159   2              Drv_XsiWriteReg(pXSI0Regs,Addr_TEST_P0_CFG0,ucConfig,AFE_REG);  //p0
 2160   2              Drv_XsiWriteReg(pXSI1Regs,Addr_TEST_P0_CFG0,ucConfig,AFE_REG);
 2161   2              ucSfrCon = 0x80;
 2162   2          }
 2163   1          else            //pin1
 2164   1          {
 2165   2              Drv_XsiWriteReg(pXSI0Regs,Addr_TEST_P1_CFG0,ucConfig,AFE_REG);  //p1
 2166   2              Drv_XsiWriteReg(pXSI1Regs,Addr_TEST_P1_CFG0,ucConfig,AFE_REG);
 2167   2              ucSfrCon = 0x81;
 2168   2          }
 2169   1          if(ucPin == 0)
 2170   1          {
 2171   2              TESTCON0 = ucSfrCon;
 2172   2          }
 2173   1          else if(ucPin == 1)
 2174   1          {
 2175   2              TESTCON1 = ucSfrCon;
 2176   2          }
C251 COMPILER V5.54.0.0,  DrvAfePara                                                       26/05/17  20:21:06  PAGE 35  

 2177   1          else if(ucPin == 2)
 2178   1          {
 2179   2              TESTCON2 = ucSfrCon;
 2180   2          }
 2181   1          else if(ucPin == 3)
 2182   1          {
 2183   2              TESTCON3 = ucSfrCon;
 2184   2          }
 2185   1          DBG_FLOW("CA_RST");    
 2186   1      }
 2187          
 2188          /*******************************************************************************
 2189          *   Name:Test_Lcd_Run
 2190          *  Brief:
 2191          *  Input:
 2192          * Output:
 2193          * Return:
 2194          *******************************************************************************/
 2195          void Test_Lcd_Run(UINT8 ucPin,UINT8 ucAfePin)
 2196          {
 2197   1          UINT8 XRAM ucSfrCon;
 2198   1          UINT16 XRAM ucConfig;
 2199   1          ucConfig = (0x1<<4) + 0x0;//lcd_run,afeÓësocÐÅºÅ
 2200   1      
 2201   1          if(ucAfePin == 0)// pin0
 2202   1          {
 2203   2              Drv_XsiWriteReg(pXSI0Regs,Addr_TEST_P0_CFG0,ucConfig,AFE_REG);  //p0
 2204   2              Drv_XsiWriteReg(pXSI1Regs,Addr_TEST_P0_CFG0,ucConfig,AFE_REG);
 2205   2              ucSfrCon = 0x80;
 2206   2          }
 2207   1          else            //pin1
 2208   1          {
 2209   2              Drv_XsiWriteReg(pXSI0Regs,Addr_TEST_P1_CFG0,ucConfig,AFE_REG);  //p1
 2210   2              Drv_XsiWriteReg(pXSI1Regs,Addr_TEST_P1_CFG0,ucConfig,AFE_REG);
 2211   2              ucSfrCon = 0x81;
 2212   2          }
 2213   1          if(ucPin == 0)
 2214   1          {
 2215   2              TESTCON0 = ucSfrCon;
 2216   2          }
 2217   1          else if(ucPin == 1)
 2218   1          {
 2219   2              TESTCON1 = ucSfrCon;
 2220   2          }
 2221   1          else if(ucPin == 2)
 2222   1          {
 2223   2              TESTCON2 = ucSfrCon;
 2224   2          }
 2225   1          else if(ucPin == 3)
 2226   1          {
 2227   2              TESTCON3 = ucSfrCon;
 2228   2          }
 2229   1          DBG_FLOW("LCD_RUN");    
 2230   1      }
 2231          
 2232          /*******************************************************************************
 2233          *   Name:Test_Lcd_Busy
 2234          *  Brief:
 2235          *  Input:
 2236          * Output:
 2237          * Return:
 2238          *******************************************************************************/
 2239          void Test_Lcd_Busy(UINT8 ucPin,UINT8 ucAfePin)
 2240          {
 2241   1          UINT8 XRAM ucSfrCon;
 2242   1          UINT16 XRAM ucConfig;
C251 COMPILER V5.54.0.0,  DrvAfePara                                                       26/05/17  20:21:06  PAGE 36  

 2243   1          ucConfig = (0x2<<4) + 0x0;//lcd_Busy,afeÓësocÐÅºÅ
 2244   1      
 2245   1          if(ucAfePin == 0)// pin0
 2246   1          {
 2247   2              Drv_XsiWriteReg(pXSI0Regs,Addr_TEST_P0_CFG0,ucConfig,AFE_REG);  //p0
 2248   2              Drv_XsiWriteReg(pXSI1Regs,Addr_TEST_P0_CFG0,ucConfig,AFE_REG);
 2249   2              ucSfrCon = 0x80;
 2250   2          }
 2251   1          else            //pin1
 2252   1          {
 2253   2              Drv_XsiWriteReg(pXSI0Regs,Addr_TEST_P1_CFG0,ucConfig,AFE_REG);  //p1
 2254   2              Drv_XsiWriteReg(pXSI1Regs,Addr_TEST_P1_CFG0,ucConfig,AFE_REG);
 2255   2              ucSfrCon = 0x81;
 2256   2          }
 2257   1          if(ucPin == 0)
 2258   1          {
 2259   2              TESTCON0 = ucSfrCon;
 2260   2          }
 2261   1          else if(ucPin == 1)
 2262   1          {
 2263   2              TESTCON1 = ucSfrCon;
 2264   2          }
 2265   1          else if(ucPin == 2)
 2266   1          {
 2267   2              TESTCON2 = ucSfrCon;
 2268   2          }
 2269   1          else if(ucPin == 3)
 2270   1          {
 2271   2              TESTCON3 = ucSfrCon;
 2272   2          }
 2273   1          DBG_FLOW("LCD_BUSY");
 2274   1        DBG_FLOW("\nReg[%x]:%04x",Addr_TEST_P1_CFG0,Drv_XsiReadReg(pXSI0Regs,Addr_TEST_P1_CFG0,AFE_REG));
 2275   1      }
 2276          
 2277          /*******************************************************************************
 2278          *   Name:Test_Tp_Scan
 2279          *  Brief:
 2280          *  Input:
 2281          * Output:
 2282          * Return:
 2283          *******************************************************************************/
 2284          void Test_Tp_Scan(UINT8 ucPin,UINT8 ucAfePin)
 2285          {
 2286   1          UINT8 XRAM ucSfrCon;
 2287   1          UINT16 XRAM ucConfig;
 2288   1          ucConfig = (0x5<<4) + 0x0;//Tp_Scan,afeÓësocÐÅºÅ
 2289   1      
 2290   1          if(ucAfePin == 0)// pin0
 2291   1          {
 2292   2              Drv_XsiWriteReg(pXSI0Regs,Addr_TEST_P0_CFG0,ucConfig,AFE_REG);  //p0
 2293   2              Drv_XsiWriteReg(pXSI1Regs,Addr_TEST_P0_CFG0,ucConfig,AFE_REG);
 2294   2              ucSfrCon = 0x80;
 2295   2          }
 2296   1          else            //pin1
 2297   1          {
 2298   2              Drv_XsiWriteReg(pXSI0Regs,Addr_TEST_P1_CFG0,ucConfig,AFE_REG);  //p1
 2299   2              Drv_XsiWriteReg(pXSI1Regs,Addr_TEST_P1_CFG0,ucConfig,AFE_REG);
 2300   2              ucSfrCon = 0x81;
 2301   2          }
 2302   1          if(ucPin == 0)
 2303   1          {
 2304   2              TESTCON0 = ucSfrCon;
 2305   2          }
 2306   1          else if(ucPin == 1)
 2307   1          {
 2308   2              TESTCON1 = ucSfrCon;
C251 COMPILER V5.54.0.0,  DrvAfePara                                                       26/05/17  20:21:06  PAGE 37  

 2309   2          }
 2310   1          else if(ucPin == 2)
 2311   1          {
 2312   2              TESTCON2 = ucSfrCon;
 2313   2          }
 2314   1          else if(ucPin == 3)
 2315   1          {
 2316   2              TESTCON3 = ucSfrCon;
 2317   2          }
 2318   1          DBG_FLOW("TP_SCAN");    
 2319   1      }
 2320          
 2321          /*******************************************************************************
 2322          *   Name:Test_Tp_Busy
 2323          *  Brief:
 2324          *  Input:
 2325          * Output:
 2326          * Return:
 2327          *******************************************************************************/
 2328          void Test_Tp_Busy(UINT8 ucPin,UINT8 ucAfePin)
 2329          {
 2330   1          UINT8 XRAM ucSfrCon;
 2331   1          UINT16 XRAM ucConfig;
 2332   1          ucConfig = (0x6<<4) + 0x0;//Tp_Busy,afeÓësocÐÅºÅ
 2333   1      
 2334   1          if(ucAfePin == 0)// pin0
 2335   1          {
 2336   2              Drv_XsiWriteReg(pXSI0Regs,Addr_TEST_P0_CFG0,ucConfig,AFE_REG);  //p0
 2337   2              Drv_XsiWriteReg(pXSI1Regs,Addr_TEST_P0_CFG0,ucConfig,AFE_REG);
 2338   2              ucSfrCon = 0x80;
 2339   2          }
 2340   1          else            //pin1
 2341   1          {
 2342   2              Drv_XsiWriteReg(pXSI0Regs,Addr_TEST_P1_CFG0,ucConfig,AFE_REG);  //p1
 2343   2              Drv_XsiWriteReg(pXSI1Regs,Addr_TEST_P1_CFG0,ucConfig,AFE_REG);
 2344   2              ucSfrCon = 0x81;
 2345   2          }
 2346   1          if(ucPin == 0)
 2347   1          {
 2348   2              TESTCON0 = ucSfrCon;
 2349   2          }
 2350   1          else if(ucPin == 1)
 2351   1          {
 2352   2              TESTCON1 = ucSfrCon;
 2353   2          }
 2354   1          else if(ucPin == 2)
 2355   1          {
 2356   2              TESTCON2 = ucSfrCon;
 2357   2          }
 2358   1          else if(ucPin == 3)
 2359   1          {
 2360   2              TESTCON3 = ucSfrCon;
 2361   2          }
 2362   1          DBG_FLOW("TP_BUSY");     
 2363   1      }
 2364          
 2365          /*******************************************************************************
 2366          *   Name:Test_Tx_Clk
 2367          *  Brief:
 2368          *  Input:
 2369          * Output:
 2370          * Return:
 2371          *******************************************************************************/
 2372          void Test_Tx_Clk(UINT8 ucPin,UINT8 ucAfePin)
 2373          {
 2374   1          UINT8 XRAM ucSfrCon;
C251 COMPILER V5.54.0.0,  DrvAfePara                                                       26/05/17  20:21:06  PAGE 38  

 2375   1          UINT16 XRAM ucConfig0;
 2376   1          UINT16 XRAM ucConfig1;
 2377   1          ucConfig0 = 0x4;      //afeÓëmcapÐÅºÅ
 2378   1          ucConfig1 = (0x5<<4); //tx_clk
 2379   1          if(ucAfePin == 0)// pin0
 2380   1          {
 2381   2              Drv_XsiWriteReg(pXSI0Regs,Addr_TEST_P0_CFG0,ucConfig0,AFE_REG);  //p0
 2382   2              Drv_XsiWriteReg(pXSI1Regs,Addr_TEST_P0_CFG0,ucConfig0,AFE_REG);
 2383   2              Drv_XsiWriteReg(pXSI0Regs,Addr_TEST_P0_CFG1,ucConfig1,AFE_REG);  //p0
 2384   2              Drv_XsiWriteReg(pXSI1Regs,Addr_TEST_P0_CFG1,ucConfig1,AFE_REG);        
 2385   2              ucSfrCon = 0x80;
 2386   2          }
 2387   1          else            //pin1
 2388   1          {
 2389   2              Drv_XsiWriteReg(pXSI0Regs,Addr_TEST_P1_CFG0,ucConfig0,AFE_REG);  //p1
 2390   2              Drv_XsiWriteReg(pXSI1Regs,Addr_TEST_P1_CFG0,ucConfig0,AFE_REG);
 2391   2              Drv_XsiWriteReg(pXSI0Regs,Addr_TEST_P1_CFG1,ucConfig1,AFE_REG);  //p0
 2392   2              Drv_XsiWriteReg(pXSI1Regs,Addr_TEST_P1_CFG1,ucConfig1,AFE_REG);  
 2393   2              ucSfrCon = 0x81;
 2394   2          }
 2395   1          if(ucPin == 0)
 2396   1          {
 2397   2              TESTCON0 = ucSfrCon;
 2398   2          }
 2399   1          else if(ucPin == 1)
 2400   1          {
 2401   2              TESTCON1 = ucSfrCon;
 2402   2          }
 2403   1          else if(ucPin == 2)
 2404   1          {
 2405   2              TESTCON2 = ucSfrCon;
 2406   2          }
 2407   1          else if(ucPin == 3)
 2408   1          {
 2409   2              TESTCON3 = ucSfrCon;
 2410   2          }
 2411   1          DBG_FLOW("Tx_Clk"); 
 2412   1      }
 2413          
 2414          
 2415          /*******************************************************************************
 2416          *   Name:Test_MCAP_DONE
 2417          *  Brief:
 2418          *  Input:
 2419          * Output:
 2420          * Return:
 2421          *******************************************************************************/
 2422          void Test_MCAP_DONE(UINT8 ucPin,UINT8 ucAfePin)
 2423          {
 2424   1          UINT8 XRAM ucSfrCon;
 2425   1          UINT16 XRAM ucConfig0;
 2426   1          UINT16 XRAM ucConfig1;
 2427   1          ucConfig0 = 0xA;      //afeÓëmcapÐÅºÅ
 2428   1          //ucConfig1 = (0x1<<12); //macp_done
 2429   1          //ucConfig1 = (0x3<<12); //MIXER_VLD
 2430   1          ucConfig1 = (0x1<<12); //MIXER_VLD    
 2431   1          if(ucAfePin == 0)// pin0
 2432   1          {
 2433   2              Drv_XsiWriteReg(pXSI0Regs,Addr_TEST_P0_CFG0,ucConfig0,AFE_REG);  //p0
 2434   2              Drv_XsiWriteReg(pXSI1Regs,Addr_TEST_P0_CFG0,ucConfig0,AFE_REG);
 2435   2              Drv_XsiWriteReg(pXSI0Regs,Addr_TEST_P0_CFG2,ucConfig1,AFE_REG);  //p0
 2436   2              Drv_XsiWriteReg(pXSI1Regs,Addr_TEST_P0_CFG2,ucConfig1,AFE_REG);        
 2437   2              ucSfrCon = 0x80;
 2438   2          }
 2439   1          else            //pin1
 2440   1          {
C251 COMPILER V5.54.0.0,  DrvAfePara                                                       26/05/17  20:21:06  PAGE 39  

 2441   2              Drv_XsiWriteReg(pXSI0Regs,Addr_TEST_P1_CFG0,ucConfig0,AFE_REG);  //p1
 2442   2              Drv_XsiWriteReg(pXSI1Regs,Addr_TEST_P1_CFG0,ucConfig0,AFE_REG);
 2443   2              Drv_XsiWriteReg(pXSI0Regs,Addr_TEST_P1_CFG2,ucConfig1,AFE_REG);  //p0
 2444   2              Drv_XsiWriteReg(pXSI1Regs,Addr_TEST_P1_CFG2,ucConfig1,AFE_REG);  
 2445   2              ucSfrCon = 0x81;
 2446   2          }
 2447   1          if(ucPin == 0)
 2448   1          {
 2449   2              TESTCON0 = ucSfrCon;
 2450   2          }
 2451   1          else if(ucPin == 1)
 2452   1          {
 2453   2              TESTCON1 = ucSfrCon;
 2454   2          }
 2455   1          else if(ucPin == 2)
 2456   1          {
 2457   2              TESTCON2 = ucSfrCon;
 2458   2          }
 2459   1          else if(ucPin == 3)
 2460   1          {
 2461   2              TESTCON3 = ucSfrCon;
 2462   2          }
 2463   1          DBG_FLOW("mcap_done"); 
 2464   1      }
 2465          
 2466          
 2467          /*******************************************************************************
 2468          *   Name:Test_MCAP_ADC_DATA_VLD
 2469          *  Brief:
 2470          *  Input:
 2471          * Output:
 2472          * Return:
 2473          *******************************************************************************/
 2474          void Test_MCAP_ADC_DATA_VLD(UINT8 ucPin,UINT8 ucAfePin)
 2475          {
 2476   1          UINT8 XRAM ucSfrCon;
 2477   1          UINT16 XRAM ucConfig0;
 2478   1          UINT16 XRAM ucConfig1;
 2479   1          ucConfig0 = 0xA;      //afeÓëmcapÐÅºÅ
 2480   1          //ucConfig1 = (0x2<<12); //macp_done
 2481   1          ucConfig1 = (0x6<<12); //macp_done    
 2482   1          if(ucAfePin == 0)// pin0
 2483   1          {
 2484   2              Drv_XsiWriteReg(pXSI0Regs,Addr_TEST_P0_CFG0,ucConfig0,AFE_REG);  //p0
 2485   2              Drv_XsiWriteReg(pXSI1Regs,Addr_TEST_P0_CFG0,ucConfig0,AFE_REG);
 2486   2              Drv_XsiWriteReg(pXSI0Regs,Addr_TEST_P0_CFG2,ucConfig1,AFE_REG);  //p0
 2487   2              Drv_XsiWriteReg(pXSI1Regs,Addr_TEST_P0_CFG2,ucConfig1,AFE_REG);        
 2488   2              ucSfrCon = 0x80;
 2489   2          }
 2490   1          else            //pin1
 2491   1          {
 2492   2              Drv_XsiWriteReg(pXSI0Regs,Addr_TEST_P1_CFG0,ucConfig0,AFE_REG);  //p1
 2493   2              Drv_XsiWriteReg(pXSI1Regs,Addr_TEST_P1_CFG0,ucConfig0,AFE_REG);
 2494   2              Drv_XsiWriteReg(pXSI0Regs,Addr_TEST_P1_CFG2,ucConfig1,AFE_REG);  //p0
 2495   2              Drv_XsiWriteReg(pXSI1Regs,Addr_TEST_P1_CFG2,ucConfig1,AFE_REG);  
 2496   2              ucSfrCon = 0x81;
 2497   2          }
 2498   1          if(ucPin == 0)
 2499   1          {
 2500   2              TESTCON0 = ucSfrCon;
 2501   2          }
 2502   1          else if(ucPin == 1)
 2503   1          {
 2504   2              TESTCON1 = ucSfrCon;
 2505   2          }
 2506   1          else if(ucPin == 2)
C251 COMPILER V5.54.0.0,  DrvAfePara                                                       26/05/17  20:21:06  PAGE 40  

 2507   1          {
 2508   2              TESTCON2 = ucSfrCon;
 2509   2          }
 2510   1          else if(ucPin == 3)
 2511   1          {
 2512   2              TESTCON3 = ucSfrCon;
 2513   2          }
 2514   1          DBG_FLOW("mcap_done"); 
 2515   1      }
 2516          
 2517          
 2518          /*******************************************************************************
 2519          *   Name:Test_Debug0
 2520          *  Brief:
 2521          *  Input:
 2522          * Output:
 2523          * Return:
 2524          *******************************************************************************/
 2525          void Test_Debug0(void)
 2526          {
 2527   1          TEST_OUT0_EN = 1;
 2528   1      
 2529   1          DBG_FLOW("\nTest_Debug0:");
 2530   1      
 2531   1          //ÏÂÃæÖ»ÄÜÑ¡Ôñ´ò¿ªÒ»¸öº¯Êý
 2532   1          //Test_Ca_P1(2,0);
 2533   1          //Test_Ca_P4(2,0);
 2534   1          //Test_Ca_Rst(2,0);
 2535   1          Test_Lcd_Run(2,0);
 2536   1          //Test_Lcd_Busy(2,0);
 2537   1          //Test_Tp_Scan(2,0);
 2538   1          //Test_Tp_Busy(2,0);
 2539   1          //Test_Tx_Clk(2,0);
 2540   1          //Test_MCAP_DONE(2,0);
 2541   1          //Test_MCAP_ADC_DATA_VLD(2,0);  
 2542   1      }
 2543          
 2544          
 2545          /*******************************************************************************
 2546          *   Name:Test_Debug3
 2547          *  Brief:
 2548          *  Input:
 2549          * Output:
 2550          * Return:
 2551          *******************************************************************************/
 2552          void Test_Debug1(void)
 2553          {
 2554   1          TEST_OUT1_EN = 1;
 2555   1          
 2556   1          DBG_FLOW("\nTest_Debug1:");
 2557   1      
 2558   1          //ÏÂÃæÖ»ÄÜÑ¡Ôñ´ò¿ªÒ»¸öº¯Êý
 2559   1          Test_Ca_P1(3,1);
 2560   1          //Test_Ca_P4(3,1);
 2561   1          //Test_Ca_Rst(3,1);
 2562   1          //Test_Lcd_Run(3,1);
 2563   1          //Test_Lcd_Busy(3,1);
 2564   1          //Test_Tp_Scan(3,1);
 2565   1          //Test_Tp_Busy(3,1);
 2566   1          Test_Tx_Clk(3,1);
 2567   1      }
 2568          
 2569          
 2570          
 2571          
 2572          /*******************************************************************************
C251 COMPILER V5.54.0.0,  DrvAfePara                                                       26/05/17  20:21:06  PAGE 41  

 2573          *   Name:Test_Debug2
 2574          *  Brief:
 2575          *  Input:
 2576          * Output:
 2577          * Return:
 2578          *******************************************************************************/
 2579          void Test_Debug2(void)
 2580          {
 2581   1          if(BUS_SEL == 1)//spi0
 2582   1          {
 2583   2              P0MOD |= BITn(0);//p0_0;
 2584   2          }
 2585   1          else
 2586   1          {
 2587   2              P0MOD |= BITn(2);//P0_2;
 2588   2          }
 2589   1      
 2590   1          TEST_OUT2_EN = 1;
 2591   1      
 2592   1          DBG_FLOW("\nTest_Debug2:");
 2593   1      
 2594   1          //ÏÂÃæÖ»ÄÜÑ¡Ôñ´ò¿ªÒ»¸öº¯Êý
 2595   1          Test_Ca_P1(2,0);
 2596   1          //Test_Ca_P4(2,0);
 2597   1          //Test_Ca_Rst(2,0);
 2598   1          //Test_Lcd_Run(2,0);
 2599   1          //Test_Lcd_Busy(2,0);
 2600   1          //Test_Tp_Scan(2,0);
 2601   1          //Test_Tp_Busy(2,0);
 2602   1          //Test_Tx_Clk(2,0);
 2603   1      }
 2604          
 2605          
 2606          /*******************************************************************************
 2607          *   Name:Test_Debug3
 2608          *  Brief:
 2609          *  Input:
 2610          * Output:
 2611          * Return:
 2612          *******************************************************************************/
 2613          void Test_Debug3(void)
 2614          {
 2615   1          P0MOD |= BITn(6);
 2616   1      
 2617   1          TEST_OUT3_EN = 1;
 2618   1          
 2619   1          DBG_FLOW("\nTest_Debug3:");
 2620   1      
 2621   1          //ÏÂÃæÖ»ÄÜÑ¡Ôñ´ò¿ªÒ»¸öº¯Êý
 2622   1          //Test_Ca_P1(3,1);
 2623   1          //Test_Ca_P4(3,1);
 2624   1          //Test_Ca_Rst(3,1);
 2625   1          //Test_Lcd_Run(3,1);
 2626   1          Test_Lcd_Busy(3,1);
 2627   1          //Test_Tp_Scan(3,1);
 2628   1          //Test_Tp_Busy(3,1);
 2629   1          //Test_Tx_Clk(3,1);
 2630   1          //Test_MCAP_DONE(3,1);    
 2631   1          //Test_MCAP_ADC_DATA_VLD(3,1);    
 2632   1      }
 2633          
 2634          
 2635          
 2636          
 2637          /*******************************************************************************
 2638          *   Name: Test_DebugOut
C251 COMPILER V5.54.0.0,  DrvAfePara                                                       26/05/17  20:21:06  PAGE 42  

 2639          *  Brief:
 2640          *  Input:
 2641          * Output:
 2642          * Return:
 2643          *******************************************************************************/
 2644          void Test_DebugOut(void)
 2645          {
 2646   1          //²âÊÔ48M/32K/Test_Debug3Ö»ÄÜÍ¬Ê±¿ªÒ»¸ö,¹²ÓÃp0_6
 2647   1      
 2648   1              
 2649   1          //Test_CLk32K(0);  //´Óp0_6³öÐÅºÅ 
 2650   1          //Test_CLk48M(0);  //´ÓP0_6³öÐÅºÅ
 2651   1      
 2652   1        //Ä¿Ç°´úÂëÀïÃæpin0ÅäÖÃÔÚdebug0Óëdebug2,Á½×éÖ»ÄÜ¿ª1¸ö;pin1ÅäÖÃÔÚdebug1Óëdebug3,Á½ÕßÒ²Ö»ÄÜ¿ª1¸ö.
 2653   1          Test_Debug0();     //´Ótp2pad_dsv_en6³öÐÅºÅ
 2654   1        //Test_Debug1();     //´Óled_pwm[0]³öÐÅºÅ
 2655   1          //Test_Debug2();     //µ±ÓÃSPI0Ê±,´ÓP0_0³öÐÅºÅ,µ±ÓÃIICÊ±£¬´Óp0_2³öÐÅºÅ
 2656   1          Test_Debug3();     //´Óp0_6³öÐÅºÅ
 2657   1          
 2658   1      }
 2659          
 2660          
 2661          #if 0 // Èí¼þCBÐ£Õý
               /*******************************************************************************
               *   Name: DrvPara_WriteCB
               *  Brief:
               *         1.¸üÐÂCBµ½¼Ä´æÆ÷±íÖÐ
               *  Input: None
               * Output: None
               * Return: None
               *******************************************************************************/
               void DrvPara_WriteCB(UINT8 Tbl_ID)
               {
                   UINT8 i;
                   UINT8 ucOrder;
                   UINT8 ucLenS0;  /* S0°ëÆÁ ÓÐÐ§Í¨µÀÊý */
                   UINT8 ucLenS1;  /* S1°ëÆÁ ÓÐÐ§Í¨µÀÊý */
               
                   UINT8 ucTbl;   /* ¸ÃÄ£Ê½¶ÔÓ¦µÄ±íºÅ */
               
                   UINT16 XRAM usTblBaseAddr;
                   UINT16 XRAM usAddr;
                   UINT16 XRAM ausCbValue[(CH_LEN_MAX+1)>>1];
                   UINT8 XRAM aucCbRegL[CH_LEN_MAX+1];
                   UINT8 XRAM aucCbRegR[CH_LEN_MAX+1];
               
                       ucTbl = Tbl_ID;
                       usTblBaseAddr = ID_TBL1_BASE + ucTbl*TBL_LEN_MAX + 22;
               
                       /* ½«µØÖ·ÇÐ»»µ½ TblÇø */
                       DrvAfeSelTaborRepRam(AREA_TBL_RAM);
                       
                       ucLenS0 = 224;
                       ucLenS1 = 224;
               
                       /* ×óAFE */
                       for (i = 0; i < ucLenS0; i++)
                       {
                           ucOrder = g_ucOrderBuf[i];
                           aucCbRegL[ucOrder+1] = 1 | (ucCbValue[i]<<1);
                       }
               
                       /* ÓÒAFE */
                       for (i = 0; i < ucLenS1; i++)
                       {
                           usAddr = ucLenS0 + i;
C251 COMPILER V5.54.0.0,  DrvAfePara                                                       26/05/17  20:21:06  PAGE 43  

                           ucOrder = g_ucOrderBuf[usAddr];
                           aucCbRegR[ucOrder+1] = 1 | (ucCbValue[usAddr] << 1);
                       }
                 
                       /* ×ó key */
                       usAddr = ucLenS0 + ucLenS1;
                       /*tbl Ram CB0µÄ¸ß°ËÎ»´æ·ÅKey0-2µÄ¸ß2Î»*/
               
                       /* Key1ÓÐÐ§Ê±£¬¸³Öµ */
                       if (1)
                       {
                           aucCbRegL[0] = 1 | ((ucCbValue[usAddr]&0x3F) << 1);
                           aucCbRegL[1] = (aucCbRegL[1]&0xFC)
                                                   + ((ucCbValue[usAddr]&0xC0) >> 6);
                       }
                       usAddr++;
                       /* Key2ÓÐÐ§Ê±£¬¸³Öµ */
                       if (1)
                       {
                           aucCbRegL[2] = 1 | ((ucCbValue[usAddr]&0x3F) << 1);
                           aucCbRegL[1] = (aucCbRegL[1]&0xF3)
                                                   + ((ucCbValue[usAddr]&0xC0) >> 4);
                       }
                       usAddr++;
               
                       /* Key3ÓÐÐ§Ê±£¬¸³Öµ */
                       if (1)
                       {
                           aucCbRegL[3] = 1 | ((ucCbValue[usAddr]&0x3F) << 1);
                           aucCbRegL[1] = (aucCbRegL[1]&0xCF)
                                                   + ((ucCbValue[usAddr]&0xC0) >> 2);
                       }
                       usAddr++;
                       /*  */
               
                       /* ÓÒKey4ÓÐÐ§Ê±£¬¸³Öµ */
                       if (1)
                       {
                           aucCbRegR[0] = 1 | ((ucCbValue[usAddr]&0x3F) << 1);
                           aucCbRegR[1] = (aucCbRegR[1]&0xFC)
                                                   + ((ucCbValue[usAddr]&0xC0) >> 6);
                       }
                       usAddr++;
               
                       /* ÓÒKey5ÓÐÐ§Ê±£¬¸³Öµ */
                       if (1)
                       {
                           aucCbRegR[2] = 1 | ((ucCbValue[usAddr]&0x3F) << 1);
                           aucCbRegR[1] = (aucCbRegR[1]&0xF3)
                                                   + ((ucCbValue[usAddr]&0xC0) >> 4);
                       }
                       usAddr++;
                       /* ÓÒKey6ÓÐÐ§Ê±£¬¸³Öµ */
                       if (1)
                       {
                           aucCbRegR[3] = 1 | ((ucCbValue[usAddr]&0x3F) << 1);
                           aucCbRegR[1] = (aucCbRegR[1]&0xCF)
                                                   + ((ucCbValue[usAddr]&0xC0) >> 2);
                       }
                       usAddr++;
               
               
                       for (i = 0; i<CH_LEN_MAX; i+=2)
                       {
                           ausCbValue[i>>1] = ((UINT16)aucCbRegL[i+1]<<8) + aucCbRegL[i];
                       }
C251 COMPILER V5.54.0.0,  DrvAfePara                                                       26/05/17  20:21:06  PAGE 44  

               #if 0
                   DBG_FLOW("\n write CB Tab_L %d\n",ucTbl);
                   for (i = 0;i < 10 ;i++)
                   {
                       DBG_FLOW("%04x  ",ausCbValue[i]);
                   }
               #endif
                       DrvXsi0_WriteN(usTblBaseAddr, ausCbValue, (CH_LEN_MAX+1)>>1);
               
                       for (i = 0; i<CH_LEN_MAX; i+=2)
                       {
                          ausCbValue[i>>1] = ((UINT16)aucCbRegR[i+1]<<8) + aucCbRegR[i];
                       }
               #if 0
                   DBG_FLOW("\n write CB Tab_R %d\n",ucTbl);
                   for (i = 0;i < 10 ;i++)
                   {
                       DBG_FLOW("%04x  ",ausCbValue[i]);
                   }
               #endif
                       DrvXsi1_WriteN(usTblBaseAddr, ausCbValue, (CH_LEN_MAX+1)>>1);
               }
               
               /*******************************************************************************
               *   Name: DrvClbCB
               *  Brief:
               *         1.CB×Ô¶¯Ð£Õý,CFÐ£ÕýÊ±£¬ÅäÖÃ³É×î´ó
               *         2.CB´Ó00-->0x7F,  ¸ßÎ»-->µÍÎ»£¬ÖðÎ»±Æ½ü
               *  Input: None
               * Output: None
               * Return: None
               *******************************************************************************/
               void DrvClbCB(UINT8 ucTabID)
               {
                   SINT8 scCnt;                // Ð£×¼´ÎÊý¼ÆÊýÆ÷
                   UINT8 ucDataMask;           // ÁÙÊ±ÉèÖÃµÄCBÖµ
                   UINT8 ucKeyMask;            // ÁÙÊ±ÉèÖÃµÄKey CBÖµ:Èí¼þÐ£×¼µÍÁ½Î»²»Ð£
                   UINT16 i;
                   UINT16 usChNum;             // ÐèÒªÐ£×¼µÄËùÓÐÍ¨µÀ×ÜÊý
                   UINT16 usChVaNum;           // ÐèÒªÐ£×¼µÄvaÍ¨µÀ×ÜÊý
                   UINT16 usRawTargeNormal;    // Õý³£Ä£Ê½ Ð£×¼Ä¿±êÖµ
               
               
                   /* +6¸ö°´¼üÍ¨µÀ */
                   usChVaNum = CH_LEN;  /* ÓÐÐ§Í¨µÀ×Ü³¤¶È, ²»º¬°´¼ü */
                   usChNum = usChVaNum + KEY_NUM_MAX;
                   /* ÇåÁãËùÓÐÍ¨µÀCBÖµ */
                   memset(ucCbValue, 0x00, usChNum);
                  
                   // RAWDATAÄ¿±êÖµÉèÖÃ£¬OutPutRaw = (1CycleRaw * CycleSum)>>AccShift
                   usRawTargeNormal = 8192;
               
                   /* Á¬Ðø½øÐÐ7´ÎÍêÕûÉ¨Ãè£¬Öð´Î±Æ½ü·½Ê½Ð£×¼CBÖµ */
                   for (scCnt = (SC_CLB_TIMES - 1); scCnt >= 0; scCnt--)
                   {
                       /* Ô¤ÉèCBÖµ */
                       if (scCnt > 1)
                       {
                           ucDataMask = (0x01 << (scCnt-2)); /*vaÇøÖ»Ð£×¼6Î»*/
                       }
                       else
                       {
                           ucDataMask = 0x00;
                       }
               #if 1
                       if (scCnt > 1)
C251 COMPILER V5.54.0.0,  DrvAfePara                                                       26/05/17  20:21:06  PAGE 45  

                       {
                           ucKeyMask = (0x01 << (scCnt-2)); /*Key¸ß2Î»²»Æð×÷ÓÃ*/
                       }
                       else
                       {
                           ucKeyMask = 0x00;
                       }
               #else
                       ucKeyMask = (0x01 << scCnt);
               #endif
               
                       /* VAÍ¨µÀ´Ë´ÎÐ£ÕýÎ»ÖÃ */
                       for (i = 0; i < usChVaNum; i++)
                       {
                           ucCbValue[i] |= ucDataMask;
                       }
                       /* KeyÍ¨µÀ´Ë´ÎÐ£ÕýÎ»ÖÃ */
                       for (i = 0; i < KEY_NUM_MAX; i++)
                       {
                           ucCbValue[usChVaNum+i] |= ucKeyMask;
                       }
               
                       /* CB²ÎÊýÐ´Èë¼Ä´æÆ÷ */
                       DrvPara_WriteCB(ucTabID);
                       
                       g_ucAramReadyFlag = 0;
                       /* ¼ÓÔØTab±í */
                       DrvLoadTabSingle(ucTabID,0);
                       /* scan start */
                       DrvAsmScanStart();
               
                       /* wait end¡¡*/
                       while(!g_ucAramReadyFlag);
               
                       /* µ±Ç°Ö¡Êý¾Ý,AFE ARAM READYÖÐ¶ÏÍê³ÉÊý¾Ý°áÔËµ½RawBufÖÐ */
               #if 1
                       DBG_FLOW("\nRaw time %d \n",scCnt);
                       DrvGetRawdata();
               #endif
                       /* ¶ÔËùÓÐÍ¨µÀ½øÐÐÐ£Õý */
                       for (i = 0; i < usChNum; i++)
                       {
                           /* Èç¹ûRAWDATAÐ¡ÓÚÄ¿±êÖµ£¬½«Ô¤ÉèµÄÖµÇå³ý£¬Èç¹û´óÓÚÄ¿±êÖµ£¬±£³Öµ±Ç°Ô¤ÉèÖµ */
                           if (g_usRawdataBuf[i] < usRawTargeNormal)
                           {
                               ucCbValue[i] &= ~ucDataMask;
                           }
                       }
               
                   }
                   
                   /* CB²ÎÊýÐ´Èë¼Ä´æÆ÷ */
                   DrvPara_WriteCB(ucTabID);
               }
               #endif
 2892          
 2893          


Module Information          Static   Overlayable
------------------------------------------------
  code size            =    ------     ------
  ecode size           =      9307     ------
  data size            =         4         14
  idata size           =    ------     ------
  pdata size           =    ------     ------
  xdata size           =    ------     ------
C251 COMPILER V5.54.0.0,  DrvAfePara                                                       26/05/17  20:21:06  PAGE 46  

  xdata-const size     =    ------     ------
  edata size           =        84       4328
  bit size             =    ------     ------
  ebit size            =    ------     ------
  bitaddressable size  =    ------     ------
  ebitaddressable size =    ------     ------
  far data size        =    ------     ------
  huge data size       =    ------     ------
  const size           =    ------     ------
  hconst size          =      1274     ------
End of Module Information.


C251 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
