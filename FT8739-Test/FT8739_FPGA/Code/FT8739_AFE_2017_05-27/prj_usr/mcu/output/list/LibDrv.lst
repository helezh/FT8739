C251 COMPILER V5.54.0.0,  LibDrv                                                           26/05/17  20:21:07  PAGE 1   


C251 COMPILER V5.54.0.0, COMPILATION OF MODULE LibDrv
OBJECT MODULE PLACED IN ..\output\obj\LibDrv.obj
COMPILER INVOKED BY: D:\software\Keil\C251\BIN\C251.EXE ..\..\src\source\lib_drv\LibDrv.c SMALL ROM(HUGE) OPTIMIZE(9,SPE
                    -ED) REGFILE(..\output\obj\mcu.ORC) BROWSE INCDIR(..\..\src\include;..\..\src\include\app;..\..\src\include\flow;..\..\sr
                    -c\include\driver\;..\..\src\include\lib_drv\;..\..\src\include\config;..\..\src\include\Debug) DEFINE(__FT8836__) DEBUG 
                    -PRINT(..\output\list\LibDrv.lst) TABS(2) OBJECT(..\output\obj\LibDrv.obj) 

stmt  level    source

    1          /*******************************************************************************
    2          * Copyright (C) 2012-2014, FocalTech Systems (R)，All Rights Reserved.
    3          *
    4          * File Name: LibDrv.c
    5          *
    6          *    Author: xinkunpeng
    7          *
    8          *   Created: 2014-05-28
    9          *
   10          *  Abstract: 
   11          *
   12          * Reference:
   13          *
   14          *******************************************************************************/
   15          
   16          /*******************************************************************************
   17          * Included header files
   18          *******************************************************************************/
   19          #include "CfgSystem.h" 
   20          #include "LibDrv.h"
   21          #include "DrvSysCtrl.h"
   22          
   23          /*******************************************************************************
   24          * 2.Private constant and macro definitions using #define
   25          *******************************************************************************/
   26          
   27          /* DMA unit default value */
   28          #define DMALENGTH     5
   29          
   30          #define XSI_S_W_CFG      ((1<<XSI_WDATA_WR) + (XSI_S_REG<<XSI_WDATA_SEL))
   31          #define XSI_S_R_CFG      ((0<<XSI_WDATA_WR) + (XSI_S_REG<<XSI_WDATA_SEL))
   32          #define AFE_REG_W_CFG    ((1<<XSI_WDATA_WR) + (AFE_REG<<XSI_WDATA_SEL))
   33          #define AFE_REG_R_CFG    ((0<<XSI_WDATA_WR) + (AFE_REG<<XSI_WDATA_SEL))
   34          
   35          //对lcd reg操作，小心操作
   36          #define LCD_REG_BASE_ADDR      0x020000
   37          #define Xbus_ADDR8(n)    (*((UINT8 far *)(LCD_REG_BASE_ADDR + n)))
   38          #define Xbus_ADDR16(n)   (*((UINT16 far *)(LCD_REG_BASE_ADDR + n)))
   39          /*******************************************************************************
   40          * 3.Private enumerations, structures and unions using typedef
   41          *******************************************************************************/
   42          
   43          /*******************************************************************************
   44          * 4.Static variables
   45          *******************************************************************************/
   46          ST_CalRegisters * XRAM pCalRegs = (volatile ST_CalRegisters *)CAL_REG_BASE_ADDR;
   47          
   48          ST_XSIRegisters * XRAM pXSI0Regs = (volatile ST_XSIRegisters *)XSI0_REG_BASE_ADDR;
   49          ST_XSIRegisters * XRAM pXSI1Regs = (volatile ST_XSIRegisters *)XSI1_REG_BASE_ADDR;
   50          ST_XSIRegisters * XRAM pXSI2Regs = (volatile ST_XSIRegisters *)XBUS_REG_BASE_ADDR;
   51          
   52          ST_LcdWrapRegisters * XRAM pLcdWrapRegs = (volatile ST_LcdWrapRegisters *)LCD_WRAP_START_ADDR;
   53          
   54          /*******************************************************************************
   55          * 5.Global variable or extern global variabls/functions
   56          *******************************************************************************/
C251 COMPILER V5.54.0.0,  LibDrv                                                           26/05/17  20:21:07  PAGE 2   

   57          BOOLEAN g_bCalResumeFlag;
   58          
   59          /*******************************************************************************
   60          * 6.Static function prototypes
   61          *******************************************************************************/
   62          
   63          /******************************************************************************/
   64          // XSI module
   65          /*******************************************************************************
   66          *   Name: Drv_Xsi0Init
   67          *  Brief: 
   68          *  Input: 
   69          * Output: 
   70          * Return: 
   71          *******************************************************************************/
   72          void Drv_XsiInit()
   73          {    
   74   1          AFECKEN  = 1;
   75   1          XSICKEN  = 1;
   76   1      
   77   1          XSI_SEL = 0; //CPU访问XSI
   78   1          while(XSI_STA);  //确保时钟切换完成
   79   1         
   80   1          // clk sel
   81   1          pXSI0Regs->Clksel = 3;
   82   1          pXSI1Regs->Clksel = 3;
   83   1          
   84   1          XBUSCKEN = 1;
   85   1      }
   86          
   87          /*******************************************************************************
   88          *   Name: Drv_XsiReadReg
   89          *  Brief: 
   90          *  Input: 
   91          * Output: 
   92          * Return: 
   93          *******************************************************************************/
   94          UINT16 Drv_XsiReadReg(ST_XSIRegisters *pXSIRegs, UINT16 usAddr, UINT8 flag)
   95          {
   96   1          UINT16 XRAM tmp;
   97   1      
   98   1      //    DelayMs(1);
   99   1          XSI_SEL = 0;  // MCU used XSI
  100   1          while(XSI_STA);  //确保时钟切换完成
  101   1      
  102   1      //    pXSIRegs->Stop = 1;
  103   1      //    while (pXSIRegs->Stop);
  104   1      
  105   1          pXSIRegs->Wdata  = (0<<XSI_WDATA_WR) + (flag<<XSI_WDATA_SEL) + usAddr;
  106   1          while (!pXSIRegs->Tx_int);
  107   1      
  108   1          pXSIRegs->Wdata = XSI_WDATA_DUMMY; // dummy
  109   1          while (!pXSIRegs->Tx_int);
  110   1       
  111   1          tmp = pXSIRegs->Rdata;
  112   1      
  113   1          pXSIRegs->Stop = 1;
  114   1          while (pXSIRegs->Stop);
  115   1          
  116   1          XSI_SEL = 1;  // AFE used XSI
  117   1          while(!XSI_STA); 
  118   1          
  119   1          return tmp;
  120   1      }
  121          
  122          /*******************************************************************************
C251 COMPILER V5.54.0.0,  LibDrv                                                           26/05/17  20:21:07  PAGE 3   

  123          *   Name: Drv_XsiWriteReg
  124          *  Brief: 
  125          *  Input: 
  126          * Output: 
  127          * Return: 
  128          *******************************************************************************/
  129          void Drv_XsiWriteReg(ST_XSIRegisters *pXSIRegs, UINT16 usAddr, UINT16 usData,UINT8 flag)
  130          {
  131   1      //DelayMs(1);
  132   1          XSI_SEL = 0;  // MCU used XSI
  133   1          while(XSI_STA);  //确保时钟切换完成
  134   1      
  135   1      //    pXSIRegs->Stop = 1;
  136   1      //    while (pXSIRegs->Stop);
  137   1          
  138   1          pXSIRegs->Wdata = (1<<XSI_WDATA_WR) + (flag<<XSI_WDATA_SEL) + usAddr;
  139   1          while (!pXSIRegs->Tx_int);
  140   1      
  141   1          pXSIRegs->Wdata = usData;
  142   1          while (!pXSIRegs->Tx_int);
  143   1      
  144   1          pXSIRegs->Stop = 1;
  145   1          while (pXSIRegs->Stop);
  146   1          XSI_SEL = 1;  // AFE used XSI
  147   1          while(!XSI_STA);     
  148   1      }
  149          
  150          /*******************************************************************************
  151          *   Name: Drv_XsiRead
  152          *  Brief: 
  153          *  Input: 
  154          * Output: 
  155          * Return: 
  156          *******************************************************************************/
  157          void Drv_XsiRead(ST_XSIRegisters *pXSIRegs, UINT16 usAddr, UINT16 *pBuf, UINT16 len, UINT8 flag)
  158          {
  159   1          UINT16 XRAM i;
  160   1      
  161   1      //DelayMs(1);
  162   1          XSI_SEL = 0;  // MCU used XSI
  163   1          while(XSI_STA);  //确保时钟切换完成
  164   1       
  165   1      //     pXSIRegs->Stop = 1;
  166   1      //     while (pXSIRegs->Stop);
  167   1      
  168   1          pXSIRegs->Wdata  = (0<<XSI_WDATA_WR) + (flag<<XSI_WDATA_SEL) + usAddr;
  169   1          while (!pXSIRegs->Tx_int);
  170   1      
  171   1          for (i = 0; i < len; i++)
  172   1          {
  173   2              pXSIRegs->Wdata = XSI_WDATA_DUMMY;   // dummy
  174   2              while (!pXSIRegs->Tx_int);
  175   2              
  176   2              *pBuf++ = pXSIRegs->Rdata;
  177   2          }
  178   1      
  179   1          pXSIRegs->Stop = 1;
  180   1          while (pXSIRegs->Stop);
  181   1          
  182   1          XSI_SEL = 1;  // AFE used XSI
  183   1          while(!XSI_STA);    
  184   1      }
  185          
  186          /*******************************************************************************
  187          *   Name: Drv_XsiWrite
  188          *  Brief: 
C251 COMPILER V5.54.0.0,  LibDrv                                                           26/05/17  20:21:07  PAGE 4   

  189          *  Input: 
  190          * Output: 
  191          * Return: 
  192          *******************************************************************************/
  193          void Drv_XsiWrite(ST_XSIRegisters *pXSIRegs, UINT16 usAddr, UINT16 *pBuf, UINT16 len, UINT8 flag)
  194          {
  195   1          UINT16 XRAM i;
  196   1          
  197   1          XSI_SEL = 0;  // MCU used XSI
  198   1          while(XSI_STA);  //确保时钟切换完成
  199   1      //    pXSIRegs->Stop = 1;
  200   1      //    while (pXSIRegs->Stop);
  201   1          
  202   1          pXSIRegs->Wdata = (1<<XSI_WDATA_WR) + (flag<<XSI_WDATA_SEL) + usAddr;
  203   1          while (!pXSIRegs->Tx_int);
  204   1      
  205   1          for (i = 0; i < len; i++)
  206   1          {
  207   2              pXSIRegs->Wdata = *pBuf++;
  208   2              while (!pXSIRegs->Tx_int);
  209   2          }
  210   1      
  211   1          pXSIRegs->Stop = 1;
  212   1          while (pXSIRegs->Stop); 
  213   1          
  214   1          XSI_SEL = 1;  // AFE used XSI
  215   1          while(!XSI_STA);
  216   1      }
  217          
  218          /******************************************************************************/
  219          // Cal module
  220          /*******************************************************************************
  221          *   Name: DrvCal_Init
  222          *  Brief: 
  223          *        1. 配置矩阵Tx * Rx
  224          *        2. 配置可被打断的中断源
  225          *  Input:
  226          *        1. ucTxNum:矩阵行数
  227          *        2. ucRxNum:矩阵列数
  228          *        3. usDmask:中断源屏蔽字
  229          * Output: 
  230          * Return: None
  231          *******************************************************************************/
  232          void DrvCal_Init(UINT8 ucTxNum, UINT8 ucRxNum, UINT16 usDmask)
  233          {
  234   1          CALCKEN = 1;
  235   1      
  236   1          ucRxNum &= 0x1F;
  237   1          ucTxNum &= 0x3F;    
  238   1         
  239   1          //pCalRegs->DmaLen = DMALENGTH + (ucTxNum<<10) + (ucRxNum<<5);
  240   1          pCalRegs->DmaLen = DMALENGTH;
  241   1          pCalRegs->TxRxNum = (ucTxNum<<8)+ucRxNum;
  242   1      
  243   1          /* 运行时中断可打断源配置 */
  244   1          pCalRegs->Dmask = usDmask;
  245   1          
  246   1          CALCKEN = 0;      
  247   1      }
  248          
  249          /*******************************************************************************
  250          *   Name: DrvCal_Cmd
  251          *  Brief: Set cmd to cal_module.
  252          *  Input: cmd
  253          * Output: 
  254          * Return: None
C251 COMPILER V5.54.0.0,  LibDrv                                                           26/05/17  20:21:07  PAGE 5   

  255          *******************************************************************************/
  256          void DrvCal_Cmd(UINT16 cmd)
  257          {
  258   1          pCalRegs->cmd |= (cmd|CAL_CMD_START);
  259   1      
  260   1           /* mcu hold ... cal run */
  261   1          while ( (pCalRegs->cmd&CAL_CMD_INT) != CAL_CMD_INT )
  262   1          {       
  263   2              /* if cal madule is resumed,start again */
  264   2              if ( (pCalRegs->cmd&CAL_CMD_SUSPEND) == CAL_CMD_SUSPEND )
  265   2              {
  266   3                  pCalRegs->cmd |= CAL_CMD_RESUME;
  267   3                  g_bCalResumeFlag = TRUE;
  268   3                  //DBG_FLOW("\nint");
  269   3              }
  270   2          }
  271   1          pCalRegs->cmd |= CAL_CMD_INT_CLR;
  272   1          pCalRegs->cmd  = 0;                   // clear cmd
  273   1      }
  274          
  275          /*******************************************************************************
  276          *   Name: DrvCal_MatrixProc
  277          *  Brief: Let hardware do ADD/DEC/MOV matrix calculation.
  278          *         ADD/DEC: pCalRegs->OutAddr = (pCalRegs->S1Addr +/- pCalRegs->S2Addr)>>ucShift
  279          *         MOV:     pCalRegs->OutAddr = pCalRegs->S1Addr
  280          *  Input: ST_CalMcMatrixParam *pMcMP =>
  281          * Output: None
  282          * Return: None
  283          *******************************************************************************/
  284          void DrvCal_MatrixProc(ST_CalMcMatrixParam *pMcMP)
  285          {
  286   1          CALCKEN = 1;
  287   1      
  288   1          g_bCalResumeFlag = FALSE;
  289   1      
  290   1          pCalRegs->S1Addr  = pMcMP->usSrc1Addr;
  291   1          pCalRegs->S2Addr  = pMcMP->usSrc2Addr;
  292   1          pCalRegs->OutAddr = pMcMP->usDstAddr;
  293   1          pCalRegs->Size    = (pMcMP->ucTxNum<<8) + pMcMP->ucRxNum;
  294   1          
  295   1          pCalRegs->PThd = pMcMP->ucShift;
  296   1         
  297   1          // run
  298   1          pCalRegs->cmd  = ((pMcMP->ucCfg & 0x01)<<8);
  299   1      
  300   1          DrvCal_Cmd(pMcMP->usCalcmd);      
  301   1      
  302   1          CALCKEN = 0;            
  303   1      }
  304          
  305          /*******************************************************************************
  306          *   Name: DrvCal_MatrixAmp
  307          *  Brief: Let hardware do AMP matrix calculation.
  308          *         AMP: pCalRegs->OutAddr = (pCalRegs->S1Addr * mul)>>ucShift
  309          *  Input: ST_CalMcMatrixParam *pMcMP =>
  310          *         UINT8 mul
  311          * Output: None
  312          * Return: None
  313          *******************************************************************************/
  314          void DrvCal_MatrixAmp(ST_CalMcMatrixParam *pMcMP, SINT16 mul)
  315          {
  316   1          CALCKEN = 1;
  317   1      
  318   1          pCalRegs->S1Addr  = pMcMP->usSrc1Addr;
  319   1          pCalRegs->OutAddr = pMcMP->usDstAddr;
  320   1          pCalRegs->Size    = (pMcMP->ucTxNum<<8) + pMcMP->ucRxNum;
C251 COMPILER V5.54.0.0,  LibDrv                                                           26/05/17  20:21:07  PAGE 6   

  321   1      
  322   1          pCalRegs->PThd = pMcMP->ucShift;
  323   1          pCalRegs->Par  = mul;
  324   1         
  325   1          // run
  326   1          pCalRegs->cmd = 0;     
  327   1          DrvCal_Cmd(pMcMP->usCalcmd);      
  328   1      
  329   1          CALCKEN = 0;
  330   1      }
  331          
  332          /*******************************************************************************
  333          *   Name: DrvCal_MatrixMul
  334          *  Brief: M1 : M*K           
  335          *         M2 : K*N
  336          *         OUT: M*N
  337          *         Out[i][j] = sum(S1[i][0...(K-1)]*S2[0...(k-1)[j]])
  338          *  Input: ST_CalMcMatrixParam *pMcMP =>
  339          *
  340          * Output: None
  341          * Return: None
  342          *******************************************************************************/
  343          void DrvCal_MatrixMul(ST_CalMcMatrixParam *pMcMP, UINT8 K_Num)
  344          {
  345   1          //clk
  346   1          CALCKEN = TRUE;
  347   1          DMACKEN = FALSE; 
  348   1      
  349   1          // Address
  350   1          pCalRegs->S1Addr  = pMcMP->usSrc1Addr;
  351   1          pCalRegs->S2Addr  = pMcMP->usSrc2Addr;
  352   1          pCalRegs->OutAddr = pMcMP->usDstAddr;
  353   1          pCalRegs->Size   = (pMcMP->ucTxNum<<8) + pMcMP->ucRxNum;  
  354   1          pCalRegs->PThd   = pMcMP->ucShift;    
  355   1          pCalRegs->NThd   = K_Num;
  356   1      
  357   1          pCalRegs->cmd  = 0;    
  358   1          DrvCal_Cmd(OP_MUL);
  359   1          
  360   1          CALCKEN = FALSE;        
  361   1      }
  362          
  363          
  364          /*******************************************************************************
  365          *   Name: DrvCal_MatrixAMov
  366          *  Brief: 
  367          *    1.Amov可嵌套CAL运算,当启动Amov时可打断当前CAL运算进行AMov运算
  368          *    2.该运算用于在中断中搬移Aram中rawdata到dram
  369          *    3.将master aram中rawdata与从slave搬过来的dram中rawdata拼成一块连续的buf
  370          *    4.mode: 0:只搬移S1矩阵, 1: 矩阵S1与矩阵S2合并后再搬移
  371          * input : 
  372          * Return: None
  373          *******************************************************************************/
  374          void DrvCal_MatrixAMov(ST_CalMatrixAMov *pMcMP)
  375          {
  376   1          CALCKEN = 1;//clk
  377   1          
  378   1          pCalRegs->DmaSka = pMcMP->usDmaMask;
  379   1          pCalRegs->Trna= (pMcMP->ucS1TxNum << 8) + pMcMP->ucS1RxNum;    //  1f TxRxNum
  380   1          pCalRegs->SizeA = (pMcMP->ucS1TxLen << 8) + pMcMP->ucS1RxLen;  //  21 TxRxLen
  381   1          pCalRegs->S1BaseEa = pMcMP->usSrc1Addr; // SrcAddr
  382   1          pCalRegs->DBaseEa = pMcMP->usDstAddr;   // DstAddr
  383   1          pCalRegs->Int &= 0xFF00;
  384   1          pCalRegs->Int |= (0<<3);//不支持合并aMove Mode Select 03
  385   1          pCalRegs->Int |= CAL_CMD_AMOV_EN;//启用aMove  04
  386   1          pCalRegs->Int |= CAL_CMD_AMOV_START;//aMoveStart 0
C251 COMPILER V5.54.0.0,  LibDrv                                                           26/05/17  20:21:07  PAGE 7   

  387   1           /* mcu hold ... cal run */
  388   1          while ((pCalRegs->Int&CAL_CMD_AMOV_INT) != CAL_CMD_AMOV_INT)
  389   1          {
  390   2              DBG_FLOW("\nwaiting...int");
  391   2              /* if cal madule is resumed,start again */
  392   2              if ((pCalRegs->Int&CAL_CMD_AMOV_SUSPEND) == CAL_CMD_AMOV_SUSPEND)
  393   2              {
  394   3                  pCalRegs->Int |= CAL_CMD_AMOV_RESUME;
  395   3                  g_bCalResumeFlag = TRUE;
  396   3              }
  397   2          }    
  398   1          pCalRegs->Int |= CAL_CMD_AMOV_INT_CLR;
  399   1          pCalRegs->Int &= 0xFF00;
  400   1          
  401   1          CALCKEN = 0;
  402   1      }
  403          
  404          /*******************************************************************************
  405          *   Name: Drv_XbusInit
  406          *  Brief:
  407          *  Input:
  408          * Output:
  409          * Return:
  410          *******************************************************************************/
  411          void Drv_XbusInit(void)
  412          {
  413   1          XBUSCKEN = 1;//
  414   1          LCD_RELOAD_FLASH_WKEN =0;
  415   1      
  416   1      }
  417          
  418          
  419          /******************************************************************************
  420          *
  421          *   Name: DrvXbus_ReadLcd16
  422          *  Brief: 读lcd数据 16位(双字节对齐)
  423          *  Input:
  424          * Output:
  425          * Return:
  426          *******************************************************************************/
  427          UINT16 DrvXbus_ReadLcd16(UINT16 usaddr)
  428          {
  429   1          volatile UINT8 Dummy;
  430   1          while(((pLcdWrapRegs->lcd_regfile_ctrl) & (BITn(1))) == 0);   //wait wr enable
  431   1          Dummy = Xbus_ADDR8(usaddr);     
  432   1          while(((pLcdWrapRegs->lcd_regfile_ctrl) & (BITn(0))) == 0);   //wait rdata redy
  433   1          //return (UINT16)((pLcdWrapRegs->rdata_lo_byte << 8) + (pLcdWrapRegs->rdata_ho_byte & 0x00ff)); //Big
             --endian
  434   1          return (UINT16)(pLcdWrapRegs->rdata_lo_byte);
  435   1      
  436   1      }
  437          
  438          
  439          /******************************************************************************
  440          *
  441          *   Name: DrvXbus_WriteLcd8
  442          *  Brief:写lcd数据 8位
  443          *  Input:
  444          * Output:
  445          * Return:
  446          *******************************************************************************/
  447          void DrvXbus_WriteLcd8(UINT16 usaddr,UINT8 usdata)
  448          {
  449   1          while(((pLcdWrapRegs->lcd_regfile_ctrl) & (BITn(1))) == 0); //wait wr enable
  450   1          Xbus_ADDR8(usaddr) = usdata;
  451   1      }
C251 COMPILER V5.54.0.0,  LibDrv                                                           26/05/17  20:21:07  PAGE 8   

  452          
  453          
  454          /******************************************************************************
  455          *
  456          *   Name: DrvXbus_WriteLcd8
  457          *  Brief:写lcd数据 8位
  458          *  Input:
  459          * Output:
  460          * Return:
  461          *******************************************************************************/
  462          void DrvXbus_WriteInitCode(void)
  463          {
  464   1        UINT16 ucData;
  465   1        ucData = DrvXbus_ReadLcd16(0x0A00);
  466   1        DBG_FLOW("\nLCD 0A00:%04x",ucData);
  467   1      
  468   1        DelayMs(100);
  469   1        DrvXbus_WriteLcd8(0x1100,0x00);      //sleep out
  470   1        
  471   1        DrvXbus_WriteLcd8(0x2900,0x00);      //display on 
  472   1      
  473   1        ucData = DrvXbus_ReadLcd16(0x0A00);
  474   1        DBG_FLOW("\nLCD 0A00:%04x",ucData);  //读到0x9c9c表明
  475   1        
  476   1      
  477   1        DrvXbus_WriteLcd8(0xff00,0x88);   
  478   1        DrvXbus_WriteLcd8(0xff01,0x35); 
  479   1        DrvXbus_WriteLcd8(0xff02,0x01);
  480   1      
  481   1        DrvXbus_WriteLcd8(0xff80,0x88);   
  482   1        DrvXbus_WriteLcd8(0xff81,0x35); 
  483   1        DrvXbus_WriteLcd8(0xff82,0x01);   
  484   1      
  485   1      #if 1
  486   1        //============================================      
  487   1        // kyo TCON setting    
  488   1        //============================================     
  489   1        DrvXbus_WriteLcd8(0xc080,0x00);     //reg_tcon_rtn_hi      
  490   1        DrvXbus_WriteLcd8(0xc081,0x56);       //reg_tcon_rtn_lo      
  491   1        DrvXbus_WriteLcd8(0xc084,0x00);       //reg_tcon_norm_vbp_hi
  492   1        DrvXbus_WriteLcd8(0xc085,0x10);       //reg_tcon_norm_vbp_lo     
  493   1        DrvXbus_WriteLcd8(0xc0a3,0x10);     //reg_tcon_pwrseq_vfp_lo[7:0]    
  494   1        DrvXbus_WriteLcd8(0xc0c1,0x80);     //[7:6]reg_tcon_pwron_mode, [4]reg_tcon_pwrof_2_en, [3:0]reg_tcon_f_p
             -owof_2      
  495   1        DrvXbus_WriteLcd8(0xc180,0x33);     //[6:4]reg_osc_idle_freq,   [2:0]reg_osc_normal_freq      
  496   1        DrvXbus_WriteLcd8(0xc181,0x33);     //[6:4]reg_osc_pwrseq_freq, [2:0]reg_osc_video_freq   
  497   1        DrvXbus_WriteLcd8(0xc190,0x44);     //[7:4]reg_oscdiv_pwrseq_num, [3:0]reg_oscdiv_num   
  498   1        DrvXbus_WriteLcd8(0xc1a1,0x80);     //vs_video, hs_video, clk_video, bp_video   
  499   1        DrvXbus_WriteLcd8(0xc1a3,0x03);     //reg_oscref_video_vs_shift_hi
  500   1        DrvXbus_WriteLcd8(0xc1a4,0x9b);       //reg_oscref_video_vs_shift_lo
  501   1        DrvXbus_WriteLcd8(0xc1a5,0x00);       //reg_oscref_video_hs_shift_hi
  502   1        DrvXbus_WriteLcd8(0xc1a6,0x00);       //reg_oscref_video_hs_shift_lo
  503   1        DrvXbus_WriteLcd8(0xc0a5,0x00);       //reg_tcon_mck_shift1_hi
  504   1        DrvXbus_WriteLcd8(0xc0a6,0x05);       //reg_tcon_mck_shift1_lo
  505   1        DrvXbus_WriteLcd8(0xc0a7,0x00);       //reg_tcon_mck_shift2_hi
  506   1        DrvXbus_WriteLcd8(0xc0a8,0x08);       //reg_tcon_mck_shift2_lo
  507   1        DrvXbus_WriteLcd8(0xc0a9,0x00);       //reg_tcon_mck_shift3_hi
  508   1        DrvXbus_WriteLcd8(0xc0aa,0x07);       //reg_tcon_mck_shift3_lo
  509   1        DrvXbus_WriteLcd8(0xc0e2,0x85);       //reg_tcon_datapath_dly_offset
  510   1        DrvXbus_WriteLcd8(0xc0a0,0x00);       //reg_tcon_pwrseq_rtn_hi
  511   1        DrvXbus_WriteLcd8(0xc0a1,0x20);       //reg_tcon_pwrseq_rtn_lo
  512   1        DrvXbus_WriteLcd8(0xc0c1,0xc0);       //[7:6]reg_tcon_pwron_mode, [4]reg_tcon_pwrof_2_en,[3:0]reg_tcon_f
             -_powof_2      
  513   1        //============================================
  514   1        // kyo TCON LPF setting
  515   1        //============================================
C251 COMPILER V5.54.0.0,  LibDrv                                                           26/05/17  20:21:07  PAGE 9   

  516   1        DrvXbus_WriteLcd8(0xced0,0x85);       //[7]reg_tcon_dfr_video_en,[2]reg_tcon_lpf_mode, [1]reg_tcon_lpf, 
             -[0]reg_tcon_lpf_auto
  517   1        DrvXbus_WriteLcd8(0xced1,0x02);     //reg_tcon_dfr_num
  518   1        DrvXbus_WriteLcd8(0xced2,0x01);       //reg_tcon_lpfscan_num
  519   1        DrvXbus_WriteLcd8(0xced3,0x00);       //reg_tcon_lpf_rtn_hi
  520   1        DrvXbus_WriteLcd8(0xced4,0x50);       //reg_tcon_lpf_rtn_lo
  521   1        DrvXbus_WriteLcd8(0xced5,0x00);       //reg_tcon_lpf_vfp_hi
  522   1        DrvXbus_WriteLcd8(0xced6,0x10);       //reg_tcon_lpf_vfp_lo
  523   1        DrvXbus_WriteLcd8(0xced7,0x00);       //reg_tcon_lpf_vbp_hi
  524   1        DrvXbus_WriteLcd8(0xced8,0x10);       //reg_tcon_lpf_vbp_lo
  525   1        DrvXbus_WriteLcd8(0xced9,0x00);       //reg_tcon_lpf_shift
  526   1        DrvXbus_WriteLcd8(0xceda,0x06);       //reg_tcon_lpf_pcg_dri
  527   1        DrvXbus_WriteLcd8(0xcedb,0x05);       //reg_tcon_lpf_pcg_nop
  528   1        DrvXbus_WriteLcd8(0xcedc,0x04);       //reg_tcon_lpf_pcg_swt
  529   1        DrvXbus_WriteLcd8(0xcedd,0x15);     //reg_tcon_lpf_ckh_dri
  530   1        DrvXbus_WriteLcd8(0xcede,0x03);       //reg_tcon_lpf_ckh_nop
  531   1        DrvXbus_WriteLcd8(0xcedf,0x01);
  532   1        
  533   1        //reg_tcon_lpf_ckh_swt
  534   1        //============================================
  535   1        // kyo TP setting
  536   1        //============================================
  537   1        DrvXbus_WriteLcd8(0xce80,0x01);       //reg_tp_en
  538   1        DrvXbus_WriteLcd8(0xce81,0x01);       //reg_tp_line_num_of_unit_1st_hi
  539   1        DrvXbus_WriteLcd8(0xce82,0x20);       //reg_tp_line_num_of_unit_1st_lo
  540   1        DrvXbus_WriteLcd8(0xce83,0x01);       //reg_tp_line_num_of_unit_2nd_hi
  541   1        DrvXbus_WriteLcd8(0xce84,0x20);       //reg_tp_line_num_of_unit_2nd_lo
  542   1        DrvXbus_WriteLcd8(0xce85,0xFF);       //reg_tcon_tp_swt_rgn
  543   1        DrvXbus_WriteLcd8(0xce86,0x01);       //[7]reg_tcon_tp_1st_rgn_ena, [3:0]reg_tcon_tp_lnpb_1st_hi
  544   1        DrvXbus_WriteLcd8(0xce87,0x20);       //reg_tcon_tp_lnpb_1st_lo
  545   1        DrvXbus_WriteLcd8(0xce88,0x09);       //reg_tcon_tp_last_rgn
  546   1        DrvXbus_WriteLcd8(0xce89,0x01);       //reg_tcon_tp_lnpb_last_hi
  547   1        DrvXbus_WriteLcd8(0xce8a,0x20);       //reg_tcon_tp_lnpb_last_lo
  548   1        DrvXbus_WriteLcd8(0xce8b,0x00);       //reg_tcon_tp_break_rgn
  549   1        DrvXbus_WriteLcd8(0xce8c,0x00);       //[7]reg_tcon_tp_rgn_break_ena, [3:0]reg_tcon_tp_lnpb_break_hi
  550   1        DrvXbus_WriteLcd8(0xce8d,0x00);       //reg_tcon_tp_lnpb_break_lo
  551   1        DrvXbus_WriteLcd8(0xce90,0x00);       //reg_tp_term1_width_hi 
  552   1        DrvXbus_WriteLcd8(0xce91,0x76);       //reg_tp_term1_width_lo
  553   1        DrvXbus_WriteLcd8(0xce92,0x0F);       //reg_tp_term2_width_hi
  554   1        DrvXbus_WriteLcd8(0xce93,0x50);       //reg_tp_term2_width_lo
  555   1        DrvXbus_WriteLcd8(0xce94,0x00);       //reg_tp_term3_width_hi
  556   1        DrvXbus_WriteLcd8(0xce95,0x76);       //reg_tp_term3_width_lo
  557   1        DrvXbus_WriteLcd8(0xce96,0x00);       //reg_tcon_tp_vb_str_hi
  558   1        DrvXbus_WriteLcd8(0xce97,0x00);       //reg_tcon_tp_vb_str_lo
  559   1        DrvXbus_WriteLcd8(0xce98,0x02);       //reg_tcon_tp_term1a_vb_ln
  560   1        DrvXbus_WriteLcd8(0xce99,0x00);       //reg_tcon_tp_term1b_vb_ln_hi
  561   1        DrvXbus_WriteLcd8(0xce9a,0xA0);       //reg_tcon_tp_term1b_vb_ln_lo
  562   1      
  563   1        DrvXbus_WriteLcd8(0xce9b,0x02);       //reg_tcon_tp_term2_vb_ln
  564   1        //DrvXbus_WriteLcd8(0xceaa,`ROW_NO/256);//reg_tcon_tp_cnt_stp_disp_hi
  565   1        //DrvXbus_WriteLcd8(0xceab,`ROW_NO%256);//reg_tcon_tp_cnt_stp_disp_lo
  566   1      
  567   1        DrvXbus_WriteLcd8(0xceaa,0x0B);       //reg_tcon_tp_cnt_stp_disp_hi
  568   1        DrvXbus_WriteLcd8(0xceab,0x40);       //reg_tcon_tp_cnt_stp_disp_lo
  569   1        DrvXbus_WriteLcd8(0xceb1,0x00);       //reg_tp_pre_dmy_rtn_hi, reg_tp_pos_dmy_rtn_hi
  570   1        DrvXbus_WriteLcd8(0xceb2,0x56);       //reg_tp_pre_dmy_rtn_lo
  571   1        DrvXbus_WriteLcd8(0xceb3,0x56);       //reg_tp_pos_dmy_rtn_lo 
  572   1        DrvXbus_WriteLcd8(0xcfd2,0x00);     //reg_tp_busy_termx_start_cnt_hi
  573   1        DrvXbus_WriteLcd8(0xcfd3,0x1d);       //reg_tp_busy_termx_start_cnt_lo
  574   1        DrvXbus_WriteLcd8(0xcfd4,0x00);     //reg_tp_busy_termx_end_cnt_hi
  575   1        DrvXbus_WriteLcd8(0xcfd5,0x1d);       //reg_tp_busy_termx_end_cnt_lo
  576   1        DrvXbus_WriteLcd8(0xcfd7,0x00);       //reg_tp_sw_termx_start_cnt_hi
  577   1        DrvXbus_WriteLcd8(0xcfd8,0x28);       //reg_tp_sw_termx_start_cnt_lo
  578   1        DrvXbus_WriteLcd8(0xcfd9,0x00);       //reg_tp_sw_termx_end_cnt_hi
  579   1        DrvXbus_WriteLcd8(0xcfda,0x12);       //reg_tp_sw_termx_end_cnt_lo
  580   1        DrvXbus_WriteLcd8(0xcf84,0x00);       //reg_tp_vcom_termx_start_cnt_hi
C251 COMPILER V5.54.0.0,  LibDrv                                                           26/05/17  20:21:07  PAGE 10  

  581   1        DrvXbus_WriteLcd8(0xcf85,0x28);       //reg_tp_vcom_termx_start_cnt_lo
  582   1        DrvXbus_WriteLcd8(0xcf86,0x00);       //reg_tp_vcom_termx_end_cnt_hi
  583   1        DrvXbus_WriteLcd8(0xcf87,0x12);       //reg_tp_vcom_termx_end_cnt_lo
  584   1        DrvXbus_WriteLcd8(0xcf88,0x05);       //reg_abnormal_width_swb_lo_vcom
  585   1        DrvXbus_WriteLcd8(0xcf89,0x00);       //[7:6]reg_abnormal_width_swb_hi_vcom, [1:0]reg_abnormal_width_swb
             -_hi_vglo
  586   1        DrvXbus_WriteLcd8(0xcf8a,0x05);       //reg_abnormal_width_swb_lo_vglo
  587   1        DrvXbus_WriteLcd8(0xcf8c,0x00);       //reg_tp_vglo_termx_start_cnt_hi
  588   1        DrvXbus_WriteLcd8(0xcf8d,0x28);       //reg_tp_vglo_termx_start_cnt_lo
  589   1        DrvXbus_WriteLcd8(0xcf8e,0x00);       //reg_tp_vglo_termx_end_cnt_hi 
  590   1        DrvXbus_WriteLcd8(0xcf8f,0x12);       //reg_tp_vglo_termx_end_cnt_lo
  591   1        DrvXbus_WriteLcd8(0xcfa0,0x00);       //reg_tp_gpio0_start_hi
  592   1        DrvXbus_WriteLcd8(0xcfa2,0x10);       //reg_tp_gpio0_start_lo 
  593   1        DrvXbus_WriteLcd8(0xcfa1,0x00);       //reg_tp_gpio0_end_hi
  594   1        DrvXbus_WriteLcd8(0xcfa3,0x20);       //reg_tp_gpio0_end_lo 
  595   1        DrvXbus_WriteLcd8(0xcfa4,0x03);       //reg_tp_gpio1_start_hi   
  596   1        DrvXbus_WriteLcd8(0xcfa6,0xD0);     //reg_tp_gpio1_start_lo
  597   1        DrvXbus_WriteLcd8(0xcfa5,0x03);       //reg_tp_gpio1_end_hi
  598   1        DrvXbus_WriteLcd8(0xcfa7,0xE0);       //reg_tp_gpio1_end_lo
  599   1        DrvXbus_WriteLcd8(0xcfa8,0x07);       //reg_tp_gpio2_start_hi
  600   1        DrvXbus_WriteLcd8(0xcfaa,0x90);       //reg_tp_gpio2_start_lo 
  601   1        DrvXbus_WriteLcd8(0xcfa9,0x07);       //reg_tp_gpio2_end_hi
  602   1        DrvXbus_WriteLcd8(0xcfab,0xA0);     //reg_tp_gpio2_end_lo
  603   1        DrvXbus_WriteLcd8(0xcfac,0x0B);     //reg_tp_gpio3_start_hi
  604   1        DrvXbus_WriteLcd8(0xcfae,0x50);       //reg_tp_gpio3_start_lo 
  605   1        DrvXbus_WriteLcd8(0xcfad,0x0B);       //reg_tp_gpio3_end_hi 
  606   1        DrvXbus_WriteLcd8(0xcfaf,0x60);       //reg_tp_gpio3_end_lo
  607   1        
  608   1        //============================================
  609   1        // kyo latch control
  610   1        //============================================
  611   1        DrvXbus_WriteLcd8(0xc491,0x80);   //[7]reg_latch_clk_opt
  612   1      
  613   1      #endif
  614   1      
  615   1      }
  616          
  617          
  618          
  619          void DrvXsi0_WriteN(UINT16 usAddr, UINT16 *pBuf, UINT16 usLen)
  620          {
  621   1          UINT16 i;
  622   1      
  623   1          XSI_SEL = 0;  // MCU used XSI
  624   1          while(XSI_STA);
  625   1      //    pXSI0Regs->Stop = 1;
  626   1      //    while (pXSI0Regs->Stop);
  627   1      
  628   1          pXSI0Regs->Wdata = AFE_REG_W_CFG + usAddr;
  629   1          while (!pXSI0Regs->Tx_int);
  630   1      
  631   1          for (i = 0; i < usLen; i++)
  632   1          {
  633   2              pXSI0Regs->Wdata = pBuf[i];
  634   2              while (!pXSI0Regs->Tx_int);
  635   2          }
  636   1          
  637   1          pXSI0Regs->Stop = 1;
  638   1          while (pXSI0Regs->Stop);
  639   1          
  640   1          XSI_SEL = 1;  // AFE used XSI
  641   1          while(!XSI_STA);    
  642   1      }
  643          
  644          void DrvXsi1_WriteN(UINT16 usAddr, UINT16 *pBuf, UINT16 usLen)
  645          {
C251 COMPILER V5.54.0.0,  LibDrv                                                           26/05/17  20:21:07  PAGE 11  

  646   1          UINT16 i;
  647   1      
  648   1          XSI_SEL = 0;  // MCU used XSI
  649   1          while(XSI_STA);
  650   1      //    pXSI1Regs->Stop = 1;
  651   1      //    while (pXSI1Regs->Stop);
  652   1      
  653   1          pXSI1Regs->Wdata = AFE_REG_W_CFG + usAddr;
  654   1          while (!pXSI1Regs->Tx_int);
  655   1      
  656   1          for (i = 0; i < usLen; i++)
  657   1          {
  658   2              pXSI1Regs->Wdata = pBuf[i];
  659   2              while (!pXSI1Regs->Tx_int);
  660   2          }
  661   1          
  662   1          pXSI1Regs->Stop = 1;
  663   1          while (pXSI1Regs->Stop);   
  664   1          
  665   1          XSI_SEL = 1;  // AFE used XSI
  666   1          while(!XSI_STA);    
  667   1      }
  668          
  669          
  670          void DrvXbus_WriteLcdReg(UINT16 usAddr,UINT8 ucData)
  671          {
  672   1          while(((pLcdWrapRegs->lcd_regfile_ctrl) & (BITn(1))) == 0); //wait wr enable
  673   1          XBUS_ADDR8(usAddr) = ucData;
  674   1      //    while(((pLcdWrapRegs->lcd_regfile_ctrl) & (BITn(1))) == 0); //wait wr enable
  675   1      }
  676          
  677          /*******************************************************************************
  678          *   Name: DrvXbus_ReadLcd16
  679          *  Brief: 读lcd数据 
  680          *  Input: Addr:16bit  Data:8bit
  681          * Output:
  682          * Return:
  683          *******************************************************************************/
  684          UINT8 DrvXbus_ReadLcdReg(UINT16 usAddr)
  685          {
  686   1          volatile UINT8 Dummy;
  687   1          while(((pLcdWrapRegs->lcd_regfile_ctrl) & (BITn(1))) == 0);   //wait wr enable
  688   1          Dummy = XBUS_ADDR8(usAddr);     
  689   1          while(((pLcdWrapRegs->lcd_regfile_ctrl) & (BITn(0))) == 0);   //wait rdata redy
  690   1          if(usAddr%2)
  691   1          {
  692   2              return (UINT8)(pLcdWrapRegs->rdata_hi_byte & 0x00ff); //Big-endian
  693   2          }
  694   1          else
  695   1          {
  696   2              return (UINT8)(pLcdWrapRegs->rdata_lo_byte & 0x00ff);
  697   2          }
  698   1      }
  699          


Module Information          Static   Overlayable
------------------------------------------------
  code size            =    ------     ------
  ecode size           =      2558     ------
  data size            =    ------         16
  idata size           =    ------     ------
  pdata size           =    ------     ------
  xdata size           =    ------     ------
  xdata-const size     =    ------     ------
  edata size           =        20     ------
  bit size             =         1     ------
C251 COMPILER V5.54.0.0,  LibDrv                                                           26/05/17  20:21:07  PAGE 12  

  ebit size            =    ------     ------
  bitaddressable size  =    ------     ------
  ebitaddressable size =    ------     ------
  far data size        =    ------     ------
  huge data size       =    ------     ------
  const size           =    ------     ------
  hconst size          =        70     ------
End of Module Information.


C251 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
