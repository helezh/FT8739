C251 COMPILER V5.54.0.0,  FlowFactory                                                      26/05/17  20:21:08  PAGE 1   


C251 COMPILER V5.54.0.0, COMPILATION OF MODULE FlowFactory
OBJECT MODULE PLACED IN ..\output\obj\FlowFactory.obj
COMPILER INVOKED BY: D:\software\Keil\C251\BIN\C251.EXE ..\..\src\source\flow\FlowFactory.c SMALL ROM(HUGE) OPTIMIZE(9,S
                    -PEED) REGFILE(..\output\obj\mcu.ORC) BROWSE INCDIR(..\..\src\include;..\..\src\include\app;..\..\src\include\flow;..\..\
                    -src\include\driver\;..\..\src\include\lib_drv\;..\..\src\include\config;..\..\src\include\Debug) DEFINE(__FT8836__) DEBU
                    -G PRINT(..\output\list\FlowFactory.lst) TABS(2) OBJECT(..\output\obj\FlowFactory.obj) 

stmt  level    source

    1           /*******************************************************************************
    2          * Copyright (C) 2016-2018, FocalTech Systems (R)，All Rights Reserved.
    3          *
    4          * File Name: FlowFactory.c
    5          *
    6          *    Author: lisen
    7          *
    8          *   Created: 2016-12-06
    9          *
   10          *  Abstract: 
   11          *
   12          * Reference:
   13          *
   14          *******************************************************************************/
   15          
   16          /*******************************************************************************
   17          * 1.Included header files
   18          *******************************************************************************/
   19          #include "FlowFactory.h"
   20          #include "DrvSysCtrl.h"
   21          #include "AppHostComm.h"
   22          #include "AppSysCtrl.h"
   23          #include "CfgSystem.h"
   24          #include "AppParameter.h"
   25          #include "LibDrv.h"
   26          #include "DrvAsm.h"
   27          #include "DrvAfe.h"
   28          #include <intrins.h>
   29          
   30          /*******************************************************************************
   31          * 2.Private constant and macro definitions using #define
   32          *******************************************************************************/
   33          #define CFG_TX_NUM     (9*2)
   34          #define CFG_RX_NUM     36
   35          
   36          /*******************************************************************************
   37          * 3.Private enumerations, structures and unions using typedef
   38          *******************************************************************************/
   39          
   40          
   41          typedef enum
   42          {
   43              UP_K1_DELAY = 0x0001,
   44              UP_K2_DELAY = 0x0002,
   45              UP_SYNC_NUM = 0x0004,
   46              UP_CF       = 0x0008,
   47              UP_SUB_BASE = 0x0010,
   48              UP_NUM_LIST = 0x0020,
   49              UP_CB       = 0x0040,
   50              UP_ORDER    = 0x0080,
   51              UP_DUMMY    = 0x0100,
   52              UP_NOISE_THR    = 0x0200,
   53              UP_SWITCH_FREQ  = 0x0400,
   54              UP_TEST_CH      = 0x0800,     // 通道检测
   55              UP_MON_THR      = 0x1000,
   56          } ENUM_UP_PARA;
C251 COMPILER V5.54.0.0,  FlowFactory                                                      26/05/17  20:21:08  PAGE 2   

   57          
   58          typedef enum
   59          {
   60              UP_SYS_PARA = 0x01,
   61              UP_PANEL_PARA = 0x02,
   62          } ENUM_UP_GROUP_PARA;
   63          /*******************************************************************************
   64          * 4.Static variables
   65          *******************************************************************************/
   66          
   67          BOOLEAN s_bPanelParamUpdated = FALSE;   /* 系统参数更新标志 */
   68          UINT16 XRAM s_usParaFlag = 0x00;        /* AFE参数写入更新标志，按bit位安排 */
   69          
   70          /*******************************************************************************
   71          * 5.Global variable or extern global variabls/functions
   72          *******************************************************************************/
   73          UINT16 XRAM s_usRawCnt;               /* Read rawdata counter */
   74          UINT16 XRAM s_usCbCnt;                /* RW CB counter */
   75          UINT16 XRAM s_usOrderCnt;             /* RW Order counter */
   76          
   77          UINT8 XRAM * XRAM s_pucCbBuf;
   78          UINT16 XRAM * XRAM s_pucOrderBuf;
   79          UINT8 XRAM * XRAM s_pucRawBuf;
   80          
   81          UINT16 XRAM  g_usCBBuf[CH_LEN_MAX<<1];           //Tab表中初始化CB用的Buffer
   82          UINT8  XRAM  ucCbValue[CH_LEN_MAX<<1];            /* CB值 先放Tp.后放Key*/
   83          
   84          UINT16 XRAM  g_usInfo[30];                       // Info信息标志
   85          UINT16 XRAM  g_usRawdataBuf[(CH_LEN_MAX+1)*2];   // Rawdata (288+4key) *2 
   86          UINT16 XRAM  g_usBaseBuf[(CH_LEN_MAX+1)*2];      // Base    (288+4key) *2 
   87          
   88          UINT16  XRAM  g_ucOrderBuf[CH_ORDER_MAX<<1];      // Order   288不包含key
   89          
   90          
   91          volatile UINT16 XRAM g_usAsmIntFlag0      = 0x00;    // 中断中的软件标志
   92          volatile UINT16 XRAM g_usAsmIntFlag1      = 0x00;
   93          
   94          volatile UINT8 XRAM g_ucFrameEndFlag    = 0x00;  // frame end
   95          volatile UINT8 XRAM g_ucAramReadyFlag   = 0x00;  // Aram ready
   96          volatile UINT8 XRAM g_ucCbAdjOverFlag   = 0x00;  // Cb over
   97          volatile UINT8 XRAM g_ucConvertOverFlag = 0x00;
   98          
   99          volatile UINT8 XRAM g_ucLcdBusyFlag     = 0x00;
  100          volatile UINT8 XRAM g_ucLcdStopFlag     = 0x00;
  101          volatile UINT8 XRAM g_ucLcdStartFlag    = 0x00;
  102          volatile UINT8 XRAM g_ucLcdSyncMissFlag = 0x00;   
  103          volatile UINT8 XRAM g_ucTimeOutFlag     = 0x00;  // hw mon time out
  104          volatile UINT8 XRAM g_ucTchDetFlag      = 0x00;  // tch det
  105          
  106          volatile UINT8 XRAM g_ucAbnormalFlag    = 0x00;   // 0x01:esd 0x02:LVD 0x04:sync_mis
  107          volatile UINT8 XRAM g_ucState0 = 0x00;
  108          volatile UINT8 XRAM g_ucState1 = 0x00;
  109          
  110          UINT8 XRAM ucAfeRunMode   = 0x00;
  111          UINT16 *XRAM ap0;
  112          UINT16 *XRAM g_ucAram;
  113          volatile UINT16 XRAM g_ucIntCount = 0;
  114          UINT16 XRAM g_usAsmSta1 = 0;
  115          volatile UINT16 XRAM g_usAsmIntSta;
  116          
  117          
  118          #if TEST_60HZ_SCAN_MODE
  119          UINT8 XRAM g_ucAfeScanMode   = TP_60HZ_RUN_MODE;
  120          #else
               UINT8 XRAM g_ucAfeScanMode   = TP_120HZ_RUN_MODE; 
               #endif
C251 COMPILER V5.54.0.0,  FlowFactory                                                      26/05/17  20:21:08  PAGE 3   

  123          
  124          /*******************************************************************************
  125          * 6.Static function prototypes
  126          *******************************************************************************/
  127          
  128          
  129          /*******************************************************************************
  130          *   Name: AppWriteReg0x01
  131          *  Brief:
  132          *  Input:
  133          *
  134          * Output: None
  135          * Return:
  136          *******************************************************************************/
  137          void AppWriteReg0x01(UINT8 ucData)
  138          {
  139   1          switch (ucData)
  140   1          {
  141   2              case R01_CNT_CLEAR:
  142   2              {
  143   3                  s_usRawCnt = 0;
  144   3                  break;
  145   3              }
  146   2              case R01_CNT_KEY:
  147   2              {
  148   3                  s_usRawCnt = (TX_NUM * RX_NUM)<<1;
  149   3                  g_unPanelParam.reg.ucRawAddrH = (s_usRawCnt>>1)>>8;
  150   3                  g_unPanelParam.reg.ucRawAddrL = (s_usRawCnt>>1)%256;
  151   3                  break;
  152   3              }
  153   2      
  154   2              default:
  155   2              {
  156   3                  break;
  157   3              }
  158   2          }
  159   1      }
  160          /*******************************************************************************
  161          *   Name: AppWriteRegMapDataTest
  162          *  Brief: Write a byte to the register at given address in test device mode
  163          *  Input: UINT8 ucAddr => register address
  164          *         UINT8 ucData => register value to be written
  165          * Output: None
  166          * Return: UINT8 => the read byte
  167          *******************************************************************************/
  168          void AppWriteRegMapDataTest(UINT8 ucAddr,  UINT8 ucData)
  169          {
  170   1          UINT16 usBufAddr;
  171   1      
  172   1          /* set System parameters */
  173   1          if (ucAddr == ID_G_DEVICE_MODE)
  174   1          {
  175   2              AppHostUpdateHeadState(ucData);
  176   2          }
  177   1          
  178   1          /* make s_pucRawBuf point to related raw row data */
  179   1          else if (ucAddr == ID_G_RAWDATA_SETCT)
  180   1          {
  181   2              g_unPanelParam.reg.ucRawSel = ucData;
  182   2              AppWriteReg0x01(ucData);
  183   2          } 
  184   1          else if (ucAddr <= ID_G_DIFF_NOISE0)
  185   1          {
  186   2              if (ucAddr == ID_G_SCAN_MODE)
  187   2              {
  188   3                  /* 模式不变，或者异常数据，则不更新 */
C251 COMPILER V5.54.0.0,  FlowFactory                                                      26/05/17  20:21:08  PAGE 4   

  189   3                  if ((ucData == g_unPanelParam.reg.ucScanMode)
  190   3                      || (ucData >= 4))
  191   3                  {
  192   4                      return;
  193   4                  }
  194   3              }
  195   2      
  196   2              switch (ucAddr)
  197   2              {
  198   3                  // 只读寄存器处理
  199   3                  // case ID_G_TX_NUM:
  200   3                  // case ID_G_RX_NUM:
  201   3                  case ID_G_LCD_BUSY_NUM:
  202   3                  case ID_G_RUN_MODE:
  203   3                  case ID_G_P1P2_DELAY:
  204   3                  case ID_G_DROP_FLAG:
  205   3                  case ID_G_RAW_BUF_STA:
  206   3                  case ID_G_PARAUP_STATE:
  207   3                      return;
  208   3              }
  209   2      
  210   2              g_unPanelParam.Offset[ucAddr] = ucData;
  211   2      
  212   2              switch (ucAddr)
  213   2              {
  214   3                  case ID_G_CLB:
  215   3                  case ID_G_SCAN_MODE:
  216   3                  case ID_G_KEY_EN_LEFT:
  217   3                  case ID_G_KEY_EN_RIGHT:
  218   3                  case ID_G_DATA_MODE:
  219   3                  case ID_G_RAW_BUF_SEL:
  220   3                  {
  221   4                      s_bPanelParamUpdated = TRUE;
  222   4                      break;
  223   4                  }
  224   3      
  225   3                  case ID_G_INT_TEST_EN:
  226   3                  {
  227   4                      //AppTestIntPin();
  228   4                      break;
  229   4                  }
  230   3      
  231   3                  case ID_G_DUMMY_STB:
  232   3                  case ID_G_DUMMY_FRM:
  233   3                  case ID_G_DUMMY_SEG:
  234   3                  {
  235   4                      s_usParaFlag |= UP_DUMMY;
  236   4                      break;
  237   4                  }
  238   3      
  239   3                  case ID_G_K1_DELAY:
  240   3                  {
  241   4                      s_usParaFlag |= UP_K1_DELAY;
  242   4                      break;
  243   4                  }
  244   3      
  245   3                  case ID_G_K2_DELAY:
  246   3                  {
  247   4                      s_usParaFlag |= UP_K2_DELAY;
  248   4                      break;
  249   4                  }
  250   3      
  251   3                  case ID_G_SYNC_NUM:
  252   3                  {
  253   4                      s_usParaFlag |= UP_SYNC_NUM;
  254   4                      break;
C251 COMPILER V5.54.0.0,  FlowFactory                                                      26/05/17  20:21:08  PAGE 5   

  255   4                  }
  256   3      
  257   3                  case ID_G_CF:
  258   3                  {
  259   4                      s_usParaFlag |= UP_CF;
  260   4                      break;
  261   4                  }
  262   3      
  263   3                  case ID_G_SUB_BASE0:
  264   3                  {
  265   4                      s_usParaFlag |= UP_SUB_BASE;
  266   4                      break;
  267   4                  }
  268   3      
  269   3                  /* 设置 CB地址, 单位8bit */
  270   3                  case ID_G_CB_ADDR_L:
  271   3                  {
  272   4                      s_usCbCnt = (g_unPanelParam.Offset[ID_G_CB_ADDR_H]<<8) + ucData;
  273   4                      break;
  274   4                  }
  275   3      
  276   3                  /* 设置 order地址, 单位8bit */
  277   3                  case ID_G_ORDER_ADDR_L:
  278   3                  {
  279   4                      s_usOrderCnt = (g_unPanelParam.Offset[ID_G_ORDER_ADDR_H]<<8) + ucData;
  280   4                      break;
  281   4                  }
  282   3      
  283   3                  /* 设置 rawdta地址, 单位16bit */
  284   3                  case ID_G_RAW_ADDR_L:
  285   3                  {
  286   4                      s_usRawCnt = ((g_unPanelParam.Offset[ID_G_RAW_ADDR_H]<<8) + ucData)<<1;
  287   4                      break;
  288   4                  }
  289   3      
  290   3                  default:
  291   3                  {
  292   4                      break;
  293   4                  }
  294   3              }
  295   2      
  296   2              if (ucAddr >= ID_G_NUMLIST0 && ucAddr <= ID_G_NUMLIST15)
  297   2              {
  298   3                  /* 写低位的时候更新寄存器 */
  299   3                  if (ucAddr % 0x02 == 1)
  300   3                  {
  301   4                      s_usParaFlag |= UP_NUM_LIST;
  302   4                  }
  303   3              }
  304   2      
  305   2              if (ucAddr >= ID_G_RF_NOISE1)
  306   2              {
  307   3                  s_usParaFlag |= UP_NOISE_THR;
  308   3              }
  309   2      
  310   2              if (ucAddr == ID_G_FREQ_IDX)
  311   2              {
  312   3                  s_usParaFlag |= UP_SWITCH_FREQ;
  313   3              }
  314   2          }
  315   1          /* Write order data */
  316   1          else if ((ucAddr == ID_G_ORDER_BUF0) || (ucAddr == ID_G_ORDER_BUF1))
  317   1          {
  318   2              s_usParaFlag |= UP_ORDER;
  319   2              usBufAddr = (g_unPanelParam.reg.ucOrderAddrH<<8) + g_unPanelParam.reg.ucOrderAddrL;
  320   2              g_unPanelParam.reg.ucOrderAddrL++;
C251 COMPILER V5.54.0.0,  FlowFactory                                                      26/05/17  20:21:08  PAGE 6   

  321   2              if (g_unPanelParam.reg.ucOrderAddrL == 0x00)
  322   2              {
  323   3                  g_unPanelParam.reg.ucOrderAddrH++;
  324   3              }
  325   2              //g_stFrmInfo.ch.aucOrder[usBufAddr] = ucData;
  326   2              if (ucAddr == ID_G_ORDER_BUF1)
  327   2              {
  328   3                  g_ucI2cDataAddr = ID_G_ORDER_BUF0;
  329   3              }
  330   2          }
  331   1          /* Write CB data */
  332   1          else if ((ucAddr == ID_G_CB_BUF0) || (ucAddr == ID_G_CB_BUF1))
  333   1          {
  334   2              s_usParaFlag |= UP_CB;
  335   2              usBufAddr = (g_unPanelParam.reg.ucCbAddrH<<8) + g_unPanelParam.reg.ucCbAddrL;
  336   2              g_unPanelParam.reg.ucCbAddrL++;
  337   2              if (g_unPanelParam.reg.ucCbAddrL == 0x00)
  338   2              {
  339   3                  g_unPanelParam.reg.ucCbAddrH++;
  340   3              }
  341   2              if ((ucData >= 64)&&(usBufAddr < CH_LEN))      /* 有效通道总长度, 不含按键 */
  342   2              {
  343   3                  ucData = 64 + ((ucData-64)*4);
  344   3              }
  345   2              s_pucCbBuf[usBufAddr] = ucData&0x7F;
  346   2              if (ucAddr == ID_G_CB_BUF1)
  347   2              {
  348   3                  g_ucI2cDataAddr = ID_G_CB_BUF0;
  349   3              }
  350   2          }
  351   1      }
  352          
  353          /*******************************************************************************
  354          *   Name: AppReadRegMapDataTest
  355          *  Brief: Read a byte from the register at given address in test device mode
  356          *  Input: UINT8 ucAddr => register address
  357          * Output: None
  358          * Return: UINT8 => the read byte
  359          *******************************************************************************/
  360          UINT8 AppReadRegMapDataTest(UINT8 ucAddr)
  361          {
  362   1          UINT8 ucData;
  363   1      
  364   1          /* system parameters */
  365   1          if (ucAddr <= ID_G_DIFF_NOISE0)
  366   1          {
  367   2              return g_unPanelParam.Offset[ucAddr];
  368   2          }
  369   1          /* 一次性连续读取所有rawdata数据 */
  370   1          else if ((ucAddr == ID_G_RAW_BUF0) || (ucAddr == ID_G_RAW_BUF1))
  371   1          {
  372   2              ucData = s_pucRawBuf[s_usRawCnt++];
  373   2              if (ucAddr == ID_G_RAW_BUF1)
  374   2              {
  375   3                  g_ucI2cDataAddr = ID_G_RAW_BUF0;
  376   3              }
  377   2              return ucData;
  378   2          }
  379   1          /* 一次性连续读取所有 CB 数据: va 6bit ,key 8bit*/
  380   1          else if ((ucAddr == ID_G_CB_BUF0) || (ucAddr == ID_G_CB_BUF1))
  381   1          {
  382   2      
  383   2              if (s_usCbCnt < CH_LEN) // 288/324 *2
  384   2              {
  385   3                  ucData = s_pucCbBuf[s_usCbCnt]&0x3F;
  386   3              }
C251 COMPILER V5.54.0.0,  FlowFactory                                                      26/05/17  20:21:08  PAGE 7   

  387   2              else
  388   2              {
  389   3                  ucData = s_pucCbBuf[s_usCbCnt];
  390   3              }
  391   2              s_usCbCnt++;
  392   2              if (ucAddr == ID_G_CB_BUF1)
  393   2              {
  394   3                  g_ucI2cDataAddr = ID_G_CB_BUF0;
  395   3              }
  396   2              return ucData;
  397   2          }
  398   1      
  399   1          /* 一次性连续读取所有 Order 数据 */
  400   1          else if ((ucAddr == ID_G_ORDER_BUF0) || (ucAddr == ID_G_ORDER_BUF1))
  401   1          {
  402   2              ucData = s_pucOrderBuf[s_usOrderCnt++];
  403   2              if (ucAddr == ID_G_ORDER_BUF1)
  404   2              {
  405   3                  g_ucI2cDataAddr = ID_G_ORDER_BUF0;
  406   3              }
  407   2              return ucData;
  408   2          }
  409   1      
  410   1          else if ((ucAddr >= ID_FREE_RUN) && (ucAddr <= ID_G_LCD_INFO_END))
  411   1          {
  412   2              //return AppReadLcdInfo(ucAddr);
  413   2              return 0; //ls
  414   2          }
  415   1      
  416   1          /* 取FW buf */
  417   1          else if ((ucAddr == ID_G_FW_BUG0) || (ucAddr == ID_G_FW_BUG1))
  418   1          {
  419   2              UINT16 FwInfoStart;
  420   2              FwInfoStart = 0x70;
  421   2      
  422   2              //tmp = XDATA_ADDR8(FwInfoStart + g_unPanelParam.reg.FwInfoCnt);
  423   2              ucData = PRAM_ADDR8(FwInfoStart + g_unPanelParam.reg.FwInfoCnt);
  424   2      
  425   2              g_unPanelParam.reg.FwInfoCnt++;
  426   2              if (ucAddr == ID_G_FW_BUG1)
  427   2              {
  428   3                  g_ucI2cDataAddr = ID_G_FW_BUG0;
  429   3              }
  430   2      
  431   2              return ucData;
  432   2          }
  433   1          /* 调试窗口信息 */
  434   1          else
  435   1          {
  436   2              return 0;
  437   2          }
  438   1      }
  439          
  440          void AppPanelParamUpdate(void)
  441          {
  442   1          s_pucRawBuf =(UINT8 XRAM *)&g_usRawdataBuf[0]; 
  443   1          s_pucOrderBuf = (UINT16 XRAM *)&g_ucOrderBuf[0];
  444   1          s_pucCbBuf = (UINT8 XRAM *)&ucCbValue[0];
  445   1          s_usCbCnt = 0x00;
  446   1      }
  447          
  448          void AppShowRawdata(void)
  449          {
  450   1          UINT16  i;
  451   1      
  452   1          // TP Rawdata
C251 COMPILER V5.54.0.0,  FlowFactory                                                      26/05/17  20:21:08  PAGE 8   

  453   1          for(i = 0; i < (CH_ORDER_MAX)*2;i++)
  454   1          {
  455   2              if(i<CH_ORDER_MAX)
  456   2              {
  457   3                  if((i%(RX_NUM/2)) == 0)  
  458   3                  //if((i%(30)) == 0)  
  459   3                  {
  460   4                      DBG_FLOW("\n ");   
  461   4                  }
  462   3                  DBG_FLOW("%04x ",g_usRawdataBuf[i]);
  463   3              }
  464   2          }
  465   1      
  466   1          // KEY rawdata 最后8个数据放key, 左右各4个，只用一边。
  467   1          DBG_FLOW("\n ");
  468   1          for(i = 0;i < 8; i++)
  469   1          {
  470   2              DBG_FLOW("K%d :%05x ",i,g_usRawdataBuf[CH_ORDER_MAX*2 + i]);
  471   2          }
  472   1          
  473   1          // Info信息
  474   1          DBG_FLOW("\n ");
  475   1          for(i = 0;i < 6; i++)
  476   1          {
  477   2              DBG_FLOW("If%d:%05x ",i,g_usInfo[i]);
  478   2          }
  479   1      }
  480          
  481          void DrvGetDiffNoseMax(void)
  482          {
  483   1          UINT16 XRAM DiffMaxLTP;
  484   1          UINT16 XRAM DiffMaxRTP;
  485   1          UINT16 XRAM DiffMaxLKey;
  486   1          UINT16 XRAM DiffMaxRKey;
  487   1          
  488   1          ARAM_SEL = 1;
  489   1          ap0 = (UINT16)ARAM_DATA_BASE_ADDR;  
  490   1      
  491   1          DiffMaxLTP = ap0[ARAM_INFO_BASE_ADDR + TP_L_DIFF_NOISE_MAX_ADDR];
  492   1          DiffMaxRTP = ap0[ARAM_INFO_BASE_ADDR + TP_R_DIFF_NOISE_MAX_ADDR];
  493   1          DiffMaxLKey = ap0[ARAM_INFO_BASE_ADDR + KEY_L_DIFF_NOISE_MAX_ADDR];
  494   1          DiffMaxRKey = ap0[ARAM_INFO_BASE_ADDR + KEY_R_DIFF_NOISE_MAX_ADDR];
  495   1      
  496   1          DBG_FLOW("\n DiffMax LTp:%05d  RTp:%05d  LKey:%05d  RKey:%05d",DiffMaxLTP,DiffMaxRTP,DiffMaxLKey,Diff
             -MaxRKey);    
  497   1          ARAM_SEL = 0;
  498   1      }
  499          
  500          void DrvGetBase(void)
  501          {
  502   1          UINT16  i;
  503   1          
  504   1          for(i = 0; i < (CH_LEN_MAX)*2;i++)
  505   1          {
  506   2              g_usBaseBuf[i] = g_usRawdataBuf[i];
  507   2          }
  508   1          DBG_FLOW("\n-------Get Base-----");    
  509   1      }
  510          
  511          void DrvGetDiffdata(void)
  512          {
  513   1          UINT16  i;
  514   1          SINT16 XRAM diff;
  515   1          
  516   1          DBG_FLOW("\n-------Get differ-----");    
  517   1      
C251 COMPILER V5.54.0.0,  FlowFactory                                                      26/05/17  20:21:08  PAGE 9   

  518   1          for(i = 0; i < (CH_LEN_MAX)*2;i++)
  519   1          {        
  520   2              diff = g_usRawdataBuf[i]-g_usBaseBuf[i];
  521   2              if(i<400)
  522   2              {
  523   3                  if((i%18)==0)
  524   3                  {
  525   4                      DBG_FLOW("\n");
  526   4                  }
  527   3                  DBG_FLOW("%05d ",diff);
  528   3              }
  529   2          }
  530   1      }
  531          
  532          void DrvInitAram(void)
  533          {
  534   1          UINT16  i;
  535   1      
  536   1          ARAM_SEL = 1;
  537   1          EA = 0;
  538   1      
  539   1          g_ucAram = (UINT16)ARAM_DATA_BASE_ADDR; 
  540   1          
  541   1          // TP Rawdata + Key 
  542   1          for(i = 0; i < (CH_LEN_MAX)*2;i++)  // (324+4)*2  324,324,4,4
  543   1          {  
  544   2              g_ucAram[i] = 0;
  545   2          }
  546   1          EA = 1;
  547   1          ARAM_SEL = 0;
  548   1      }     
  549          
  550          void DrvGetAramData(void)
  551          {
  552   1          UINT16  i;
  553   1      
  554   1          ARAM_SEL = 1;
  555   1          EA = 0;
  556   1      
  557   1          ap0 = (UINT16)ARAM_DATA_BASE_ADDR; 
  558   1         
  559   1          // TP Rawdata
  560   1          for(i = 0; i < (CH_ORDER_MAX)*2;i++)
  561   1          {
  562   2              EA = 1;
  563   2              g_usRawdataBuf[i] = ap0[i];
  564   2          }
  565   1      
  566   1          // KEY rawdata 最后8个数据放key, 左右各4个，只用一边。
  567   1          for(i = 0;i < 8; i++)
  568   1          {
  569   2              g_usRawdataBuf[CH_ORDER_MAX*2 + i] = ap0[CH_ORDER_MAX*2 + i];
  570   2          }
  571   1          
  572   1          // Info信息
  573   1          for(i = 0;i < 6; i++)
  574   1          {
  575   2              g_usInfo[i] = ap0[CH_ORDER_MAX*2 + 8 + i];
  576   2          }
  577   1          
  578   1          ARAM_SEL = 0;
  579   1          EA = 1;
  580   1      }
  581          
  582          void DrvGetRawdata(void)
  583          {
C251 COMPILER V5.54.0.0,  FlowFactory                                                      26/05/17  20:21:08  PAGE 10  

  584   1          UINT16  i;
  585   1      
  586   1          ARAM_SEL = 1;
  587   1          EA = 0;
  588   1      
  589   1          ap0 = (UINT16)ARAM_DATA_BASE_ADDR; 
  590   1          
  591   1          // TP Rawdata
  592   1          for(i = 0; i < (CH_ORDER_MAX)*2;i++)
  593   1          {
  594   2              EA = 1;
  595   2              g_usRawdataBuf[i] = ap0[i];
  596   2              if(i<CH_ORDER_MAX)
  597   2              {
  598   3                  if((i%(RX_NUM/2)) == 0)  
  599   3                  //if((i%(30)) == 0)  
  600   3                  {
  601   4                      DBG_FLOW("\n ");   
  602   4                  }
  603   3                  DBG_FLOW("%04x ",g_usRawdataBuf[i]);
  604   3              }
  605   2          }
  606   1      
  607   1          // KEY rawdata 最后8个数据放key, 左右各4个，只用一边。
  608   1          DBG_FLOW("\n ");
  609   1          for(i = 0;i < 8; i++)
  610   1          {
  611   2              g_usRawdataBuf[CH_ORDER_MAX*2 + i] = ap0[CH_ORDER_MAX*2 + i];
  612   2              DBG_FLOW("Key%d :%05x ",i,g_usRawdataBuf[CH_ORDER_MAX*2 + i]);
  613   2          }
  614   1          
  615   1          // Info信息
  616   1          DBG_FLOW("\n ");
  617   1          for(i = 0;i < 6; i++)
  618   1          {
  619   2              g_usInfo[i] = ap0[CH_ORDER_MAX*2 + 8 + i];
  620   2              DBG_FLOW("Info%d:%05x ",i,g_usInfo[i]);
  621   2          }
  622   1          
  623   1          ARAM_SEL = 0;
  624   1          EA = 1;
  625   1      }
  626          
  627          
  628          /*******************************************************************************
  629          *   Name: DrvGetRptRamRawBase
  630          *  Brief: 地址: 0-323: Tp通道与Key键上报Rawdata所需的Order
  631          *         地址: 324-651: Tp通道 Rawdata/Base 
  632          *  Input: 
  633          * Output: 
  634          * Return: 
  635          *******************************************************************************/
  636          void DrvGetRptRamRawBase(void)
  637          {
  638   1          UINT16 XRAM j;
  639   1          UINT16 XRAM i;
  640   1      //    SINT16 XRAM diff;
  641   1          static UINT16 XRAM getBaseCount = 0;    
  642   1          UINT16 XRAM ausBaseBufL[BASE_RAM_BASE_LEN + BASE_RAM_KEY_LEN]; // Base + 4key
  643   1          UINT16 XRAM ausBaseBufR[BASE_RAM_BASE_LEN + BASE_RAM_KEY_LEN]; // Base + 4key
  644   1      
  645   1          DrvAfeSelTaborRepRam(AREA_BASE_ORDER);
  646   1          
  647   1          Drv_XsiRead(pXSI0Regs, BASE_RAM_START_ADDR + BASE_RAM_TP_RAWBASE_ADDR, ausBaseBufL,CH_LEN_MAX, AFE_RE
             -G);  
  648   1          Drv_XsiRead(pXSI1Regs, BASE_RAM_START_ADDR + BASE_RAM_TP_RAWBASE_ADDR, ausBaseBufR,CH_LEN_MAX, AFE_RE
C251 COMPILER V5.54.0.0,  FlowFactory                                                      26/05/17  20:21:08  PAGE 11  

             -G);  
  649   1      
  650   1          DBG_FLOW("\n---------DrvGet Rpt Ram ----------------------");
  651   1      //    if(getBaseCount<60)
  652   1          {
  653   2              for(j = 0;j <CH_LEN_MAX;j++) //左边
  654   2              {
  655   3                  if((j%18)==0)
  656   3                  {
  657   4                      DBG_FLOW("\n");
  658   4                  }
  659   3                
  660   3                  //if(j>=(CH_LEN_MAX-4))
  661   3                  //{
  662   3                      DBG_FLOW("%04x ",ausBaseBufL[j]);
  663   3                  //}  
  664   3                 
  665   3              }
  666   2      #if 0  //右边  
                       for(j = 0;j <CH_LEN_MAX;j++)//右边
                       {
                           if((j%18)==0)
                           {
                               DBG_FLOW("\n");
                           }
                           DBG_FLOW("%04x ",ausBaseBufR[j]);
                       } 
               #endif        
  676   2              getBaseCount++;
  677   2              DBG_FLOW("\n%04d",getBaseCount);
  678   2          }
  679   1      
  680   1          if(getBaseCount == 50)// Base
  681   1          {        
  682   2              for(i = 0;i <CH_LEN_MAX;i++)
  683   2              {
  684   3                  g_usBaseBuf[i] = ausBaseBufL[i]; 
  685   3                  if((i%18)==0)
  686   3                  {
  687   4                      DBG_FLOW("\n");
  688   4                  }
  689   3                  DBG_FLOW("%04x ",g_usBaseBuf[i]);
  690   3              }
  691   2          
  692   2              for(i = 0;i <CH_LEN_MAX;i++)
  693   2              {
  694   3                  g_usBaseBuf[i+CH_LEN_MAX] = ausBaseBufR[i];
  695   3                  if((i%18)==0)
  696   3                  {
  697   4                      DBG_FLOW("\n");
  698   4                  }
  699   3                  DBG_FLOW("%04x ",g_usBaseBuf[i+CH_LEN_MAX]);
  700   3              } 
  701   2          }
  702   1      
  703   1      #if 0    //differ
                   else if(getBaseCount>50)
                   {
                       for(i = 0;i <CH_LEN_MAX;i++)
                       {
                           diff = ausBaseBufL[i]-g_usBaseBuf[i]; 
                           if((i%18)==0)
                           {
                               DBG_FLOW("\n");
                           }
                           DBG_FLOW("%04d ",diff);
C251 COMPILER V5.54.0.0,  FlowFactory                                                      26/05/17  20:21:08  PAGE 12  

                       }
               #if 0
                       for(i = 0;i <CH_LEN_MAX;i++)
                       {
                           diff = ausBaseBufR[i]- g_usBaseBuf[i+CH_LEN_MAX];
                           if((i%30)==0)
                           {
                               DBG_FLOW("\n");
                           }
                           DBG_FLOW("%04d ",diff);
                       } 
               #endif
                   }  
               #endif
  728   1          
  729   1      }
  730          
  731          /*******************************************************************************
  732          *   Name: Afe_Clk_Init
  733          *  Brief: Afe时钟初始化
  734          *  Input: 
  735          * Output: 
  736          * Return: 
  737          *******************************************************************************/
  738          void Afe_Clk_Init(void)
  739          {  
  740   1          AFEACKEN = 1;    
  741   1          AFECKEN  = 1;   
  742   1          AFESCKEN = 1;
  743   1          ARAM_SEL = 0;  //0: afe控制aram 
  744   1        
  745   1          
  746   1      #if 0 //Close Clk
               //    AFEACKEN = 0;    
               //    AFECKEN  = 0;  
                   AFESCKEN = 0;   //FPGA版本 关闭无效
               #endif
  751   1      }
  752          
  753          /*******************************************************************************
  754          *   Name: Afe_Order_Init
  755          *  Brief: 重排序表初始化
  756          *  Input: 
  757          * Output: 
  758          * Return: 
  759          *******************************************************************************/
  760          void Afe_Order_Init(void)
  761          {
  762   1      #if 1
  763   1          SINT16 i;
  764   1          UINT16 len;
  765   1          UINT16 XRAM Buf[CH_ORDER_MAX];
  766   1      
  767   1          //左半屏Order
  768   1          for(i = 0; i<CH_ORDER_MAX; i++)
  769   1          {
  770   2             g_ucOrderBuf[i] = i; //0- 287/323
  771   2          }
  772   1      
  773   1          //右半屏Order
  774   1          for(i = 0; i <CH_ORDER_MAX; i++)
  775   1          {
  776   2             g_ucOrderBuf[i+CH_ORDER_MAX] = ((CH_ORDER_MAX-1)-i); // 287/323 -0
  777   2          }
  778   1          
  779   1          DrvAfeSelTaborRepRam(AREA_BASE_ORDER);
C251 COMPILER V5.54.0.0,  FlowFactory                                                      26/05/17  20:21:08  PAGE 13  

  780   1      
  781   1          //按照Order Ram字节配置
  782   1          len = CH_ORDER_MAX;
  783   1          for (i = 0; i < len; i++)
  784   1          {
  785   2             //Buf[i] = ((i*2+1+3)<<8)+i*2+3;                      //  正序   3开始--290结束 
  786   2             //Buf[i] = (g_ucOrderBuf[i*2+1]<<8)+g_ucOrderBuf[i*2];  //  值: 04_03;06_05...226_225...290_289 
  787   2             Buf[i] = g_ucOrderBuf[i];  //  值: 04_03;06_05...226_225...290_289        
  788   2          }
  789   1          Drv_XsiWrite(pXSI0Regs,256,Buf,len,AFE_REG);
  790   1          Drv_XsiWrite(pXSI1Regs,256,Buf,len,AFE_REG);        //左右同序
  791   1      
  792   1          
  793   1          len = CH_ORDER_MAX;
  794   1          for (i = 0; i < len; i++)
  795   1          {
  796   2             //Buf[i] = (111-i)*2+3 + (((111-i)*2+1+3)<<8);                                                    
             - // 反序   290开始--3结束 
  797   2             //Buf[i] = (g_ucOrderBuf[((CH_ORDER_MAX/2-1)-i)*2 +1]<<8)+(g_ucOrderBuf[((CH_ORDER_MAX/2-1)-i)*2])
             -;  //值:290_289.. 226_225; 224_223...04_03
  798   2             Buf[i] = g_ucOrderBuf[(CH_ORDER_MAX-1)-i];            //值:290_289.. 226_225; 224_223...04_03
  799   2          }
  800   1      //    Drv_XsiWrite(pXSI0Regs,256,Buf,len,AFE_REG);       //左反序
  801   1      //    Drv_XsiWrite(pXSI1Regs,256,Buf,len,AFE_REG);     //左右反序
  802   1      
  803   1      #else // 跳序测试order表 324-9
                   SINT16 i;
                   UINT16 Order = 0;
                   UINT16 len;
                   UINT16 XRAM Buf[CH_ORDER_MAX];
               
                   //半屏Order
                   for(i = 0; i<CH_ORDER_MAX; i++)
                   {
                      g_ucOrderBuf[i] = i; //0- 323
                   }
               
                   DrvAfeSelTaborRepRam(AREA_BASE_ORDER);
               
                   //按照Order Ram字节配置
                   len = CH_ORDER_MAX;
                   for (i = 0; i < len; i++)
                   {
               #if 1    
                      if((Order%36)== 0) //通道1,37,73,109,145,181,217,253,289，对应order号减1，即通道1表示order0
                      {
                          Order++; 
                          len--;
                      }
               #endif
                      Buf[i] = g_ucOrderBuf[Order];  //  
                      Order++;
                   }
                   Drv_XsiWrite(pXSI0Regs,256,Buf,len,AFE_REG);
                   Drv_XsiWrite(pXSI1Regs,256,Buf,len,AFE_REG);        //左右同序
               #endif
  834   1      
  835   1      
  836   1      #if 0 // 读取重排序表是否配置正确
                   for (i = 0; i < len; i++)
                   {
                      Buf[i] = 0;
                   }
                   Drv_XsiRead(pXSI0Regs,256,Buf,len,AFE_REG);
                   for (i = 0; i < len; i++)
                   {
C251 COMPILER V5.54.0.0,  FlowFactory                                                      26/05/17  20:21:08  PAGE 14  

                       DBG_FLOW("\nRegL[%02d] =  %04d",i,Buf[i]);
                   }
                   
                   Drv_XsiRead(pXSI1Regs,256,Buf,len,AFE_REG);
                   for (i = 0; i < len; i++)
                   {
                       DBG_FLOW("\nRegR[%02d] =  %04d",i,Buf[i]);
                   }
                   while(1);
               #endif
  854   1      }
  855          
  856          
  857          
  858          /*******************************************************************************
  859          *   Name: Afe_Table_Init
  860          *  Brief: Afe Tab Ram初始化，通道使能打开，CB初始值配置为0。
  861          *  Input: 
  862          * Output: 
  863          * Return: 
  864          *******************************************************************************/
  865          void Afe_Table_Init()
  866          {
  867   1          UINT8 i;
  868   1          UINT16 XRAM aus_tabbuf[TAB_RAM_LEN];
  869   1      
  870   1          memset(aus_tabbuf, 0, TAB_RAM_LEN*2);
  871   1      
  872   1          /* set Ch enable, set CB 0*/ 
  873   1          for(i = TAB_TP_KEY_CB_START_ADDR ;i<TAB_RAM_LEN;i++)
  874   1          {
  875   2              aus_tabbuf[i] = 0x4040;   // [6]:EN  [5:0]:CB
  876   2          }
  877   1      #if TEMP_CLOSE_KEY
                   aus_tabbuf[TAB_TP_KEY_CB_START_ADDR + 0] = 0x0;      //4个按键:  Key0-3  [8]:EN [7:0]:CB
                   aus_tabbuf[TAB_TP_KEY_CB_START_ADDR + 1] = 0x0;      
                   aus_tabbuf[TAB_TP_KEY_CB_START_ADDR + 2] = 0x0;
                   aus_tabbuf[TAB_TP_KEY_CB_START_ADDR + 3] = 0x0;
               #else
  883   1          aus_tabbuf[TAB_TP_KEY_CB_START_ADDR + 0] = 0x0100;      //4个按键:  Key0-3  [8]:EN [7:0]:CB
  884   1          aus_tabbuf[TAB_TP_KEY_CB_START_ADDR + 1] = 0x0100;      
  885   1          aus_tabbuf[TAB_TP_KEY_CB_START_ADDR + 2] = 0x0100;
  886   1          aus_tabbuf[TAB_TP_KEY_CB_START_ADDR + 3] = 0x0100;
  887   1      #endif    
  888   1      
  889   1          /* set ram buf as tab ram: */
  890   1          DrvAfeSelTaborRepRam(AREA_TBL_RAM);
  891   1      
  892   1          for (i = 0;i < 4;i++)
  893   1          { 
  894   2              Drv_XsiWrite(pXSI0Regs,256+i*TAB_RAM_LEN,aus_tabbuf,TAB_RAM_LEN,AFE_REG);
  895   2              Drv_XsiWrite(pXSI1Regs,256+i*TAB_RAM_LEN,aus_tabbuf,TAB_RAM_LEN,AFE_REG);
  896   2          }
  897   1      }
  898          
  899          /*******************************************************************************
  900          *   Name: Afe_Config_Init
  901          *  Brief: Afe配置参数初始化
  902          *  Input: 
  903          * Output: 
  904          * Return: 
  905          *******************************************************************************/
  906          void Afe_Config_Init(void)
  907          {
  908   1          UINT16 ReadXSI0 = 0;
  909   1          UINT16 ReadXSI1 = 0;
C251 COMPILER V5.54.0.0,  FlowFactory                                                      26/05/17  20:21:08  PAGE 15  

  910   1      
  911   1      //    Drv_XsiWriteReg(pXSI0Regs, 0, 0x01, AFE_REG);
  912   1      //    Drv_XsiWriteReg(pXSI1Regs, 0, 0x01, AFE_REG);
  913   1      
  914   1      //    ReadXSI0 = Drv_XsiReadReg(pXSI0Regs,0x00,AFE_REG);
  915   1      //    ReadXSI1 = Drv_XsiReadReg(pXSI1Regs,0x00,AFE_REG);
  916   1      //    DBG_FLOW("\nReg%d 0x%x  0x%x ",0x00,ReadXSI0,ReadXSI1);
  917   1      
  918   1          Drv_XsiWriteReg(pXSI0Regs, Addr_PANEL_MODE_CFG0, rPANEL_MODE_CFG0, AFE_REG);
  919   1          Drv_XsiWriteReg(pXSI1Regs, Addr_PANEL_MODE_CFG0, rPANEL_MODE_CFG0, AFE_REG);
  920   1              
  921   1          Drv_XsiWriteReg(pXSI0Regs, Addr_PANEL_MODE_CFG1, rPANEL_MODE_CFG1, AFE_REG);
  922   1          Drv_XsiWriteReg(pXSI1Regs, Addr_PANEL_MODE_CFG1, rPANEL_MODE_CFG1, AFE_REG);
  923   1      
  924   1          Drv_XsiWriteReg(pXSI0Regs, Addr_PANEL_MODE_CFG2, rPANEL_MODE_CFG2, AFE_REG);
  925   1          Drv_XsiWriteReg(pXSI1Regs, Addr_PANEL_MODE_CFG2, rPANEL_MODE_CFG2, AFE_REG);
  926   1      
  927   1          Drv_XsiWriteReg(pXSI0Regs, Addr_AFE_SYS_CFG0, rAFE_SYS_CFG0, AFE_REG);
  928   1          Drv_XsiWriteReg(pXSI1Regs, Addr_AFE_SYS_CFG0, rAFE_SYS_CFG0, AFE_REG);
  929   1         
  930   1          Drv_XsiWriteReg(pXSI0Regs, Addr_AFE_SYS_CFG1, rAFE_SYS_CFG1, AFE_REG);
  931   1          Drv_XsiWriteReg(pXSI1Regs, Addr_AFE_SYS_CFG1, rAFE_SYS_CFG1, AFE_REG);
  932   1      
  933   1          Drv_XsiWriteReg(pXSI0Regs, Addr_AFE_SCAN_CFG0, rAFE_SCAN_CFG0, AFE_REG);
  934   1          Drv_XsiWriteReg(pXSI1Regs, Addr_AFE_SCAN_CFG0, rAFE_SCAN_CFG0, AFE_REG);
  935   1      
  936   1          Drv_XsiWriteReg(pXSI0Regs, Addr_AFE_SCAN_CFG1, rAFE_SCAN_CFG1, AFE_REG);
  937   1          Drv_XsiWriteReg(pXSI1Regs, Addr_AFE_SCAN_CFG1, rAFE_SCAN_CFG1, AFE_REG);
  938   1      
  939   1          Drv_XsiWriteReg(pXSI0Regs, Addr_AFE_DUMMY_SCAN_CFG, rAFE_DUMMY_SCAN_CFG, AFE_REG);
  940   1          Drv_XsiWriteReg(pXSI1Regs, Addr_AFE_DUMMY_SCAN_CFG, rAFE_DUMMY_SCAN_CFG, AFE_REG);
  941   1      
  942   1          Drv_XsiWriteReg(pXSI0Regs, Addr_AFE_BASE_TRACK_CFG, rAFE_BASE_TRACK_CFG, AFE_REG);
  943   1          Drv_XsiWriteReg(pXSI1Regs, Addr_AFE_BASE_TRACK_CFG, rAFE_BASE_TRACK_CFG, AFE_REG);
  944   1      
  945   1          Drv_XsiWriteReg(pXSI0Regs, Addr_ACC_OFFSET, rACC_OFFSET, AFE_REG);
  946   1          Drv_XsiWriteReg(pXSI1Regs, Addr_ACC_OFFSET, rACC_OFFSET, AFE_REG);
  947   1      
  948   1          Drv_XsiWriteReg(pXSI0Regs, Addr_TP_MONITOR_THRESHOLD, rTP_MONITOR_THRESHOLD, AFE_REG);
  949   1          Drv_XsiWriteReg(pXSI1Regs, Addr_TP_MONITOR_THRESHOLD, rTP_MONITOR_THRESHOLD, AFE_REG);
  950   1      
  951   1          Drv_XsiWriteReg(pXSI0Regs, Addr_KEY_MONITOR_THRESHOLD, rKEY_MONITOR_THRESHOLD, AFE_REG);
  952   1          Drv_XsiWriteReg(pXSI1Regs, Addr_KEY_MONITOR_THRESHOLD, rKEY_MONITOR_THRESHOLD, AFE_REG);
  953   1      
  954   1          Drv_XsiWriteReg(pXSI0Regs, Addr_AFE_ANA_K1_CFG0, rAFE_ANA_K1_CFG0, AFE_REG);
  955   1          Drv_XsiWriteReg(pXSI1Regs, Addr_AFE_ANA_K1_CFG0, rAFE_ANA_K1_CFG0, AFE_REG);
  956   1      
  957   1          Drv_XsiWriteReg(pXSI0Regs, Addr_AFE_ANA_K2_CFG1, rAFE_ANA_K2_CFG1, AFE_REG);
  958   1          Drv_XsiWriteReg(pXSI1Regs, Addr_AFE_ANA_K2_CFG1, rAFE_ANA_K2_CFG1, AFE_REG);
  959   1      
  960   1          Drv_XsiWriteReg(pXSI0Regs, Addr_AFE_ANA_CA_CFG0, rAFE_ANA_CA_CFG0, AFE_REG);
  961   1          Drv_XsiWriteReg(pXSI1Regs, Addr_AFE_ANA_CA_CFG0, rAFE_ANA_CA_CFG0, AFE_REG);
  962   1      
  963   1          Drv_XsiWriteReg(pXSI0Regs, Addr_AFE_ANA_CA_CFG1, rAFE_ANA_CA_CFG1, AFE_REG);
  964   1          Drv_XsiWriteReg(pXSI1Regs, Addr_AFE_ANA_CA_CFG1, rAFE_ANA_CA_CFG1, AFE_REG);
  965   1      
  966   1          Drv_XsiWriteReg(pXSI0Regs, Addr_AFE_ANA_CA_CFG2, rAFE_ANA_CA_CFG2, AFE_REG);
  967   1          Drv_XsiWriteReg(pXSI1Regs, Addr_AFE_ANA_CA_CFG2, rAFE_ANA_CA_CFG2, AFE_REG);
  968   1      
  969   1          Drv_XsiWriteReg(pXSI0Regs, Addr_AFE_ANA_P1_P2_CFG0, rAFE_ANA_P1_P2_CFG0, AFE_REG);
  970   1          Drv_XsiWriteReg(pXSI1Regs, Addr_AFE_ANA_P1_P2_CFG0, rAFE_ANA_P1_P2_CFG0, AFE_REG);
  971   1      
  972   1          Drv_XsiWriteReg(pXSI0Regs, Addr_AFE_ANA_P1_P2_CFG1, rAFE_ANA_P1_P2_CFG1, AFE_REG);
  973   1          Drv_XsiWriteReg(pXSI1Regs, Addr_AFE_ANA_P1_P2_CFG1, rAFE_ANA_P1_P2_CFG1, AFE_REG);
  974   1      
  975   1          Drv_XsiWriteReg(pXSI0Regs, Addr_AFE_ANA_P1_P2_CFG2, rAFE_ANA_P1_P2_CFG2, AFE_REG);
C251 COMPILER V5.54.0.0,  FlowFactory                                                      26/05/17  20:21:08  PAGE 16  

  976   1          Drv_XsiWriteReg(pXSI1Regs, Addr_AFE_ANA_P1_P2_CFG2, rAFE_ANA_P1_P2_CFG2, AFE_REG);
  977   1      
  978   1          Drv_XsiWriteReg(pXSI0Regs, Addr_AFE_ANA_P1_P2_CFG3, rAFE_ANA_P1_P2_CFG3, AFE_REG);
  979   1          Drv_XsiWriteReg(pXSI1Regs, Addr_AFE_ANA_P1_P2_CFG3, rAFE_ANA_P1_P2_CFG3, AFE_REG);
  980   1      
  981   1          Drv_XsiWriteReg(pXSI0Regs, Addr_AFE_ANA_P1_P2_CFG4, rAFE_ANA_P1_P2_CFG4, AFE_REG);
  982   1          Drv_XsiWriteReg(pXSI1Regs, Addr_AFE_ANA_P1_P2_CFG4, rAFE_ANA_P1_P2_CFG4, AFE_REG);
  983   1      
  984   1          Drv_XsiWriteReg(pXSI0Regs, Addr_AFE_ANA_P1_P2_CFG5, rAFE_ANA_P1_P2_CFG5, AFE_REG);
  985   1          Drv_XsiWriteReg(pXSI1Regs, Addr_AFE_ANA_P1_P2_CFG5, rAFE_ANA_P1_P2_CFG5, AFE_REG);
  986   1      
  987   1          Drv_XsiWriteReg(pXSI0Regs, Addr_AFE_P1_P2_DLY_CFG0, rAFE_P1_P2_DLY_CFG0, AFE_REG);
  988   1          Drv_XsiWriteReg(pXSI1Regs, Addr_AFE_P1_P2_DLY_CFG0, rAFE_P1_P2_DLY_CFG0, AFE_REG);
  989   1      
  990   1          Drv_XsiWriteReg(pXSI0Regs, Addr_AFE_P1_P2_DLY_CFG1, rAFE_P1_P2_DLY_CFG1, AFE_REG);
  991   1          Drv_XsiWriteReg(pXSI1Regs, Addr_AFE_P1_P2_DLY_CFG1, rAFE_P1_P2_DLY_CFG1, AFE_REG);
  992   1      
  993   1          Drv_XsiWriteReg(pXSI0Regs, Addr_AFE_ANA_SH_CFG0, rAFE_ANA_SH_CFG0, AFE_REG);
  994   1          Drv_XsiWriteReg(pXSI1Regs, Addr_AFE_ANA_SH_CFG0, rAFE_ANA_SH_CFG0, AFE_REG);
  995   1      
  996   1          Drv_XsiWriteReg(pXSI0Regs, Addr_AFE_ANA_SH_CFG1, rAFE_ANA_SH_CFG1, AFE_REG);
  997   1          Drv_XsiWriteReg(pXSI1Regs, Addr_AFE_ANA_SH_CFG1, rAFE_ANA_SH_CFG1, AFE_REG);
  998   1      
  999   1          Drv_XsiWriteReg(pXSI0Regs, Addr_AFE_ANA_SH_CFG2, rAFE_ANA_SH_CFG2, AFE_REG);
 1000   1          Drv_XsiWriteReg(pXSI1Regs, Addr_AFE_ANA_SH_CFG2, rAFE_ANA_SH_CFG2, AFE_REG);
 1001   1      
 1002   1          Drv_XsiWriteReg(pXSI0Regs, Addr_AFE_ANA_SH_CFG3, rAFE_ANA_SH_CFG3, AFE_REG);
 1003   1          Drv_XsiWriteReg(pXSI1Regs, Addr_AFE_ANA_SH_CFG3, rAFE_ANA_SH_CFG3, AFE_REG);
 1004   1      
 1005   1          Drv_XsiWriteReg(pXSI0Regs, Addr_AFE_ANA_SH_CFG4, rAFE_ANA_SH_CFG4, AFE_REG);
 1006   1          Drv_XsiWriteReg(pXSI1Regs, Addr_AFE_ANA_SH_CFG4, rAFE_ANA_SH_CFG4, AFE_REG);
 1007   1          
 1008   1          Drv_XsiWriteReg(pXSI0Regs, Addr_AFE_ANA_SH_CFG5, rAFE_ANA_SH_CFG5, AFE_REG);
 1009   1          Drv_XsiWriteReg(pXSI1Regs, Addr_AFE_ANA_SH_CFG5, rAFE_ANA_SH_CFG5, AFE_REG);
 1010   1          
 1011   1          Drv_XsiWriteReg(pXSI0Regs, Addr_AFE_ANA_SH_CFG6, rAFE_ANA_SH_CFG6, AFE_REG);
 1012   1          Drv_XsiWriteReg(pXSI1Regs, Addr_AFE_ANA_SH_CFG6, rAFE_ANA_SH_CFG6, AFE_REG);
 1013   1      
 1014   1          Drv_XsiWriteReg(pXSI0Regs, Addr_AFE_ANA_ADC_CFG0, rAFE_ANA_ADC_CFG0, AFE_REG);
 1015   1          Drv_XsiWriteReg(pXSI1Regs, Addr_AFE_ANA_ADC_CFG0, rAFE_ANA_ADC_CFG0, AFE_REG);
 1016   1      
 1017   1          Drv_XsiWriteReg(pXSI0Regs, Addr_AFE_ANA_ADC_CFG1, rAFE_ANA_ADC_CFG1, AFE_REG);
 1018   1          Drv_XsiWriteReg(pXSI1Regs, Addr_AFE_ANA_ADC_CFG1, rAFE_ANA_ADC_CFG1, AFE_REG);
 1019   1      
 1020   1          Drv_XsiWriteReg(pXSI0Regs, Addr_AFE_ANA_ADC_CFG2, rAFE_ANA_ADC_CFG2, AFE_REG);
 1021   1          Drv_XsiWriteReg(pXSI1Regs, Addr_AFE_ANA_ADC_CFG2, rAFE_ANA_ADC_CFG2, AFE_REG);
 1022   1      
 1023   1          Drv_XsiWriteReg(pXSI0Regs, Addr_AFE_ANA_ADC_CFG3, rAFE_ANA_ADC_CFG3, AFE_REG);
 1024   1          Drv_XsiWriteReg(pXSI1Regs, Addr_AFE_ANA_ADC_CFG3, rAFE_ANA_ADC_CFG3, AFE_REG);
 1025   1      
 1026   1          Drv_XsiWriteReg(pXSI0Regs, Addr_AFE_GIPH_P1_P2_CFG, rAFE_GIPH_P1_P2_CFG, AFE_REG);
 1027   1          Drv_XsiWriteReg(pXSI1Regs, Addr_AFE_GIPH_P1_P2_CFG, rAFE_GIPH_P1_P2_CFG, AFE_REG);
 1028   1          
 1029   1          Drv_XsiWriteReg(pXSI0Regs, Addr_AFE_GIPL_P1_P2_CFG, rAFE_GIPL_P1_P2_CFG, AFE_REG);
 1030   1          Drv_XsiWriteReg(pXSI1Regs, Addr_AFE_GIPL_P1_P2_CFG, rAFE_GIPL_P1_P2_CFG, AFE_REG);
 1031   1      
 1032   1          Drv_XsiWriteReg(pXSI0Regs, Addr_AFE_SD_VOM_OPT_P1_P2_CFG, rAFE_SD_VOM_OPT_P1_P2_CFG, AFE_REG);
 1033   1          Drv_XsiWriteReg(pXSI1Regs, Addr_AFE_SD_VOM_OPT_P1_P2_CFG, rAFE_SD_VOM_OPT_P1_P2_CFG, AFE_REG);
 1034   1      
 1035   1          Drv_XsiWriteReg(pXSI0Regs, Addr_AFE_SX_P1_P2_CFG, rAFE_SX_P1_P2_CFG, AFE_REG);
 1036   1          Drv_XsiWriteReg(pXSI1Regs, Addr_AFE_SX_P1_P2_CFG, rAFE_SX_P1_P2_CFG, AFE_REG);
 1037   1      
 1038   1      //41
 1039   1          Drv_XsiWriteReg(pXSI0Regs, Addr_AFE_MOUT_GIPH_CFG, rAFE_MOUT_GIPH_CFG, AFE_REG);
 1040   1          Drv_XsiWriteReg(pXSI1Regs, Addr_AFE_MOUT_GIPH_CFG, rAFE_MOUT_GIPH_CFG, AFE_REG);
 1041   1      
C251 COMPILER V5.54.0.0,  FlowFactory                                                      26/05/17  20:21:08  PAGE 17  

 1042   1          Drv_XsiWriteReg(pXSI0Regs, Addr_AFE_MOUT_GIPL_CFG, rAFE_MOUT_GIPL_CFG, AFE_REG);
 1043   1          Drv_XsiWriteReg(pXSI1Regs, Addr_AFE_MOUT_GIPL_CFG, rAFE_MOUT_GIPL_CFG, AFE_REG);
 1044   1      
 1045   1          Drv_XsiWriteReg(pXSI0Regs, Addr_AFE_GOUT_GIPH_CFG, rAFE_GOUT_GIPH_CFG, AFE_REG);
 1046   1          Drv_XsiWriteReg(pXSI1Regs, Addr_AFE_GOUT_GIPH_CFG, rAFE_GOUT_GIPH_CFG, AFE_REG);
 1047   1      
 1048   1          Drv_XsiWriteReg(pXSI0Regs, Addr_AFE_GOUT_GIPL_CFG, rAFE_GOUT_GIPL_CFG, AFE_REG);
 1049   1          Drv_XsiWriteReg(pXSI1Regs, Addr_AFE_GOUT_GIPL_CFG, rAFE_GOUT_GIPL_CFG, AFE_REG);
 1050   1      //
 1051   1          
 1052   1      
 1053   1          Drv_XsiWriteReg(pXSI0Regs, Addr_ALL_GATE_ON_L_CFG, rALL_GATE_ON_L_CFG, AFE_REG);
 1054   1          Drv_XsiWriteReg(pXSI1Regs, Addr_ALL_GATE_ON_L_CFG, rALL_GATE_ON_L_CFG, AFE_REG);
 1055   1      
 1056   1          Drv_XsiWriteReg(pXSI0Regs, Addr_ALL_GATE_OFF_L_CFG, rALL_GATE_OFF_L_CFG, AFE_REG);
 1057   1          Drv_XsiWriteReg(pXSI1Regs, Addr_ALL_GATE_OFF_L_CFG, rALL_GATE_OFF_L_CFG, AFE_REG);
 1058   1      
 1059   1          Drv_XsiWriteReg(pXSI0Regs, Addr_ALL_GATE_STOP_L_CFG, rALL_GATE_STOP_L_CFG, AFE_REG);
 1060   1          Drv_XsiWriteReg(pXSI1Regs, Addr_ALL_GATE_STOP_L_CFG, rALL_GATE_STOP_L_CFG, AFE_REG);
 1061   1      
 1062   1          Drv_XsiWriteReg(pXSI0Regs, Addr_ALL_GATE_H_CFG, rALL_GATE_H_CFG, AFE_REG);
 1063   1          Drv_XsiWriteReg(pXSI1Regs, Addr_ALL_GATE_H_CFG, rALL_GATE_H_CFG, AFE_REG);
 1064   1      
 1065   1          Drv_XsiWriteReg(pXSI0Regs, Addr_RPT_RAWDATA_NUM, rRPT_RAWDATA_NUM, AFE_REG);
 1066   1          Drv_XsiWriteReg(pXSI1Regs, Addr_RPT_RAWDATA_NUM, rRPT_RAWDATA_NUM, AFE_REG);
 1067   1      
 1068   1          Drv_XsiWriteReg(pXSI0Regs, Addr_CB_ADJUST_THLD_TP, rCB_ADJUST_THLD_TP, AFE_REG);
 1069   1          Drv_XsiWriteReg(pXSI1Regs, Addr_CB_ADJUST_THLD_TP, rCB_ADJUST_THLD_TP, AFE_REG);
 1070   1      
 1071   1          Drv_XsiWriteReg(pXSI0Regs, Addr_TEST_MODE_FLAG, rTEST_MODE_FLAG, AFE_REG);
 1072   1          Drv_XsiWriteReg(pXSI1Regs, Addr_TEST_MODE_FLAG, rTEST_MODE_FLAG, AFE_REG);
 1073   1      
 1074   1          Drv_XsiWriteReg(pXSI0Regs, Addr_PRESCAN_TIME, rPRESCAN_TIME, AFE_REG);
 1075   1          Drv_XsiWriteReg(pXSI1Regs, Addr_PRESCAN_TIME, rPRESCAN_TIME, AFE_REG);
 1076   1      
 1077   1          Drv_XsiWriteReg(pXSI0Regs, Addr_DISCHARGE_TIME, rDISCHARGE_TIME, AFE_REG);
 1078   1          Drv_XsiWriteReg(pXSI1Regs, Addr_DISCHARGE_TIME, rDISCHARGE_TIME, AFE_REG);
 1079   1      
 1080   1          Drv_XsiWriteReg(pXSI0Regs, Addr_ANA_STATIC_CFG0, rANA_STATIC_CFG0, AFE_REG);
 1081   1          Drv_XsiWriteReg(pXSI1Regs, Addr_ANA_STATIC_CFG0, rANA_STATIC_CFG0, AFE_REG);
 1082   1      
 1083   1          Drv_XsiWriteReg(pXSI0Regs, Addr_ANA_STATIC_CFG1, rANA_STATIC_CFG1, AFE_REG);
 1084   1          Drv_XsiWriteReg(pXSI1Regs, Addr_ANA_STATIC_CFG1, rANA_STATIC_CFG1, AFE_REG);
 1085   1      
 1086   1          Drv_XsiWriteReg(pXSI0Regs, Addr_ANA_STATIC_CFG2, rANA_STATIC_CFG2, AFE_REG);
 1087   1          Drv_XsiWriteReg(pXSI1Regs, Addr_ANA_STATIC_CFG2, rANA_STATIC_CFG2, AFE_REG);
 1088   1      
 1089   1          Drv_XsiWriteReg(pXSI0Regs, Addr_ANA_STATIC_CFG3, rANA_STATIC_CFG3, AFE_REG);
 1090   1          Drv_XsiWriteReg(pXSI1Regs, Addr_ANA_STATIC_CFG3, rANA_STATIC_CFG3, AFE_REG);
 1091   1      
 1092   1          Drv_XsiWriteReg(pXSI0Regs, Addr_TEST_P0_CFG0, rTEST_P0_CFG0, AFE_REG);
 1093   1          Drv_XsiWriteReg(pXSI1Regs, Addr_TEST_P0_CFG0, rTEST_P0_CFG0, AFE_REG);
 1094   1      
 1095   1          Drv_XsiWriteReg(pXSI0Regs, Addr_TEST_P0_CFG1, rTEST_P0_CFG1, AFE_REG);
 1096   1          Drv_XsiWriteReg(pXSI1Regs, Addr_TEST_P0_CFG1, rTEST_P0_CFG1, AFE_REG);
 1097   1      
 1098   1          Drv_XsiWriteReg(pXSI0Regs, Addr_TEST_P0_CFG2, rTEST_P0_CFG2, AFE_REG);
 1099   1          Drv_XsiWriteReg(pXSI1Regs, Addr_TEST_P0_CFG2, rTEST_P0_CFG2, AFE_REG);
 1100   1      
 1101   1          Drv_XsiWriteReg(pXSI0Regs, Addr_TEST_P1_CFG0, rTEST_P1_CFG0, AFE_REG);
 1102   1          Drv_XsiWriteReg(pXSI1Regs, Addr_TEST_P1_CFG0, rTEST_P1_CFG0, AFE_REG);
 1103   1      
 1104   1          Drv_XsiWriteReg(pXSI0Regs, Addr_TEST_P1_CFG1, rTEST_P1_CFG1, AFE_REG);
 1105   1          Drv_XsiWriteReg(pXSI1Regs, Addr_TEST_P1_CFG1, rTEST_P1_CFG1, AFE_REG);
 1106   1      
 1107   1          Drv_XsiWriteReg(pXSI0Regs, Addr_TEST_P1_CFG2, rTEST_P1_CFG2, AFE_REG);
C251 COMPILER V5.54.0.0,  FlowFactory                                                      26/05/17  20:21:08  PAGE 18  

 1108   1          Drv_XsiWriteReg(pXSI1Regs, Addr_TEST_P1_CFG2, rTEST_P1_CFG2, AFE_REG);
 1109   1          
 1110   1      //  MCAP KEY
 1111   1          Drv_XsiWriteReg(pXSI0Regs, Addr_MCAP_SCAN_CFG, rMCAP_SCAN_CFG, AFE_REG);
 1112   1          Drv_XsiWriteReg(pXSI1Regs, Addr_MCAP_SCAN_CFG, rMCAP_SCAN_CFG, AFE_REG);
 1113   1          
 1114   1          Drv_XsiWriteReg(pXSI0Regs, Addr_MCAP_SCANSR, rMCAP_SCANSR, AFE_REG);
 1115   1          Drv_XsiWriteReg(pXSI1Regs, Addr_MCAP_SCANSR, rMCAP_SCANSR, AFE_REG);
 1116   1          
 1117   1          Drv_XsiWriteReg(pXSI0Regs, Addr_MCAP_LPFIR_SUM_NUM, DAT_MCAP_LPFIR_SUM_NUM, AFE_REG);
 1118   1          Drv_XsiWriteReg(pXSI1Regs, Addr_MCAP_LPFIR_SUM_NUM, DAT_MCAP_LPFIR_SUM_NUM, AFE_REG);
 1119   1          
 1120   1          Drv_XsiWriteReg(pXSI0Regs, Addr_RAWSHIFTCAF, rRAWSHIFTCAF, AFE_REG);
 1121   1          Drv_XsiWriteReg(pXSI1Regs, Addr_RAWSHIFTCAF, rRAWSHIFTCAF, AFE_REG);
 1122   1          
 1123   1          Drv_XsiWriteReg(pXSI0Regs, Addr_RAWDATA_OFFSET_L, rRAWDATA_OFFSET_L, AFE_REG);
 1124   1          Drv_XsiWriteReg(pXSI1Regs, Addr_RAWDATA_OFFSET_L, rRAWDATA_OFFSET_L, AFE_REG);
 1125   1      
 1126   1          Drv_XsiWriteReg(pXSI0Regs, Addr_ADC_CFG, rADC_CFG, AFE_REG);
 1127   1          Drv_XsiWriteReg(pXSI1Regs, Addr_ADC_CFG, rADC_CFG, AFE_REG);
 1128   1          
 1129   1          Drv_XsiWriteReg(pXSI0Regs, Addr_ADC_DATA0, rADC_DATA0, AFE_REG);
 1130   1          Drv_XsiWriteReg(pXSI1Regs, Addr_ADC_DATA0, rADC_DATA0, AFE_REG);
 1131   1          
 1132   1          Drv_XsiWriteReg(pXSI0Regs, Addr_MCAP_INIT_SAMPL_CFG, rMCAP_INIT_SAMPL_CFG, AFE_REG);
 1133   1          Drv_XsiWriteReg(pXSI1Regs, Addr_MCAP_INIT_SAMPL_CFG, rMCAP_INIT_SAMPL_CFG, AFE_REG);
 1134   1              
 1135   1          Drv_XsiWriteReg(pXSI0Regs, Addr_OVERFLOW_THR, rOVERFLOW_THR, AFE_REG);
 1136   1          Drv_XsiWriteReg(pXSI1Regs, Addr_OVERFLOW_THR, rOVERFLOW_THR, AFE_REG);
 1137   1          
 1138   1          Drv_XsiWriteReg(pXSI0Regs, Addr_UNDERFLOW_THR, rUNDERFLOW_THR, AFE_REG);
 1139   1          Drv_XsiWriteReg(pXSI1Regs, Addr_UNDERFLOW_THR, rUNDERFLOW_THR, AFE_REG);
 1140   1      
 1141   1          Drv_XsiWriteReg(pXSI0Regs, Addr_OVERFLOW_UPBOUND, rOVERFLOW_UPBOUND, AFE_REG);
 1142   1          Drv_XsiWriteReg(pXSI1Regs, Addr_OVERFLOW_UPBOUND, rOVERFLOW_UPBOUND, AFE_REG);
 1143   1          
 1144   1          Drv_XsiWriteReg(pXSI0Regs, Addr_OVER_POINT_FRAME, rOVER_POINT_FRAME, AFE_REG);
 1145   1          Drv_XsiWriteReg(pXSI1Regs, Addr_OVER_POINT_FRAME, rOVER_POINT_FRAME, AFE_REG);
 1146   1          
 1147   1          Drv_XsiWriteReg(pXSI0Regs, Addr_NORMAL_SIGNAL_UPTHR, rNORMAL_SIGNAL_UPTHR, AFE_REG);
 1148   1          Drv_XsiWriteReg(pXSI1Regs, Addr_NORMAL_SIGNAL_UPTHR, rNORMAL_SIGNAL_UPTHR, AFE_REG);
 1149   1          
 1150   1          Drv_XsiWriteReg(pXSI0Regs, Addr_NORMAL_SIGNAL_DWTHR, rNORMAL_SIGNAL_DWTHR, AFE_REG);
 1151   1          Drv_XsiWriteReg(pXSI1Regs, Addr_NORMAL_SIGNAL_DWTHR, rNORMAL_SIGNAL_DWTHR, AFE_REG);
 1152   1          
 1153   1          Drv_XsiWriteReg(pXSI0Regs, Addr_OVERFLOW_CLR_FRAMENUM, rOVERFLOW_CLR_FRAMENUM, AFE_REG);
 1154   1          Drv_XsiWriteReg(pXSI1Regs, Addr_OVERFLOW_CLR_FRAMENUM, rOVERFLOW_CLR_FRAMENUM, AFE_REG);
 1155   1          
 1156   1          Drv_XsiWriteReg(pXSI0Regs, Addr_MCAP_LPFIR_CFG, rMCAP_LPFIR_CFG, AFE_REG);
 1157   1          Drv_XsiWriteReg(pXSI1Regs, Addr_MCAP_LPFIR_CFG, rMCAP_LPFIR_CFG, AFE_REG);
 1158   1          
 1159   1          Drv_XsiWriteReg(pXSI0Regs, Addr_MCAP_LPFIR_COF0, rMCAP_LPFIR_COF0, AFE_REG);
 1160   1          Drv_XsiWriteReg(pXSI1Regs, Addr_MCAP_LPFIR_COF0, rMCAP_LPFIR_COF0, AFE_REG);
 1161   1          
 1162   1          Drv_XsiWriteReg(pXSI0Regs, Addr_MCAP_LPFIR_COF1, rMCAP_LPFIR_COF1, AFE_REG);
 1163   1          Drv_XsiWriteReg(pXSI1Regs, Addr_MCAP_LPFIR_COF1, rMCAP_LPFIR_COF1, AFE_REG);
 1164   1          
 1165   1          Drv_XsiWriteReg(pXSI0Regs, Addr_MCAP_LPFIR_COF2, rMCAP_LPFIR_COF2, AFE_REG);
 1166   1          Drv_XsiWriteReg(pXSI1Regs, Addr_MCAP_LPFIR_COF2, rMCAP_LPFIR_COF2, AFE_REG);
 1167   1      
 1168   1          Drv_XsiWriteReg(pXSI0Regs, Addr_MCAP_LPFIR_COF3, rMCAP_LPFIR_COF3, AFE_REG);
 1169   1          Drv_XsiWriteReg(pXSI1Regs, Addr_MCAP_LPFIR_COF3, rMCAP_LPFIR_COF3, AFE_REG);
 1170   1          
 1171   1          Drv_XsiWriteReg(pXSI0Regs, Addr_MCAP_LPFIR_COF4, rMCAP_LPFIR_COF4, AFE_REG);
 1172   1          Drv_XsiWriteReg(pXSI1Regs, Addr_MCAP_LPFIR_COF4, rMCAP_LPFIR_COF4, AFE_REG);
 1173   1          
C251 COMPILER V5.54.0.0,  FlowFactory                                                      26/05/17  20:21:08  PAGE 19  

 1174   1          Drv_XsiWriteReg(pXSI0Regs, Addr_MCAP_LPFIR_COF5, rMCAP_LPFIR_COF5, AFE_REG);
 1175   1          Drv_XsiWriteReg(pXSI1Regs, Addr_MCAP_LPFIR_COF5, rMCAP_LPFIR_COF5, AFE_REG);
 1176   1          
 1177   1          Drv_XsiWriteReg(pXSI0Regs, Addr_MCAP_LPFIR_COF6, rMCAP_LPFIR_COF6, AFE_REG);
 1178   1          Drv_XsiWriteReg(pXSI1Regs, Addr_MCAP_LPFIR_COF6, rMCAP_LPFIR_COF6, AFE_REG);
 1179   1          
 1180   1          Drv_XsiWriteReg(pXSI0Regs, Addr_MCAP_LPFIR_COF7, rMCAP_LPFIR_COF7, AFE_REG);
 1181   1          Drv_XsiWriteReg(pXSI1Regs, Addr_MCAP_LPFIR_COF7, rMCAP_LPFIR_COF7, AFE_REG);
 1182   1      
 1183   1          Drv_XsiWriteReg(pXSI0Regs, Addr_CB_ADJUST_THLD_KEY, rCB_ADJUST_THLD_KEY, AFE_REG);
 1184   1          Drv_XsiWriteReg(pXSI1Regs, Addr_CB_ADJUST_THLD_KEY, rCB_ADJUST_THLD_KEY, AFE_REG);  
 1185   1      
 1186   1      #if  TEST_GROUP_SEL1 
                   // Default:  MUX1: G1 G9  MUX2: G2  G8  MUX3: G3 G7  MUX4: G4 G6  MUX5: X G5
                   // Config:   MUX1: G1 G5  MUX2: G2  G6  MUX3: G3 G7  MUX4: G4 G8  MUX5: X G9
                   DrvAFEGroupSelReg1(0,0,1,1,2,2);
                   DrvAFEGroupSelReg2(3,3,4,4);
               #endif
 1192   1      #if  TEST_GROUP_SEL2 
                   // Default:  MUX1: G1 G9  MUX2: G2  G8  MUX3: G3 G7  MUX4: G4 G6  MUX5: X G5
                   // Config:   MUX1: G4 G5  MUX2: G3  G6  MUX3: G2 G7  MUX4: G1 G8  MUX5: X G9
                   DrvAFEGroupSelReg1(3,0,2,1,1,2);
                   DrvAFEGroupSelReg2(0,3,4,4);
               #endif
 1198   1      
 1199   1      #ifdef COF_MODE
 1200   1          DrvAfeEnCOF();
 1201   1          DrvAfeEnRawdataNum(CH_ORDER_MAX); //左右各324
 1202   1      //    DrvAfeEnRawdataNum(10);     // test   
 1203   1      //    DrvAfeEnRawdataNum(300);     // test  
 1204   1      //    DrvAfeEnRawdataNum(CH_ORDER_MAX-9);     // test order  跳序   
 1205   1      #endif
 1206   1      
 1207   1      #if  IS_4_MUX_MODE
                   DrvAfeEn4mux();
                   // Config:   MUX1: G1 G5  MUX2: G2  G6  MUX3: G3 G7  MUX4: G4 G8  MUX5: X G9
                   DrvAFEGroupSelReg1(0,0,1,1,2,2);
                   DrvAFEGroupSelReg2(3,3,4,4); // G5配置无效
               #endif
 1213   1          
 1214   1      }
 1215          
 1216          void Afe_Tab_Config(void)
 1217          {
 1218   1          XSICKEN = 1;
 1219   1          
 1220   1          Afe_Config_Tab0();
 1221   1          Afe_Config_Tab1();
 1222   1          Afe_Config_Tab2();
 1223   1          Afe_Config_Tab3();
 1224   1        
 1225   1      }
 1226          
 1227          /*******************************************************************************
 1228          *   Name: Afe_Init
 1229          *  Brief: 
 1230          *  Input: 
 1231          * Output: 
 1232          * Return: 
 1233          *******************************************************************************/
 1234          void Afe_Init(void)
 1235          {
 1236   1          Afe_Order_Init();
 1237   1          
 1238   1          Afe_Table_Init();
 1239   1          
C251 COMPILER V5.54.0.0,  FlowFactory                                                      26/05/17  20:21:08  PAGE 20  

 1240   1          Afe_Config_Init();
 1241   1      
 1242   1          Asm_Config_Init();
 1243   1      
 1244   1          Afe_Tab_Config();
 1245   1        
 1246   1          DBG_FLOW("\nAfe Init is OK");
 1247   1      
 1248   1      }
 1249          
 1250          /*******************************************************************************
 1251          *   Name: Afe_Free_Run
 1252          *  Brief: 
 1253          *  Input: 
 1254          * Output: 
 1255          * Return: 
 1256          *******************************************************************************/
 1257          void Afe_Free_Run(void)
 1258          {
 1259   1          static XRAM getBaseCount = 0; 
 1260   1          static XRAM FristStart = 1;
 1261   1          UINT16 XRAM usConfigValue;
 1262   1          UINT8 XRAM ucTPFramePerScan = 0;
 1263   1      
 1264   1          usConfigValue = 0xFF;
 1265   1          Drv_XsiWriteReg(pXSI0Regs, Addr_AFE_SX_P1_P2_CFG, usConfigValue, AFE_REG);
 1266   1          Drv_XsiWriteReg(pXSI1Regs, Addr_AFE_SX_P1_P2_CFG, usConfigValue, AFE_REG);
 1267   1      
 1268   1      #if TEMP_CLOSE_KEY
                   usConfigValue = 0x101;
                   Drv_XsiWriteReg(pXSI0Regs, Addr_AFE_SYS_CFG0, usConfigValue, AFE_REG); // close key enable
                   Drv_XsiWriteReg(pXSI1Regs, Addr_AFE_SYS_CFG0, usConfigValue, AFE_REG);
               #endif
 1273   1          
 1274   1      
 1275   1          /* 加载Tab表*/
 1276   1      #ifdef TEST_MUL_SCAN
                    ucTPFramePerScan = 3;   // 连续4次扫描
               //    ucTPFramePerScan = 2;   // 连续3次扫描
               //    ucTPFramePerScan = 1;   // 连续2次扫描
                   DrvLoadTabMultiple(0,5,0,0,ucTPFramePerScan,0);    // 表0  启动后，每次扫描多帧  1=2次
               #else
 1282   1          DrvLoadTabSingle(0,0);            // 表0  启动后，每次扫描1帧
 1283   1      //    DrvLoadTabSingle(1,0);            // 表1  启动后，每次扫描1帧
 1284   1      //    DrvLoadTabSingle(2,0);            // 表2  启动后，每次扫描1帧
 1285   1      //    DrvLoadTabSingle(3,0);            // 表3  启动后，每次扫描1帧
 1286   1      #endif
 1287   1          
 1288   1          DrvAsmInterEnable0(BIT_LCD_ARAM_RDY_EN0);
 1289   1          DrvAsmInterEnable0(BIT_LCD_FRAME_END_EN0); 
 1290   1          DrvAsmInterDisable0(BIT_LCD_VSTART_EN0);   // Close Vstart interrupt
 1291   1         
 1292   1          g_ucAramReadyFlag = 0;
 1293   1      
 1294   1          while(ucAfeRunMode == TP_FREE_RUN_MODE) // 表示LCD灭屏
 1295   1          {
 1296   2              AppPanelParamUpdate();
 1297   2              
 1298   2              if(FristStart == 1)
 1299   2              {
 1300   3      #ifdef TEST_MUL_SCAN    
                           if((g_ucIntCount%(ucTPFramePerScan+1))==0)    
                           {
                               DrvAsmScanStart();
                           }
                           //FristStart = 0;
C251 COMPILER V5.54.0.0,  FlowFactory                                                      26/05/17  20:21:08  PAGE 21  

               #else 
 1307   3      
 1308   3      #if TEST_ASM_ARAM_READY_WAKEUP
                           ASM_MON_WKEN = 1;
                           DrvAsmWakeEnable0(BIT_LCD_ARAM_RDY_WAKE_EN0);       //8
                           DBG_FLOW("\nFreeRun ARAM_RDY Standby in------");
                           DelayMs(100); // For Print
                           EA = 0;
               #endif        
 1315   3                  DrvAsmScanStart();
 1316   3      #if TEST_ASM_ARAM_READY_WAKEUP
                           DrvSysPowerStandby();
                           EA = 1;
               #endif 
 1320   3      #endif  
 1321   3                  //DrvAfeSofeReset();
 1322   3                  //DrvAsmScanStart();
 1323   3              }
 1324   2      
 1325   2              while(!g_ucAramReadyFlag);
 1326   2              g_ucAramReadyFlag = 0;
 1327   2              DBG_FLOW("\n=======Afe_Free_Run====== :%d  Sta:0x%x",g_ucIntCount,g_usAsmIntSta);
 1328   2              DBG_FLOW("\nReg4 0x%x ",DebugReadAFEOneReg(4));
 1329   2      
 1330   2              //当前扫描的TP帧号
 1331   2              //DBG_FLOW("\n9usAsmScanSta0: %04x",(pAsmRegs->usAsmScanSta0>>BIT_CUR_TP_FRAME_ID_STA));         
             - // 09  RO
 1332   2              //AppGetAsmState();
 1333   2      
 1334   2              DrvGetRptRamRawBase();
 1335   2      
 1336   2              DrvGetRawdata(); 
 1337   2      
 1338   2              DrvInitAram();
 1339   2              
 1340   2      #ifdef TEST_MUL_SCAN  // 多次扫描，第2次扫描在AramReady中断后启动，这时AFE会操作report ram，mcu不适合操作
             -report ram
               #else
 1342   2              DrvInitRptRam();
 1343   2      #endif
 1344   2      
 1345   2              DrvAsmAramAvail(); // realse aram:  Asm可以往Aram写下一个tp帧数据
 1346   2      
 1347   2              //AppGetAsmState();
 1348   2              
 1349   2              getBaseCount++;
 1350   2              if(getBaseCount == 20)
 1351   2              {
 1352   3                  DrvGetBase();
 1353   3              }
 1354   2      
 1355   2              //DrvGetDiffdata();
 1356   2              
 1357   2              //DelayMs(5);   
 1358   2      
 1359   2              g_RegHead.bits.ucDataReadToggle = 0;   
 1360   2          }
 1361   1      }
 1362          
 1363          /*******************************************************************************
 1364          *   Name: Afe_Free_Run
 1365          *  Brief: 
 1366          *  Input: 
 1367          * Output: 
 1368          * Return: 
 1369          *******************************************************************************/
C251 COMPILER V5.54.0.0,  FlowFactory                                                      26/05/17  20:21:08  PAGE 22  

 1370          void Afe_Free_Run_Monitor(void)
 1371          {
 1372   1        UINT16 XRAM usConfigValue;
 1373   1        static UINT16 XRAM usScanCount = 0;
 1374   1        static UINT8 XRAM ucConfigOne = 1;
 1375   1      
 1376   1        usConfigValue = 0xFF;
 1377   1        Drv_XsiWriteReg(pXSI0Regs, Addr_AFE_SX_P1_P2_CFG, usConfigValue, AFE_REG);
 1378   1        Drv_XsiWriteReg(pXSI1Regs, Addr_AFE_SX_P1_P2_CFG, usConfigValue, AFE_REG);
 1379   1        
 1380   1      #if TEMP_CLOSE_KEY
                 usConfigValue = 0x101;
                 Drv_XsiWriteReg(pXSI0Regs, Addr_AFE_SYS_CFG0, usConfigValue, AFE_REG); // close key enable
                 Drv_XsiWriteReg(pXSI1Regs, Addr_AFE_SYS_CFG0, usConfigValue, AFE_REG);
               #endif    
 1385   1        
 1386   1        DrvAsmMonitoModeInit(); 
 1387   1        DBG_FLOW("\nDrvAsmMonitoModeInit"); 
 1388   1        
 1389   1        /* 加载Tab表*/
 1390   1        DrvLoadTabSingle(2,0);          //表2 用于Monitor模式
 1391   1       
 1392   1        DrvAsmInterEnable0(BIT_LCD_ARAM_RDY_EN0);
 1393   1        DrvAsmInterEnable0(BIT_LCD_FRAME_END_EN0);
 1394   1      
 1395   1        //使能触摸检测中断
 1396   1        DrvAsmInterClear0(BIT_LCD_TCH_DET_CLR0);
 1397   1      //    DrvAsmInterEnable0(BIT_LCD_TCH_DET_EN0);
 1398   1           
 1399   1        while(ucAfeRunMode == TP_FREE_RUN_MODE) // 表示LCD灭屏
 1400   1        {
 1401   2          g_usAsmIntFlag0 = 0;
 1402   2          g_usAsmIntFlag1 = 0;
 1403   2          
 1404   2          g_ucFrameEndFlag = 0;
 1405   2              
 1406   2      #if TEST_ASM_FRAME_END_WAKEUP
                   ASM_MON_WKEN = 1;
                   DrvAsmWakeEnable0(BIT_LCD_FRAME_END_WAKE_EN0);     //7
                   DBG_FLOW("\nFreeRun FRAME_END Standby in------");
                   DelayMs(100); // For Print
                   EA = 0;
                   DrvAsmScanStart(); 
                   DrvSysPowerStandby();
                   EA = 1;
               #else
 1416   2          DrvAsmScanStart(); 
 1417   2      #endif
 1418   2      
 1419   2          
 1420   2      //      DBG_FLOW("\nMonitor---StartScan:%d",g_ucFrameEndFlag);       
 1421   2          while(!g_ucFrameEndFlag);
 1422   2          g_ucFrameEndFlag = 0;
 1423   2      //      DBG_FLOW("\nAsm int: 0x%x 0x%x",g_usAsmIntFlag0,g_usAsmIntFlag1);
 1424   2          
 1425   2          DBG_FLOW("\nReg11 0x%x ",DebugReadAFEOneReg(11));
 1426   2          DBG_FLOW("\nReg12 0x%x ",DebugReadAFEOneReg(12));
 1427   2          DBG_FLOW("\nFreeRun Montor");   
 1428   2          
 1429   2          DrvGetRptRamRawBase(); // Monitor模式不上报数据到ARAM,通过RptRam上报。
 1430   2      #if TEST_ASM_FRAME_END_WAKEUP
                   DBG_FLOW("\nFreeRun---------ucWake up");     
               #endif
 1433   2          if(ucConfigOne == 1)
 1434   2          {
 1435   3            ucConfigOne = 0;
C251 COMPILER V5.54.0.0,  FlowFactory                                                      26/05/17  20:21:08  PAGE 23  

 1436   3            //使能触摸检测中断
 1437   3            DrvAsmInterClear0(BIT_LCD_TCH_DET_CLR0); //清除 DET INT
 1438   3            DrvAsmInterEnable0(BIT_LCD_TCH_DET_EN0);
 1439   3          }
 1440   2      
 1441   2          //DrvGetTabRam();
 1442   2          
 1443   2          DelayMs(50);
 1444   2      
 1445   2          g_RegHead.bits.ucDataReadToggle = 0;   
 1446   2        }
 1447   1      }
 1448          
 1449          
 1450          /*******************************************************************************
 1451          *   Name: Afe_Free_Run_RTC_Monitor
 1452          *  Brief: 
 1453          *  Input: 
 1454          * Output: 
 1455          * Return: 
 1456          *******************************************************************************/
 1457          void Afe_Free_Run_RTC_Monitor(void)
 1458          {
 1459   1          UINT16 XRAM usConfigValue;
 1460   1          UINT16 XRAM ucData;
 1461   1          UINT8 XRAM usStartFlag = 1;
 1462   1      
 1463   1        ASM_32K_EN = 1;
 1464   1      
 1465   1      #if TEST_MCAP_HWMON 
 1466   1        //配置rf_sel
 1467   1        usConfigValue = Drv_XsiReadReg(pXSIREG,Addr_ANA_STATIC_CFG0,AFE_REG);
 1468   1        usConfigValue &= 0x87FF;
 1469   1      
 1470   1        usConfigValue |= (0x01<<13) +  (0x01<<11);            //写key的rf
 1471   1        Drv_XsiWriteReg(pXSI0Regs, Addr_ANA_STATIC_CFG0, usConfigValue, AFE_REG);
 1472   1        Drv_XsiWriteReg(pXSI1Regs, Addr_ANA_STATIC_CFG0, usConfigValue, AFE_REG);
 1473   1        
 1474   1        //Afe_Change_Tab3(2,4,13);   //hw mon,扫描方式5
 1475   1        Afe_Change_Tab3(2,7,13);   //hw mon,扫描方式8 
 1476   1      
 1477   1        /*使能mcap,更新tab0以及afe reg相关参数*/
 1478   1        DrvMcapModeInit(1,3); 
 1479   1      #else
                 Afe_Change_Tab3(1,4,1);   //HW Monitor,扫描方式5
                 //Afe_Change_Tab3(1,7,1);   //HW Monitor,扫描方式8  
               #endif
 1483   1      
 1484   1        SEL_32K_SRC = 0;
 1485   1          Drv_Rtc_Init(0);//auto_mode
 1486   1      
 1487   1      #if 1//PWR_EN
 1488   1        ANACON8 = 0xFF;
 1489   1        ANACON9 = 0xFF;
 1490   1        DrvAsmSetPwrOn();
 1491   1      #endif
 1492   1      
 1493   1          DBG_FLOW("\nRTC MONITOR");
 1494   1          usConfigValue = 0xFF;
 1495   1          Drv_XsiWriteReg(pXSI0Regs, Addr_AFE_SX_P1_P2_CFG, usConfigValue, AFE_REG);//sx全驱
 1496   1          Drv_XsiWriteReg(pXSI1Regs, Addr_AFE_SX_P1_P2_CFG, usConfigValue, AFE_REG);//sx全驱
 1497   1      
 1498   1        /*改变tab表中的触摸阈值*/
 1499   1          DrvSetTabMonThr(0xfff,10,3);
 1500   1      
 1501   1        /*HW MON配置*/    
C251 COMPILER V5.54.0.0,  FlowFactory                                                      26/05/17  20:21:08  PAGE 24  

 1502   1          DrvAsmRtcMonitoModeInit();
 1503   1        //DelayMs(1000);  
 1504   1      
 1505   1          ucData = Drv_XsiReadReg(pXSI0Regs, Addr_AFE_SYS_CFG0, AFE_REG);
 1506   1          DBG_FLOW("\nXSI0 AfeReg4:%04x",ucData);
 1507   1      
 1508   1          ucData = Drv_XsiReadReg(pXSI1Regs, Addr_AFE_SYS_CFG0, AFE_REG);
 1509   1          DBG_FLOW("\nXSI1 AfeReg4:%04x",ucData);
 1510   1      
 1511   1          P0_4 = 0;
 1512   1          DelayMs(10);
 1513   1          P0_4 = 1;
 1514   1          DelayMs(10);
 1515   1          P0_4 = 0;
 1516   1          DelayMs(10);    
 1517   1          
 1518   1          /*不能用*/
 1519   1          RTC_CNT_WKEN = 0;
 1520   1                           
 1521   1          DBG_FLOW("\n\nrtc monitor");
 1522   1               
 1523   1          DelayMs(100);
 1524   1          
 1525   1          DrvAsmClrInt();
 1526   1           
 1527   1          g_ucFrameEndFlag = 0;
 1528   1          g_usAsmIntFlag0 = 0;
 1529   1          g_usAsmIntFlag1 = 0;
 1530   1          g_ucTimeOutFlag = 0;
 1531   1      
 1532   1      #if PWR_EN
 1533   1          DrvAsmSetHwMonPwrEn(1);                                //设置在硬件monitor下，控制上下电时序。1:控制;
             -0:不控制
 1534   1      #else
                   DrvAsmSetHwMonPwrEn(0);                                //设置在硬件monitor下，控制上下电时序。1:控制;
             -0:不控制
               #endif
 1537   1      
 1538   1        DelayMs(100);
 1539   1      
 1540   1          //while(ucAfeRunMode == TP_FREE_RUN_MODE) // 表示LCD灭屏
 1541   1          //while(1)
 1542   1          {
 1543   2                  
 1544   2              RTC_CNT_WKEN = 0;        //RTC int0唤       
 1545   2              ASM_MON_WKEN = 1;        //scan mon int0唤醒
 1546   2      
 1547   2              if(usStartFlag)
 1548   2              {
 1549   3                  //刷base以后才能配置进入hw mon
 1550   3                  DrvAsmSetRtcMonitorMode(TRUE);                          //1:开启rtc monitor模式        
 1551   3                  P0_4 = 1;
 1552   3                  DelayMs(1);            
 1553   3                  P0_4 = 0;            
 1554   3                  RTC_WP = 1;
 1555   3                  RTC_START = 1;
 1556   3                  usStartFlag = 0;
 1557   3              }
 1558   2      #if 1  
 1559   2      
 1560   2              AFEACKEN = 1; //该bit不能关闭,关闭后ASM不能工作
 1561   2              AFECKEN  = 0; //可以关闭,但是实际上没必要手动关,进入stop或者standby,硬件会自动关闭.   
 1562   2              AFESCKEN = 0; //可以关闭,但是实际上没必要手动关,进入stop或者standby,硬件会自动关闭.         
 1563   2            
 1564   2              DrvSysPowerStop();
 1565   2      
C251 COMPILER V5.54.0.0,  FlowFactory                                                      26/05/17  20:21:08  PAGE 25  

 1566   2              //DrvSysPowerStandby();
 1567   2              DrvAsmSetRtcMonitorMode(FALSE);        
 1568   2              AFEACKEN = 1;
 1569   2              AFECKEN  = 1;   
 1570   2              AFESCKEN = 1;
 1571   2      
 1572   2              P0_4 = 1;
 1573   2              while(RTC_START_STA == 0);
 1574   2              RTC_WP = 1;
 1575   2              RTC_CLR = 1;
 1576   2      
 1577   2              DBG_FLOW("\nexit stop");
 1578   2      
 1579   2      #endif
 1580   2              while((!g_ucTimeOutFlag)&&(!g_ucTchDetFlag));
 1581   2              //DrvAsmSetRtcMonitorMode(FALSE); 
 1582   2              DelayMs(10); 
 1583   2      
 1584   2              DBG_FLOW("\nTHR:%04x",Drv_XsiReadReg(pXSI0Regs,0x0b,AFE_REG));
 1585   2              
 1586   2              DBG_FLOW("\nwake up-------------");
 1587   2              DBG_FLOW("\nWake up intflag: 0x%x 0x%x",g_usAsmIntFlag0,g_usAsmIntFlag1);
 1588   2              DBG_FLOW("\niwksta:%02x",g_ucState0);
 1589   2              
 1590   2              DelayMs(5);
 1591   2              if ((g_usAsmIntFlag0 &0x08) == 0x08)
 1592   2              {
 1593   3                  DBG_FLOW("\n*************Mon Det %02x",g_usAsmIntFlag0);
 1594   3                  while(1);
 1595   3                  DelayMs(1000);
 1596   3                  g_usAsmIntFlag0 = 0x00;            
 1597   3              }
 1598   2      
 1599   2              if(g_ucTimeOutFlag)
 1600   2              {
 1601   3                  DBG_FLOW("\n*************Mon Timeout %02x",g_usAsmIntFlag1);
 1602   3                  DelayMs(1000);
 1603   3              }
 1604   2      
 1605   2              g_ucTimeOutFlag = 0;
 1606   2              g_ucTchDetFlag = 0;
 1607   2              DBG_FLOW("\nRTC wake\n");
 1608   2              
 1609   2              DrvGetRptRamRawBase();
 1610   2      
 1611   2              g_ucFrameEndFlag = 0;
 1612   2              g_usAsmIntFlag0 = 0;
 1613   2              g_usAsmIntFlag1 = 0;
 1614   2      
 1615   2              DelayMs(1000);
 1616   2              while(1);
 1617   2              //g_RegHead.bits.ucDataReadToggle = 0;
 1618   2          }
 1619   1      }
 1620          
 1621          /*******************************************************************************
 1622          *   Name: Afe_Free_Run_H_CB
 1623          *  Brief: 
 1624          *  Input: 
 1625          * Output: 
 1626          * Return: 
 1627          *******************************************************************************/
 1628          void Afe_Free_Run_H_CB(void)
 1629          {
 1630   1          UINT8  XRAM ausTabId = 3;
 1631   1      
C251 COMPILER V5.54.0.0,  FlowFactory                                                      26/05/17  20:21:08  PAGE 26  

 1632   1      #if TEST_MCAP_CB
                 UINT16 usConfigValue;
               
                 //配置rf_sel
                 usConfigValue = Drv_XsiReadReg(pXSIREG,Addr_ANA_STATIC_CFG0,AFE_REG);
                 usConfigValue &= 0x87FF;
               
                 usConfigValue |= (0x01<<13) +  (0x01<<11);            //写key的rf
                 Drv_XsiWriteReg(pXSI0Regs, Addr_ANA_STATIC_CFG0, usConfigValue, AFE_REG);
                 Drv_XsiWriteReg(pXSI1Regs, Addr_ANA_STATIC_CFG0, usConfigValue, AFE_REG);
               
                   Afe_Change_Tab3(2,4,18);   //CB,扫描方式5
                   //Afe_Change_Tab3(2,7,18);   //CB,扫描方式8
               
                   /*使能mcap,更新tab0以及afe reg相关参数*/
                   DrvMcapModeInit(1,3);
               
               #else
 1650   1          //Afe_Change_Tab3(0,4,2);   //CB,扫描方式5
 1651   1          Afe_Change_Tab3(0,7,2);   //CB,扫描方式8
 1652   1      #endif
 1653   1          
 1654   1          Drv_XsiWriteReg(pXSI0Regs, Addr_AFE_SX_P1_P2_CFG, 0xFF, AFE_REG);//sx p1/p2 配成全驱
 1655   1          Drv_XsiWriteReg(pXSI1Regs, Addr_AFE_SX_P1_P2_CFG, 0xFF, AFE_REG);//sx p1/p2 配成全驱 
 1656   1      
 1657   1        
 1658   1          g_ucFrameEndFlag = FALSE;
 1659   1          g_ucAramReadyFlag = 0;
 1660   1          g_usAsmIntFlag0 = 0;
 1661   1      
 1662   1      #if 1
 1663   1      
 1664   1          /*设置CB校正的方向*/
 1665   1          DrvSetCbDir(1,1);  //0:顺时针 若raw<th cb变大;1:逆时针 若rawdata<th cb变小
 1666   1      
 1667   1          /*CB校正模式*/ 
 1668   1          DrvAsmSetCBAdjustMode(1);
 1669   1      
 1670   1          /*设置硬件CB校正的目标值*/
 1671   1          DrvAfeSetHCBTarget(10000,10000);
 1672   1      
 1673   1          /* 加载Tab表*/
 1674   1          DrvLoadTabCB(3,AFE_FREERUN_MODE);
 1675   1      
 1676   1          DrvAsmInterEnable0(BIT_LCD_ARAM_RDY_EN0);//开启AramReady中断使能
 1677   1          DrvAsmInterEnable0(BIT_LCD_FRAME_END_EN0);//开启Frame end中断使能    
 1678   1          DelayMs(20);
 1679   1      
 1680   1      //while(1)
 1681   1      {
 1682   2          /*启动扫描*/
 1683   2          DrvAsmScanStart();
 1684   2          
 1685   2          while(g_ucAramReadyFlag == 0);//CB校正模式，硬件数到8帧TP帧结束时才会发Aram Ready中断，这时候才表示CB
             -校正结束
 1686   2      
 1687   2          g_ucAramReadyFlag = 0;
 1688   2          
 1689   2          DelayMs(10000);
 1690   2      #if 1 //从ARAM中读出CB 
 1691   2          DrvGetAramCb();
 1692   2      #endif
 1693   2          DrvAsmAramAvail(); 
 1694   2          
 1695   2      #if 0 //从TAB表中读出CB
                   DelayMs(2000);    
C251 COMPILER V5.54.0.0,  FlowFactory                                                      26/05/17  20:21:08  PAGE 27  

                   DrvGetTabRamCb();
                   DelayMs(2000);
               #endif
 1700   2      
 1701   2      #if 0 //从RptRam中后去Rawdata
                   DBG_FLOW("\nRead Rawdata from RptRam");
                   DrvGetRptRamRawBase();
               #endif    
 1705   2      }
 1706   1      
 1707   1      #endif
 1708   1      
 1709   1      #if 0//AFE阶段中，由于CB是由外部的CB决定的，CB的大小对RAWDATA实际上没影响，因此不再进行一次扫描，看RAWDAT
             -A的值是否接近设定值,在芯片验证阶段。则有影响
               
                   DelayMs(2000);
               
                   DBG_FLOW("\nAFE RUN");
                   
                   g_ucFrameEndFlag = FALSE;
                   g_ucAramReadyFlag = 0;
                   g_usAsmIntFlag0 = 0;
                   
                   /*正常工作模式*/ 
                   DrvAsmSetCBAdjustMode(0);    
               
                   /*单次扫描*/
                   DrvLoadTabSingle(0,0);
                   
                   DelayMs(20);
               
                   DBG_FLOW("\n\n");
                   /*启动扫描*/
                   
                   while(1)
                   {
                       DrvAsmScanStart();
                       while((g_ucAramReadyFlag == 0)||(g_ucFrameEndFlag == 0));
               
                       g_ucAramReadyFlag = 0;
                       g_ucFrameEndFlag = 0;
                       
                       DrvGetAramRawData();
                       
                       DrvAsmAramAvail();
                       
                       DelayMs(2000);
                   }
               #endif
 1745   1      
 1746   1          DBG_FLOW("\nCB FINISH");
 1747   1          HOLD;
 1748   1      }
 1749          
 1750          /*******************************************************************************
 1751          *   Name: Mcap_Free_Run
 1752          *  Brief: 
 1753          *  Input: 
 1754          * Output: 
 1755          * Return: 
 1756          *******************************************************************************/
 1757          void Mcap_Free_Run(void)
 1758          {
 1759   1      #if TEST_SAMP_INT
                   UINT16 XRAM ucData,ucMax,ucInit;
               #endif
C251 COMPILER V5.54.0.0,  FlowFactory                                                      26/05/17  20:21:08  PAGE 28  

 1762   1          static XRAM getBaseCount = 0;
 1763   1          static XRAM FristStart = 1;
 1764   1          UINT16 XRAM usConfigValue;
 1765   1          UINT8 XRAM ucTPFramePerScan = 0;
 1766   1          UINT8 XRAM ucTabId = 3;
 1767   1          UINT8 XRAM ucTestMode = 1;//0:测试模式;1:普通模式
 1768   1          UINT8 XRAM ucScanNum = 13;
 1769   1        UINT16 XRAM i,j;
 1770   1      
 1771   1          Afe_Change_Tab3(2,4,ucScanNum );   //MCAP,扫描方式5
 1772   1          //Afe_Change_Tab3(2,7,ucScanNum );   //MCAP,扫描方式8
 1773   1          
 1774   1          usConfigValue = 0xFF;
 1775   1          Drv_XsiWriteReg(pXSI0Regs, Addr_AFE_SX_P1_P2_CFG, usConfigValue, AFE_REG);
 1776   1          Drv_XsiWriteReg(pXSI1Regs, Addr_AFE_SX_P1_P2_CFG, usConfigValue, AFE_REG);
 1777   1      
 1778   1      #if 1
 1779   1          //配置rf_sel
 1780   1          usConfigValue = Drv_XsiReadReg(pXSIREG,Addr_ANA_STATIC_CFG0,AFE_REG);
 1781   1          usConfigValue &= 0x87FF;
 1782   1      
 1783   1          usConfigValue |= (0x01<<13) +  (0x01<<11);                      //写key的rf
 1784   1          Drv_XsiWriteReg(pXSI0Regs, Addr_ANA_STATIC_CFG0, usConfigValue, AFE_REG);
 1785   1          Drv_XsiWriteReg(pXSI1Regs, Addr_ANA_STATIC_CFG0, usConfigValue, AFE_REG);
 1786   1      
 1787   1          DBG_FLOW("REG_36:%04x",usConfigValue);
 1788   1      #endif
 1789   1         
 1790   1          /*使能mcap,更新tab0以及afe reg相关参数*/
 1791   1          DrvMcapModeInit(1,ucTabId);
 1792   1      
 1793   1          /* 加载Tab表*/
 1794   1          DrvLoadTabSingle(ucTabId,0);            // 表3  启动后，每次扫描1帧
 1795   1          
 1796   1          DrvMcapSetTestMode(ucTestMode,0);          //0为开启测试模式,1为普通模式,选择输出key2
 1797   1          //DrvAfeSetOneChannelTestMode(0,0,0);
 1798   1      
 1799   1          DrvAsmInterEnable0(BIT_LCD_ARAM_RDY_EN0);//开启AramReady中断使能
 1800   1          DrvAsmInterEnable0(BIT_LCD_FRAME_END_EN0);//开启FrameEnd中断使能
 1801   1      
 1802   1          g_ucAramReadyFlag = 0;
 1803   1      
 1804   1      #if PWR_EN
 1805   1          ANACON8 = 0xFF;
 1806   1          ANACON9 = 0xFF;
 1807   1          DrvAsmSetPwrOn();
 1808   1      #endif
 1809   1      
 1810   1      #if TEST_SAMP_INT
                   ucMax = 0;
                   ucInit = 0;
                   DrvMcapSetTestMode(1,1); 
               
                   for(i = 0x0; i < ((g_pMcapPara->usK1 + g_pMcapPara->usK2)*2 - 29 - 2*3); i++)
                   {
                       g_pMcapPara->usSampl_Init = i;
                       Drv_XsiWriteReg(pXSI0Regs,Addr_MCAP_INIT_SAMPL_CFG,g_pMcapPara->usSampl_Init,AFE_REG);
                       Drv_XsiWriteReg(pXSI1Regs,Addr_MCAP_INIT_SAMPL_CFG,g_pMcapPara->usSampl_Init,AFE_REG);
                       
                       DrvAsmScanStart();
                       while(!g_ucAramReadyFlag);
                       g_ucAramReadyFlag = 0;
                       
                       ARAM_SEL = 1;
                       ucData = ARAM_ADDR16(CH_ORDER_MAX*4);
                       ARAM_SEL = 0;
C251 COMPILER V5.54.0.0,  FlowFactory                                                      26/05/17  20:21:08  PAGE 29  

                       
                       if(ucData > ucMax)
                       {
                           ucMax = ucData;
                           ucInit = i;
                       }
               
                       DBG_FLOW("\nSamp_Init:%04x,Rawdata:%04x",i,ucData);
                       DrvAsmAramAvail(); // realse aram:  Asm可以往Aram写下一个tp帧数据
               
                       DelayMs(500);
                   }
               
                   Drv_XsiWriteReg(pXSI0Regs,Addr_MCAP_INIT_SAMPL_CFG,ucInit,AFE_REG);
                   Drv_XsiWriteReg(pXSI1Regs,Addr_MCAP_INIT_SAMPL_CFG,ucInit,AFE_REG);
               
                   ucInit = Drv_XsiReadReg(pXSIREG,Addr_MCAP_INIT_SAMPL_CFG,AFE_REG);
                   DBG_FLOW("\nwhen rawdata is max,samp_init is:%04x",ucInit);
                   
                   DrvMcapSetTestMode(ucTestMode,1);          //0为开启测试模式,1为普通模式,选择输出key2     
               #endif
 1849   1      
 1850   1          while(ucAfeRunMode == TP_FREE_RUN_MODE) // 表示LCD灭屏
 1851   1          //for(j = 0; j < 2000; j++)
 1852   1          {
 1853   2           
 1854   2          #if 1
 1855   2              ARAM_SEL = 1;
 1856   2              for(i = 0; i < 0x500; i++)
 1857   2              {
 1858   3                  *(UINT8 *)(0xA000 + i) = 0;//清除aram
 1859   3              }
 1860   2              ARAM_SEL = 0;
 1861   2          #endif
 1862   2          
 1863   2              DrvAsmScanStart();
 1864   2                  
 1865   2              while(!g_ucAramReadyFlag);
 1866   2              g_ucAramReadyFlag = 0;
 1867   2              DBG_FLOW("\nHave Aram Ready");
 1868   2      
 1869   2              DrvMcapReadSta(g_pMcapPara);
 1870   2              if(g_pMcapPara->usErrFlg)
 1871   2              {
 1872   3                  DBG_FLOW("\nMcap Scan Err:%01x",g_pMcapPara->usErrSta);
 1873   3                  DBG_FLOW("\n");
 1874   3              }
 1875   2              else
 1876   2              {            
 1877   3                  if(ucTestMode == 0)
 1878   3                  {
 1879   4                      if(g_pMcapPara->usSampl_6)
 1880   4                      {
 1881   5                          DrvGetAdcData(ucScanNum * 6);
 1882   5                      }
 1883   4                      else
 1884   4                      {
 1885   5                          DrvGetAdcData(ucScanNum * 8);
 1886   5                      }
 1887   4                  }
 1888   3                  else
 1889   3                  {
 1890   4              //DrvGetRptRamRawBase();            
 1891   4                      DrvGetAramRawData();
 1892   4              
 1893   4                  }           
C251 COMPILER V5.54.0.0,  FlowFactory                                                      26/05/17  20:21:08  PAGE 30  

 1894   3              }
 1895   2              DrvAsmAramAvail(); // realse aram:  Asm可以往Aram写下一个tp帧数据
 1896   2      
 1897   2      #if PWR_EN
 1898   2              DrvAsmSetPwrOff();       
 1899   2      #endif        
 1900   2              DelayMs(1);
 1901   2      
 1902   2          }    
 1903   1      }
*** WARNING C47 IN LINE 1769 OF ..\..\src\source\flow\FlowFactory.c: 'j': unreferenced local variable
 1904          
 1905          /*******************************************************************************
 1906          *   Name: Afe_60Hz_Run
 1907          *  Brief: 
 1908          *  Input: 
 1909          * Output: 
 1910          * Return: 
 1911          *******************************************************************************/
 1912          void Afe_60Hz_Run(void)
 1913          { 
 1914   1          UINT16 XRAM usConfigValue;
 1915   1          static XRAM FristStart = 1;
 1916   1           
 1917   1          usConfigValue = 0xFF;
 1918   1          Drv_XsiWriteReg(pXSI0Regs, Addr_AFE_SX_P1_P2_CFG, usConfigValue, AFE_REG); // sx全驱
 1919   1          Drv_XsiWriteReg(pXSI1Regs, Addr_AFE_SX_P1_P2_CFG, usConfigValue, AFE_REG);
 1920   1      
 1921   1          DrvAsmInterEnable0(BIT_LCD_ARAM_RDY_EN0);
 1922   1          DrvAsmInterEnable0(BIT_LCD_FRAME_END_EN0);
 1923   1          DrvAsmInterEnable0(BIT_LCD_BUSY_FALL_EN0);
 1924   1          DrvAsmInterEnable0(BIT_LCD_VBLANK_EN0);
 1925   1          DrvAsmInterEnable0(BIT_LCD_PANEL_CONFLICT_EN0);
 1926   1          DrvAsmInterEnable0(BIT_LCD_SYNC_MISS_RISE_EN0);
 1927   1      
 1928   1      //    DBG_FLOW("\npAsmRegs->usAsmIntEn0:0x%x",pAsmRegs->usAsmIntEn0);
 1929   1          
 1930   1      //    DrvLoadTabMultiple(1,2,0,0,1,1);    // 60hz表1  启动扫描后，每次连续扫描2帧，第1次启动从1坑开始，第
             -2次启动从2坑开始，
 1931   1      //    DrvLoadTabMultiple(1,1,0,0,1,1);    // 60hz表1  启动扫描后，每次连续扫描2帧，第1次启动从1坑开始，第
             -2次启动从1坑开始，
 1932   1           DrvLoadTabMultiple(1,1,1,1,3,1);    // 60hz表1  启动扫描后，每次连续扫描4帧，第1次启动从1坑开始，第2
             -次启动从1坑开始，第4次启动从1坑开始，
 1933   1      
 1934   1      
 1935   1           DrvAsmInterEnable0(BIT_LCD_VSTART_EN0);
 1936   1                                            
 1937   1          DrvAsmReq60hz_Big_LcdBusy(); //请求60hz
 1938   1          
 1939   1          g_ucAramReadyFlag = 0;
 1940   1      
 1941   1      //    DrvAsmScanStart();
 1942   1      
 1943   1          // Vstart 中断里启动扫描
 1944   1          while((DrvAsmGetSta()&LCD_RUN_STA)==1)    
 1945   1          {     
 1946   2              if((DrvAsmGetSta1()&LCD_BUSY_STA)==0)
 1947   2              {
 1948   3                  AppPanelParamUpdate();
 1949   3               
 1950   3                  g_ucAramReadyFlag = 0;
 1951   3      
 1952   3                  while(g_ucAramReadyFlag==0);
 1953   3      
 1954   3                  DBG_FLOW("\n=======60HZ=======:%d",g_ucIntCount);
 1955   3      
C251 COMPILER V5.54.0.0,  FlowFactory                                                      26/05/17  20:21:08  PAGE 31  

 1956   3                  DrvAsmInterDisable0(BIT_LCD_VSTART_EN0);
 1957   3                  
 1958   3                  AppShowRawdata();
 1959   3      
 1960   3                  DrvAsmInterEnable0(BIT_LCD_ARAM_RDY_EN0);
 1961   3                  DrvAsmInterEnable0(BIT_LCD_VSTART_EN0);
 1962   3              }
 1963   2              
 1964   2              g_RegHead.bits.ucDataReadToggle = 0;
 1965   2          }
 1966   1      }
 1967          /*******************************************************************************
 1968          *   Name: Afe_60Hz_H_Clb
 1969          *  Brief: 
 1970          *  Input: 
 1971          * Output: 
 1972          * Return: 
 1973          *******************************************************************************/
 1974          void Afe_60Hz_H_Clb(void)
 1975          {
 1976   1      
 1977   1      #if TEST_MCAP_CB
                 UINT16 usConfigValue;
               
                 //配置rf_sel
                 usConfigValue = Drv_XsiReadReg(pXSIREG,Addr_ANA_STATIC_CFG0,AFE_REG);
                 usConfigValue &= 0x87FF;
               
                 usConfigValue |= (0x01<<13) +  (0x01<<11);            //写key的rf
                 Drv_XsiWriteReg(pXSI0Regs, Addr_ANA_STATIC_CFG0, usConfigValue, AFE_REG);
                 Drv_XsiWriteReg(pXSI1Regs, Addr_ANA_STATIC_CFG0, usConfigValue, AFE_REG);
                 
                 Afe_Change_Tab3(2,CB_AFE_SCAN_MODE,18);   //CB,扫描方式
               
                 /*使能mcap,更新tab0以及afe reg相关参数*/
                 DrvMcapModeInit(1,3); 
               #else
 1993   1        Afe_Change_Tab3(0,CB_AFE_SCAN_MODE,1);   //CB,扫描方式
 1994   1      #endif
 1995   1      
 1996   1          if(CB_AFE_SCAN_MODE == 4)//扫描方式5，大坑模式
 1997   1          {
 1998   2              DrvAsmReq60hz_Big_LcdBusy();
 1999   2          }
 2000   1          else
 2001   1          {
 2002   2              DrvAsmReq120hz_Small_LcdBusy();
 2003   2          }
 2004   1      
 2005   1          
 2006   1          Drv_XsiWriteReg(pXSI0Regs, Addr_AFE_SX_P1_P2_CFG, 0xFF, AFE_REG);//sx p1/p2 配成全驱
 2007   1          Drv_XsiWriteReg(pXSI1Regs, Addr_AFE_SX_P1_P2_CFG, 0xFF, AFE_REG);//sx p1/p2 配成全驱 
 2008   1      
 2009   1        
 2010   1          g_ucFrameEndFlag = FALSE;
 2011   1          g_ucAramReadyFlag = 0;
 2012   1          g_usAsmIntFlag0 = 0;
 2013   1      
 2014   1          /*设置CB校正的方向*/
 2015   1          DrvSetCbDir(0,0);  //0:顺时针 若raw<th cb变大;1:逆时针 若rawdata<th cb变小
 2016   1      
 2017   1          /*CB校正模式*/ 
 2018   1          DrvAsmSetCBAdjustMode(1);
 2019   1      
 2020   1          /*设置硬件CB校正的目标值*/
 2021   1          DrvAfeSetHCBTarget(0,0);
C251 COMPILER V5.54.0.0,  FlowFactory                                                      26/05/17  20:21:08  PAGE 32  

 2022   1      
 2023   1          /* 加载Tab表*/
 2024   1          DrvLoadTabCB(3,AFE_60HZ_MODE);
 2025   1      
 2026   1          DrvAsmInterEnable0(BIT_LCD_ARAM_RDY_EN0);//开启AramReady中断使能
 2027   1          DrvAsmInterEnable0(BIT_LCD_FRAME_END_EN0);//开启Frame end中断使能 
 2028   1          
 2029   1          DelayMs(20);
 2030   1      
 2031   1      //while(1)
 2032   1      {
 2033   2          /*启动扫描*/
 2034   2          DrvAsmScanStart();
 2035   2          
 2036   2          while(g_ucAramReadyFlag == 0);//CB校正模式，硬件数到8帧TP帧结束时才会发Aram Ready中断，这时候才表示CB
             -校正结束
 2037   2      
 2038   2          g_ucAramReadyFlag = 0;
 2039   2          
 2040   2          DelayMs(10000);
 2041   2      #if 1 //从ARAM中读出CB 
 2042   2          DrvGetAramCb();
 2043   2      #endif
 2044   2          DrvAsmAramAvail(); 
 2045   2          
 2046   2      #if 1 //从TAB表中读出CB
 2047   2          DelayMs(2000);    
 2048   2          DrvGetTabRamCb();
 2049   2          DelayMs(2000);
 2050   2      #endif
 2051   2      
 2052   2      #if 1 //从RptRam中后去Rawdata
 2053   2          DBG_FLOW("\nRead Rawdata from RptRam");
 2054   2          DrvGetRptRamRawBase();
 2055   2      #endif    
 2056   2      }
 2057   1      
 2058   1      
 2059   1      
 2060   1      #if 0//AFE阶段中，由于CB是由外部的CB决定的，CB的大小对RAWDATA实际上没影响，因此不再进行一次扫描，看RAWDAT
             -A的值是否接近设定值,在芯片验证阶段。则有影响
               
                   DelayMs(2000);
               
                   DBG_FLOW("\nAFE RUN");
                   
                   g_ucFrameEndFlag = FALSE;
                   g_ucAramReadyFlag = 0;
                   g_usAsmIntFlag0 = 0;
                   
                   /*正常工作模式*/ 
                   DrvAsmSetCBAdjustMode(0);    
               
                   /*单次扫描*/
                   DrvLoadTabSingle(0,0);
                   
                   DelayMs(20);
               
                   DBG_FLOW("\n\n");
                   /*启动扫描*/
                   
                   while(1)
                   {
                       DrvAsmScanStart();
                       while((g_ucAramReadyFlag == 0)||(g_ucFrameEndFlag == 0));
               
C251 COMPILER V5.54.0.0,  FlowFactory                                                      26/05/17  20:21:08  PAGE 33  

                       g_ucAramReadyFlag = 0;
                       g_ucFrameEndFlag = 0;
                       
                       DrvGetAramRawData();
                       
                       DrvAsmAramAvail();
                       
                       DelayMs(2000);
                   }
               #endif
 2096   1      
 2097   1          DBG_FLOW("\nCB FINISH");
 2098   1          HOLD;
 2099   1      }
 2100          
 2101          /*******************************************************************************
 2102          *   Name: Mcap_60Hz_Run
 2103          *  Brief: 
 2104          *  Input: 
 2105          * Output: 
 2106          * Return: 
 2107          *******************************************************************************/
 2108          void Mcap_60Hz_Run()
 2109          {
 2110   1          static XRAM getBaseCount = 0;
 2111   1          static XRAM FristStart = 1;
 2112   1          UINT16 XRAM usConfigValue;
 2113   1          UINT8 XRAM ucTPFramePerScan = 0;
 2114   1          UINT8 ucTabId = 3;
 2115   1          UINT8 ucTestMode = 1;//0:测试模式;1:普通模式
 2116   1          UINT8 ucScanNum = 13;
 2117   1          UINT8 ucScanMode = 0;//扫描方式5
 2118   1          UINT16 i;
 2119   1      
 2120   1          if(ucScanMode == 4)//扫描方式5，大坑模式
 2121   1          {
 2122   2              DrvAsmReq60hz_Big_LcdBusy();
 2123   2          }
 2124   1          else
 2125   1          {
 2126   2              DrvAsmReq120hz_Small_LcdBusy();
 2127   2          }    
 2128   1      
 2129   1          Afe_Change_Tab3(2,ucScanMode,ucScanNum );   //MCAP,扫描方式5
 2130   1          
 2131   1          usConfigValue = 0xFF;
 2132   1          Drv_XsiWriteReg(pXSI0Regs, Addr_AFE_SX_P1_P2_CFG, usConfigValue, AFE_REG);
 2133   1          Drv_XsiWriteReg(pXSI1Regs, Addr_AFE_SX_P1_P2_CFG, usConfigValue, AFE_REG);
 2134   1      
 2135   1      #if 1
 2136   1          //配置rf_sel
 2137   1          usConfigValue = Drv_XsiReadReg(pXSIREG,Addr_ANA_STATIC_CFG0,AFE_REG);
 2138   1          usConfigValue &= 0x87FF;
 2139   1      
 2140   1          usConfigValue |= (0x01<<13) +  (0x01<<11);                      //写key的rf
 2141   1          Drv_XsiWriteReg(pXSI0Regs, Addr_ANA_STATIC_CFG0, usConfigValue, AFE_REG);
 2142   1          Drv_XsiWriteReg(pXSI1Regs, Addr_ANA_STATIC_CFG0, usConfigValue, AFE_REG);
 2143   1      
 2144   1          DBG_FLOW("\nREG_36:%04x",usConfigValue);
 2145   1      #endif
 2146   1      
 2147   1          /*使能mcap,更新tab0以及afe reg相关参数*/
 2148   1          DrvMcapModeInit(0,ucTabId);
 2149   1          /* 加载Tab表*/
 2150   1          DrvLoadTabSingle(ucTabId,1);            // 表3  启动后，每次扫描1帧
 2151   1          
C251 COMPILER V5.54.0.0,  FlowFactory                                                      26/05/17  20:21:08  PAGE 34  

 2152   1          DrvMcapSetTestMode(ucTestMode,0);          //0为开启测试模式,1为普通模式,选择输出key2
 2153   1          
 2154   1          DrvAsmInterEnable0(BIT_LCD_ARAM_RDY_EN0);//开启AramReady中断使能
 2155   1          DrvAsmInterEnable0(BIT_LCD_FRAME_END_EN0);//开启AramReady中断使能
 2156   1          DrvAsmInterEnable0(BIT_LCD_PANEL_CONFLICT_EN0);//开启屏体冲突中断使能
 2157   1      
 2158   1          g_ucAramReadyFlag = 0;
 2159   1      
 2160   1      #if PWR_EN
 2161   1          ANACON8 = 0xFF;
 2162   1          ANACON9 = 0xFF;
 2163   1          DrvAsmSetPwrOn();
 2164   1      #endif
 2165   1      
 2166   1      
 2167   1          while(ucAfeRunMode == TP_60HZ_RUN_MODE) 
 2168   1          {
 2169   2          
 2170   2      #if 1
 2171   2              ARAM_SEL = 1;
 2172   2              for(i = 0; i < 0x500; i++)
 2173   2              {
 2174   3                  *(UINT8 *)(0xA000 + i) = 0;//清除aram
 2175   3              }
 2176   2              ARAM_SEL = 0;
 2177   2      #endif
 2178   2          
 2179   2              DrvAsmScanStart();
 2180   2                  
 2181   2              while(!g_ucAramReadyFlag);
 2182   2              g_ucAramReadyFlag = 0;
 2183   2              DBG_FLOW("\nHave Aram Ready");
 2184   2      
 2185   2              DrvMcapReadSta(g_pMcapPara);
 2186   2              if(g_pMcapPara->usErrFlg)
 2187   2              {
 2188   3                  DBG_FLOW("\nMcap Scan Err:%01x",g_pMcapPara->usErrSta);
 2189   3                  DBG_FLOW("\n");
 2190   3              }
 2191   2              else
 2192   2              {
 2193   3      #if 1            
 2194   3                  if(ucTestMode == 0)
 2195   3                  {
 2196   4                      if(g_pMcapPara->usSampl_6)
 2197   4                      {
 2198   5                          DrvGetAdcData(ucScanNum * 6);
 2199   5                      }
 2200   4                      else
 2201   4                      {
 2202   5                          DrvGetAdcData(ucScanNum * 8);
 2203   5                      }
 2204   4                  }
 2205   3                  else
 2206   3                  {
 2207   4                      DrvGetAramRawData();
 2208   4                  }
 2209   3      #endif            
 2210   3              }
 2211   2              
 2212   2              DrvAsmAramAvail(); // realse aram:  Asm可以往Aram写下一个tp帧数据
 2213   2      
 2214   2      #if 0//PWR_EN
                       DrvAsmSetPwrOff();       
               #endif        
 2217   2              DelayMs(1000);
C251 COMPILER V5.54.0.0,  FlowFactory                                                      26/05/17  20:21:08  PAGE 35  

 2218   2          }
 2219   1          
 2220   1      }
 2221          
 2222          /*******************************************************************************
 2223          *   Name: Afe_120Hz_Run
 2224          *  Brief: 
 2225          *  Input: 
 2226          * Output: 
 2227          * Return: 
 2228          *******************************************************************************/
 2229          void Afe_120Hz_Run(void)
 2230          { 
 2231   1          UINT16 XRAM usConfigValue;
 2232   1          static XRAM FristStart = 1;
 2233   1      //    UINT16 XRAM i;
 2234   1           
 2235   1          usConfigValue = 0xFF;
 2236   1          Drv_XsiWriteReg(pXSI0Regs, Addr_AFE_SX_P1_P2_CFG, usConfigValue, AFE_REG); // sx全驱
 2237   1          Drv_XsiWriteReg(pXSI1Regs, Addr_AFE_SX_P1_P2_CFG, usConfigValue, AFE_REG);
 2238   1      #if TEMP_CLOSE_KEY
                   usConfigValue = 0x101;
                   Drv_XsiWriteReg(pXSI0Regs, Addr_AFE_SYS_CFG0, usConfigValue, AFE_REG); // close key enable
                   Drv_XsiWriteReg(pXSI1Regs, Addr_AFE_SYS_CFG0, usConfigValue, AFE_REG);
               #endif
 2243   1      
 2244   1          DrvAsmInterEnable0(BIT_LCD_ARAM_RDY_EN0);
 2245   1          DrvAsmInterEnable0(BIT_LCD_FRAME_END_EN0);
 2246   1          DrvAsmInterEnable0(BIT_LCD_BUSY_FALL_EN0);
 2247   1          DrvAsmInterEnable0(BIT_LCD_BUSY_RISE_EN0);
 2248   1          DrvAsmInterEnable0(BIT_LCD_VBLANK_EN0);
 2249   1          DrvAsmInterEnable0(BIT_LCD_PANEL_CONFLICT_EN0);
 2250   1          DrvAsmInterEnable1(BIT_LCD_STB_TICK_EN1);
 2251   1      
 2252   1      //    DrvAsmSeStbtMask(0xFFFF);
 2253   1          DrvAsmSeStbtMask(0xFFFC); //1100
 2254   1          
 2255   1          DrvAsmSetIDReset();  //busy_id_max busy_id_min clear
 2256   1          
 2257   1      //    DBG_FLOW("\npAsmRegs->usAsmIntEn0:0x%x",pAsmRegs->usAsmIntEn0);
 2258   1          
 2259   1      #if 0  //启动扫描，每次扫描一个TP帧
                   DrvAsmInterDisable0(BIT_LCD_VSTART_EN0);      //关闭LCD_VSTART中断使能  
               
                   /* 加载Tab表*/
                   DrvLoadTabSingle(1,1);          // 第2个表， 第1个坑开始。
               
                   DrvAsmReq120hz_Small_LcdBusy(); //请求120hz
               
                   g_ucAramReadyFlag = 0;
               
                   while((DrvAsmGetSta()&LCD_RUN_STA)==1)     // 亮屏 lcd_run = 1
                   {     
                       if((DrvAsmGetSta1()&LCD_BUSY_STA)==0)// lcd busy 下沿开始启动
                       {
                           AppPanelParamUpdate();
               
                           DrvAsmScanStart();
                           DBG_FLOW("\nStartA");  
               
                           DBG_FLOW("\nHave Aram Ready:%d",g_ucAramReadyFlag);
                           //当前扫描的TP帧号
                           DBG_FLOW("\n9usAsmScanSta0: %04x",DrvAsmGetSta());          // 09  RO
                           DBG_FLOW("\n10usAsmScanSta1: %04x",DrvAsmGetSta1()); 
               
                           DBG_FLOW("\nReg6 0x%x ",DebugReadAFEOneReg(6));
C251 COMPILER V5.54.0.0,  FlowFactory                                                      26/05/17  20:21:08  PAGE 36  

                           DBG_FLOW("\nReg11 0x%x ",DebugReadAFEOneReg(11));
                           DBG_FLOW("\nReg12 0x%x ",DebugReadAFEOneReg(12)); 
                           // DBG_FLOW("\n0x%02x 0x%02x",g_usAsmIntFlag0,g_usAsmIntFlag1);
                           while((g_ucAramReadyFlag==0)); //&&(g_ucLcdStopFlag==0)&&(g_ucLcdSyncMissFlag==0));
                           g_ucAramReadyFlag = 0;
                               
                           DrvGetRawdata();
               
                           DrvAsmAramAvail(); // realse aram:  Asm可以往Aram写下一个tp帧数据                            
             -      
                       }
                     
                       DelayMs(10); 
                       g_RegHead.bits.ucDataReadToggle = 0;
                   }
               
               #else  //启动扫描，每次扫描多个TP帧
 2300   1      
 2301   1          DrvLoadTabMultiple(1,6,0,0,1,1);    // 120hz表1  启动扫描后，每次连续扫描2帧，第1次启动从1坑开始，第2
             -次启动从6坑开始，
 2302   1      
 2303   1      #if TEST_MUX_ABC_SACN
                   DrvLoadTabMultiple(1,4,7,0,2,1);    // 120hz表1  启动扫描后，每次连续扫描3帧，第1次启动从1坑开始，第2
             -次启动从4坑开始，第3次启动从7坑开始，
               #endif
 2306   1      #if TEST_MUX_ABCD_SACN
                   DrvLoadTabMultiple(1,3,5,7,3,1);    // 120hz表1  启动扫描后，每次连续扫描4帧，第1次1坑开始，第2次从4
             -涌始，第3次从7坑开始，第4次从7坑开始，
               #endif
 2309   1      
 2310   1          DrvAsmInterEnable0(BIT_LCD_VSTART_EN0);   //开启LCD_VSTART中断使能  
 2311   1                                              
 2312   1          DrvAsmReq120hz_Small_LcdBusy(); //请求120h
 2313   1          
 2314   1          g_ucAramReadyFlag = 0;
 2315   1      
 2316   1      //    AFECKEN = 0;   
 2317   1      //    DrvAsmAfeClkGateEn();         //测试自动门控
 2318   1      
 2319   1      #if TEST_SCAN_START_IN_VSTART_INT // Vstart 中断里启动扫描
 2320   1          while((DrvAsmGetSta()&LCD_RUN_STA)==1)    
 2321   1          {     
 2322   2              if((DrvAsmGetSta1()&LCD_BUSY_STA)==0)
 2323   2              {
 2324   3                  AppPanelParamUpdate();
 2325   3              
 2326   3                  g_ucAramReadyFlag = 0;
 2327   3      #if TEST_120_ARAM_READY_WAKEUP
                           ASM_MON_WKEN = 1;
                           DrvAsmWakeEnable0(BIT_LCD_ARAM_RDY_WAKE_EN0);       //8
                           DBG_FLOW("\n120 ARAM_RDY Standby in------");
                           DelayMs(100); // For Print            
               
                           DrvAsmScanStart();
                           DrvSysPowerStandby();
               #endif 
 2336   3      
 2337   3                  while(g_ucAramReadyFlag==0);
 2338   3                  DBG_FLOW("\n=======Afe_120Hz_Run====== :%d,0x%x",g_ucIntCount,g_usAsmIntSta);
 2339   3      
 2340   3                  //AppGetAsmState();
 2341   3      #if TEST_120_ARAM_READY_WAKEUP       
                           DrvAsmAramAvail(); // realse aram:  Asm可以往Aram写下一个tp帧数据
               #endif            
 2344   3                  DrvAsmInterDisable0(BIT_LCD_VSTART_EN0);      //Close  Vstart interrupt
 2345   3      
C251 COMPILER V5.54.0.0,  FlowFactory                                                      26/05/17  20:21:08  PAGE 37  

 2346   3                  AppShowRawdata();
 2347   3                  DrvInitRptRam();
 2348   3                  DrvInitAram(); 
 2349   3      
 2350   3                  //DBG_FLOW("\n0RegB 0x%x ",DebugReadAFEOneReg(11));
 2351   3      
 2352   3                  DrvAsmInterEnable0(BIT_LCD_VSTART_EN0);
 2353   3                  DrvAsmInterEnable0(BIT_LCD_ARAM_RDY_EN0);           
 2354   3              }
 2355   2              
 2356   2              g_RegHead.bits.ucDataReadToggle = 0;
 2357   2          }
 2358   1      
 2359   1      #endif
 2360   1      
 2361   1      
 2362   1      #endif
 2363   1      }
 2364          
 2365          /*******************************************************************************
 2366          *   Name: Afe_120Hz_Run_Monitor
 2367          *  Brief: 120hz亮屏情况，在硬件Monitro情况，上报数据到RptRam,用于触摸检测
 2368          *  Input: 
 2369          * Output: 
 2370          * Return: 
 2371          *******************************************************************************/
 2372          void Afe_120Hz_Run_Monitor(void)
 2373          { 
 2374   1          UINT16 XRAM usConfigValue;
 2375   1          static XRAM FristStart = 1;
 2376   1      
 2377   1          DrvAsmReq120hz_Small_LcdBusy(); //请求120h
 2378   1          
 2379   1          //启动扫描，每次扫描多个TP帧  
 2380   1          usConfigValue = 0xFF;
 2381   1          Drv_XsiWriteReg(pXSI0Regs, Addr_AFE_SX_P1_P2_CFG, usConfigValue, AFE_REG); // sx全驱
 2382   1          Drv_XsiWriteReg(pXSI1Regs, Addr_AFE_SX_P1_P2_CFG, usConfigValue, AFE_REG);
 2383   1          
 2384   1      #if TEMP_CLOSE_KEY
                   usConfigValue = 0x101;
                   Drv_XsiWriteReg(pXSI0Regs, Addr_AFE_SYS_CFG0, usConfigValue, AFE_REG); // close key enable
                   Drv_XsiWriteReg(pXSI1Regs, Addr_AFE_SYS_CFG0, usConfigValue, AFE_REG);
               #endif
 2389   1      
 2390   1          DrvAsmMonitoModeInit(); 
 2391   1      
 2392   1          DBG_FLOW("\n0Reg4 0x%x ",DebugReadAFEOneReg(4));
 2393   1          DBG_FLOW("\n0RegB 0x%x ",DebugReadAFEOneReg(11));
 2394   1          DBG_FLOW("\n0RegC 0x%x ",DebugReadAFEOneReg(12));
 2395   1      
 2396   1          DrvLoadTabMultiple(1,0,0,0,0,2);    // 120hz  Tab2  启动扫描后，每次连续扫描1帧，第1次启动从1坑开始
 2397   1      
 2398   1          DBG_FLOW("\nAfe_120Hz_Run_Monitor");  
 2399   1      
 2400   1          DrvAsmInterEnable0(BIT_LCD_FRAME_END_EN0);
 2401   1          DrvAsmInterEnable0(BIT_LCD_TCH_DET_EN0);
 2402   1          DrvAsmInterEnable0(BIT_LCD_ARAM_RDY_EN0);
 2403   1      
 2404   1      //    DBG_FLOW("\npAsmRegs->usAsmIntEn0:0x%x",pAsmRegs->usAsmIntEn0);
 2405   1                                                 
 2406   1          g_ucFrameEndFlag = 0;
 2407   1      
 2408   1          while((DrvAsmGetSta()&LCD_RUN_STA)==1)    
 2409   1          {   
 2410   2              if((DrvAsmGetSta1()&LCD_BUSY_STA)==0)
 2411   2              {
C251 COMPILER V5.54.0.0,  FlowFactory                                                      26/05/17  20:21:08  PAGE 38  

 2412   3                  g_usAsmIntFlag0 = 0;
 2413   3                  g_usAsmIntFlag1 = 0;
 2414   3                  DBG_FLOW("\nReg4 0x%x ",DebugReadAFEOneReg(4));
 2415   3                  DBG_FLOW("\nRegB 0x%x ",DebugReadAFEOneReg(11));
 2416   3                  DBG_FLOW("\nRegC 0x%x ",DebugReadAFEOneReg(12));
 2417   3                  DBG_FLOW("\n===120hz Montor===");    
 2418   3      
 2419   3                  DrvAsmScanStart();
 2420   3                      
 2421   3                  g_ucFrameEndFlag = 0;
 2422   3                
 2423   3                  while(!g_ucFrameEndFlag);
 2424   3                  
 2425   3                  DrvAsmInterDisable0(BIT_LCD_FRAME_END_EN0);       //关闭Frame end中断 
 2426   3                  DrvGetRptRamRawBase(); // Monitor模式不上报数据到ARAM,通过RptRam上报。
 2427   3                  DrvAsmInterEnable0(BIT_LCD_FRAME_END_EN0);
 2428   3       
 2429   3                  DelayMs(5);
 2430   3          
 2431   3                  g_RegHead.bits.ucDataReadToggle = 0;   
 2432   3      
 2433   3              }
 2434   2              
 2435   2              g_RegHead.bits.ucDataReadToggle = 0;
 2436   2          }
 2437   1      
 2438   1      }
 2439          
 2440          /*******************************************************************************
 2441          *   Name: Afe_120Hz_H_Clb
 2442          *  Brief: 
 2443          *  Input: 
 2444          * Output: 
 2445          * Return: 
 2446          *******************************************************************************/
 2447          void Afe_120Hz_H_Clb(void)
 2448          {
 2449   1      
 2450   1      #if TEST_MCAP_CB
                 UINT16 usConfigValue;
               
                 //配置rf_sel
                 usConfigValue = Drv_XsiReadReg(pXSIREG,Addr_ANA_STATIC_CFG0,AFE_REG);
                 usConfigValue &= 0x87FF;
               
                 usConfigValue |= (0x01<<13) +  (0x01<<11);            //写key的rf
                 Drv_XsiWriteReg(pXSI0Regs, Addr_ANA_STATIC_CFG0, usConfigValue, AFE_REG);
                 Drv_XsiWriteReg(pXSI1Regs, Addr_ANA_STATIC_CFG0, usConfigValue, AFE_REG);
               
                 Afe_Change_Tab3(2,CB_AFE_SCAN_MODE,18);   //CB,扫描方式
               
                 /*使能mcap,更新tab0以及afe reg相关参数*/
                 DrvMcapModeInit(1,3); 
               #else
 2466   1        Afe_Change_Tab3(0,CB_AFE_SCAN_MODE,2);   //CB,扫描方式
 2467   1      #endif
 2468   1      
 2469   1      
 2470   1          if(CB_AFE_SCAN_MODE == 4)//扫描方式5，大坑模式
 2471   1          {
 2472   2              DrvAsmReq60hz_Big_LcdBusy();     //申请为大坑模式
 2473   2          }
 2474   1          else
 2475   1          {
 2476   2              DrvAsmReq120hz_Small_LcdBusy();  //申请为小坑模式
 2477   2          }
C251 COMPILER V5.54.0.0,  FlowFactory                                                      26/05/17  20:21:08  PAGE 39  

 2478   1      
 2479   1          
 2480   1          Drv_XsiWriteReg(pXSI0Regs, Addr_AFE_SX_P1_P2_CFG, 0xFF, AFE_REG);//sx p1/p2 配成全驱
 2481   1          Drv_XsiWriteReg(pXSI1Regs, Addr_AFE_SX_P1_P2_CFG, 0xFF, AFE_REG);//sx p1/p2 配成全驱 
 2482   1      
 2483   1        
 2484   1          g_ucFrameEndFlag = FALSE;
 2485   1          g_ucAramReadyFlag = 0;
 2486   1          g_usAsmIntFlag0 = 0;
 2487   1      
 2488   1          /*设置CB校正的方向*/
 2489   1          DrvSetCbDir(1,1);  //0:顺时针 若raw<th cb变大;1:逆时针 若rawdata<th cb变小
 2490   1      
 2491   1          /*CB校正模式*/ 
 2492   1          DrvAsmSetCBAdjustMode(1);
 2493   1      
 2494   1          /*设置硬件CB校正的目标值*/
 2495   1          DrvAfeSetHCBTarget(10000,10000);
 2496   1      
 2497   1          /* 加载Tab表*/
 2498   1          DrvLoadTabCB(3,AFE_120HZ_MODE);
 2499   1      
 2500   1          DrvAsmInterEnable0(BIT_LCD_ARAM_RDY_EN0);//开启AramReady中断使能
 2501   1          DrvAsmInterEnable0(BIT_LCD_FRAME_END_EN0);//开启Frame end中断使能 
 2502   1          
 2503   1          DelayMs(20);
 2504   1      
 2505   1      //while(1)
 2506   1      {
 2507   2          /*启动扫描*/
 2508   2          DrvAsmScanStart();
 2509   2          
 2510   2          while(g_ucAramReadyFlag == 0);//CB校正模式，硬件数到8帧TP帧结束时才会发Aram Ready中断，这时候才表示CB
             -校正结束
 2511   2      
 2512   2          g_ucAramReadyFlag = 0;
 2513   2          
 2514   2          DelayMs(10000);
 2515   2      #if 1 //从ARAM中读出CB 
 2516   2          DrvGetAramCb();
 2517   2      #endif
 2518   2          DrvAsmAramAvail(); 
 2519   2          
 2520   2      #if 1 //从TAB表中读出CB
 2521   2          DelayMs(2000);    
 2522   2          DrvGetTabRamCb();
 2523   2          DelayMs(2000);
 2524   2      #endif
 2525   2      
 2526   2      #if 1 //从RptRam中后去Rawdata
 2527   2          DBG_FLOW("\nRead Rawdata from RptRam");
 2528   2          DrvGetRptRamRawBase();
 2529   2      #endif    
 2530   2      }
 2531   1      
 2532   1      #if 0//AFE阶段中，由于CB是由外部的CB决定的，CB的大小对RAWDATA实际上没影响，因此不再进行一次扫描，看RAWDAT
             -A的值是否接近设定值,在芯片验证阶段。则有影响
               
                   DelayMs(2000);
               
                   DBG_FLOW("\nAFE RUN");
                   
                   g_ucFrameEndFlag = FALSE;
                   g_ucAramReadyFlag = 0;
                   g_usAsmIntFlag0 = 0;
                   
C251 COMPILER V5.54.0.0,  FlowFactory                                                      26/05/17  20:21:08  PAGE 40  

                   /*正常工作模式*/ 
                   DrvAsmSetCBAdjustMode(0);    
               
                   /*单次扫描*/
                   DrvLoadTabSingle(0,0);
                   
                   DelayMs(20);
               
                   DBG_FLOW("\n\n");
                   /*启动扫描*/
                   
                   while(1)
                   {
                       DrvAsmScanStart();
                       while((g_ucAramReadyFlag == 0)||(g_ucFrameEndFlag == 0));
               
                       g_ucAramReadyFlag = 0;
                       g_ucFrameEndFlag = 0;
                       
                       DrvGetAramRawData();
                       
                       DrvAsmAramAvail();
                       
                       DelayMs(2000);
                   }
               #endif
 2568   1      
 2569   1          DBG_FLOW("\nCB FINISH");
 2570   1          HOLD;
 2571   1      }
 2572          
 2573          /*******************************************************************************
 2574          *   Name: Afe_120Hz_Run_Rtc_Monitor
 2575          *  Brief: 
 2576          *  Input: 
 2577          * Output: 
 2578          * Return: 
 2579          *******************************************************************************/
 2580          void Afe_120Hz_Run_RTC_Monitor(void)
 2581          {
 2582   1          UINT16 XRAM usConfigValue;
 2583   1          UINT8 XRAM usStartFlag = 1;
 2584   1          UINT8 XRAM ucScanMode = 7;      //扫描方式
 2585   1          UINT8 XRAM ucRtcMode = 1;       //0:auto_mode;1:lcd_start_mode
 2586   1      
 2587   1          if(ucScanMode == 4)//扫描方式5，大坑模式
 2588   1          {
 2589   2              DrvAsmReq60hz_Big_LcdBusy();     //申请为大坑模式
 2590   2          }
 2591   1          else
 2592   1          {
 2593   2              DrvAsmReq120hz_Small_LcdBusy();  //申请为小坑模式
 2594   2          }
 2595   1      
 2596   1        ASM_32K_EN = 1;
 2597   1      
 2598   1      #if TEST_MCAP_HWMON 
 2599   1        //配置rf_sel
 2600   1        usConfigValue = Drv_XsiReadReg(pXSIREG,Addr_ANA_STATIC_CFG0,AFE_REG);
 2601   1        usConfigValue &= 0x87FF;
 2602   1      
 2603   1        usConfigValue |= (0x01<<13) +  (0x01<<11);            //写key的rf
 2604   1        Drv_XsiWriteReg(pXSI0Regs, Addr_ANA_STATIC_CFG0, usConfigValue, AFE_REG);
 2605   1        Drv_XsiWriteReg(pXSI1Regs, Addr_ANA_STATIC_CFG0, usConfigValue, AFE_REG);
 2606   1        
 2607   1          Afe_Change_Tab3(2,ucScanMode,13);   //HW MON,扫描方式   
C251 COMPILER V5.54.0.0,  FlowFactory                                                      26/05/17  20:21:08  PAGE 41  

 2608   1      
 2609   1        /*使能mcap,更新tab0以及afe reg相关参数*/
 2610   1        DrvMcapModeInit(1,3); 
 2611   1      #else
                   Afe_Change_Tab3(1,ucScanMode,2);   //HW MON,扫描方式  
               
               #endif  
 2615   1      
 2616   1          SEL_32K_SRC = 1;
 2617   1          Drv_Rtc_Init(ucRtcMode);
 2618   1      
 2619   1      #if 1//PWR_EN
 2620   1          ANACON8 = 0xFF;
 2621   1          ANACON9 = 0xFF;
 2622   1          DrvAsmSetPwrOn();
 2623   1      #endif
 2624   1      
 2625   1          DBG_FLOW("\nRTC MONITOR");
 2626   1          usConfigValue = 0xFF;
 2627   1          Drv_XsiWriteReg(pXSI0Regs, Addr_AFE_SX_P1_P2_CFG, usConfigValue, AFE_REG);//sx全驱
 2628   1          Drv_XsiWriteReg(pXSI1Regs, Addr_AFE_SX_P1_P2_CFG, usConfigValue, AFE_REG);//sx全驱
 2629   1          
 2630   1        /*改变tab表中的触摸阈值*/
 2631   1          DrvSetTabMonThr(0xfff,20,3);
 2632   1      
 2633   1          DrvAsmRtcMonitoModeInit();
 2634   1          
 2635   1          P0_4 = 0;
 2636   1          DelayMs(10);
 2637   1          P0_4 = 1;
 2638   1          DelayMs(10);
 2639   1          P0_4 = 0;
 2640   1          DelayMs(10);    
 2641   1      
 2642   1          
 2643   1          /*不能用*/
 2644   1          RTC_CNT_WKEN = 0;
 2645   1                           
 2646   1          DBG_FLOW("\n\nrtc monitor");
 2647   1               
 2648   1          DelayMs(100);
 2649   1      
 2650   1          DrvAsmClrInt();
 2651   1          g_ucFrameEndFlag = 0;
 2652   1          g_usAsmIntFlag0 = 0;
 2653   1          g_usAsmIntFlag1 = 0;
 2654   1          g_ucTimeOutFlag = 0;
 2655   1      
 2656   1      #if PWR_EN
 2657   1          DrvAsmSetHwMonPwrEn(1);                                //设置在硬件monitor下，控制上下电时序。1:控制;
             -0:不控制
 2658   1      #else
                   DrvAsmSetHwMonPwrEn(0);                                //设置在硬件monitor下，控制上下电时序。1:控制;
             -0:不控制
               #endif
 2661   1      
 2662   1          //while(ucAfeRunMode == TP_FREE_RUN_MODE) // 表示LCD灭屏
 2663   1          //while(1)
 2664   1          {
 2665   2                  
 2666   2              RTC_CNT_WKEN = 0;        //RTC int0唤       
 2667   2              ASM_MON_WKEN = 1;        //scan mon int0唤醒
 2668   2      
 2669   2              if(usStartFlag)
 2670   2              {
 2671   3                  //刷base以后才能配置进入hw mon
C251 COMPILER V5.54.0.0,  FlowFactory                                                      26/05/17  20:21:08  PAGE 42  

 2672   3                  DrvAsmSetRtcMonitorMode(TRUE);                          //1:开启rtc monitor模式        
 2673   3                  P0_4 = 1;
 2674   3                  DelayMs(1);            
 2675   3                  P0_4 = 0;
 2676   3                  if(ucRtcMode == 0)
 2677   3                  {
 2678   4                      RTC_WP = 1;
 2679   4                      RTC_START = 1;
 2680   4                  }
 2681   3                  else
 2682   3                  {
 2683   4                      LCD_START_EN = 1;
 2684   4                  }
 2685   3                  usStartFlag = 0;
 2686   3              }
 2687   2      
 2688   2              //关闭AFE时钟，让RTC定时控制
 2689   2      
 2690   2      #if 1
 2691   2              AFEACKEN = 1;
 2692   2              AFECKEN  = 0;     
 2693   2              AFESCKEN = 0;  
 2694   2              
 2695   2              //DrvSysPowerStandby();      
 2696   2              DrvSysPowerStop();
 2697   2              AFEACKEN = 1;
 2698   2              AFECKEN  = 1;     
 2699   2              AFESCKEN = 1;          
 2700   2      
 2701   2              //DBG_FLOW("\nexit stop"); 
 2702   2      #endif
 2703   2              while((!g_ucTimeOutFlag)&&(!g_ucTchDetFlag));
 2704   2              DrvAsmSetRtcMonitorMode(FALSE);        
 2705   2      
 2706   2              P0_4 = 1;
 2707   2              while(RTC_START_STA == 0);
 2708   2              RTC_WP = 1;
 2709   2              RTC_CLR = 1;
 2710   2      
 2711   2              if(ucRtcMode)
 2712   2              {
 2713   3                  LCD_START_EN = 0;
 2714   3              }
 2715   2      
 2716   2              DelayMs(10); 
 2717   2              
 2718   2              DBG_FLOW("\nwake up-------------");
 2719   2              DBG_FLOW("\nWake up intflag: 0x%x 0x%x",g_usAsmIntFlag0,g_usAsmIntFlag1);
 2720   2              DBG_FLOW("\niwksta:%02x",g_ucState0);
 2721   2              
 2722   2              DelayMs(5);
 2723   2              if ((g_usAsmIntFlag0 &0x08) == 0x08)
 2724   2              {
 2725   3                  DBG_FLOW("\n*************Mon Det %02x",g_usAsmIntFlag0);
 2726   3                  DelayMs(1000);
 2727   3                  g_usAsmIntFlag0 = 0x00;            
 2728   3              }
 2729   2      
 2730   2              if(g_ucTimeOutFlag)
 2731   2              {
 2732   3                  DBG_FLOW("\n*************Mon Timeout %02x",g_usAsmIntFlag1);
 2733   3                  DelayMs(1000);
 2734   3              }
 2735   2      
 2736   2              g_ucTimeOutFlag = 0;
 2737   2              g_ucTchDetFlag = 0;
C251 COMPILER V5.54.0.0,  FlowFactory                                                      26/05/17  20:21:08  PAGE 43  

 2738   2              DBG_FLOW("\nRTC wake\n");
 2739   2              
 2740   2              DrvGetRptRamRawBase();
 2741   2      
 2742   2              g_ucFrameEndFlag = 0;
 2743   2              g_usAsmIntFlag0 = 0;
 2744   2              g_usAsmIntFlag1 = 0;
 2745   2      
 2746   2              DelayMs(1000);
 2747   2              while(1);
 2748   2              //g_RegHead.bits.ucDataReadToggle = 0;
 2749   2          }
 2750   1      }
 2751          
 2752          /*******************************************************************************
 2753          *   Name: Mcap_120Hz_Run
 2754          *  Brief: 
 2755          *  Input: 
 2756          * Output: 
 2757          * Return: 
 2758          *******************************************************************************/
 2759          void Mcap_120Hz_Run()
 2760          {
 2761   1          static XRAM getBaseCount = 0;
 2762   1          static XRAM FristStart = 1;
 2763   1          UINT16 XRAM usConfigValue;
 2764   1          UINT8 XRAM ucTPFramePerScan = 0;
 2765   1          UINT8 ucTabId = 3;
 2766   1          UINT8 ucTestMode = 1;//0:测试模式;1:普通模式
 2767   1          UINT8 ucScanNum = 13;
 2768   1          UINT8 ucScanMode = 0;//扫描方式
 2769   1          UINT16 i;   
 2770   1      
 2771   1          Afe_Change_Tab3(2,ucScanMode,ucScanNum );   //MCAP,扫描方式5
 2772   1              
 2773   1          usConfigValue = 0xFF;
 2774   1          Drv_XsiWriteReg(pXSI0Regs, Addr_AFE_SX_P1_P2_CFG, usConfigValue, AFE_REG);
 2775   1          Drv_XsiWriteReg(pXSI1Regs, Addr_AFE_SX_P1_P2_CFG, usConfigValue, AFE_REG);
 2776   1      
 2777   1      #if 1
 2778   1          //配置rf_sel
 2779   1          usConfigValue = Drv_XsiReadReg(pXSIREG,Addr_ANA_STATIC_CFG0,AFE_REG);
 2780   1          usConfigValue &= 0x87FF;
 2781   1      
 2782   1          usConfigValue |= (0x01<<13) +  (0x01<<11);                      //写key的rf
 2783   1          Drv_XsiWriteReg(pXSI0Regs, Addr_ANA_STATIC_CFG0, usConfigValue, AFE_REG);
 2784   1          Drv_XsiWriteReg(pXSI1Regs, Addr_ANA_STATIC_CFG0, usConfigValue, AFE_REG);
 2785   1      
 2786   1          DBG_FLOW("REG_36:%04x",usConfigValue);
 2787   1      #endif
 2788   1      
 2789   1          /*使能mcap,更新tab0以及afe reg相关参数*/
 2790   1          DrvMcapModeInit(1,ucTabId);
 2791   1          /* 加载Tab表*/
 2792   1          //DrvLoadTabSingle(ucTabId,0);            // 表3  启动后，每次扫描1帧
 2793   1      
 2794   1          if(ucScanMode == 4)//扫描方式5，大坑模式
 2795   1          {
 2796   2              DrvAsmReq60hz_Big_LcdBusy();
 2797   2              DrvLoadTabMultiple(1,2,0,0,1,ucTabId);
 2798   2          }
 2799   1          else
 2800   1          {
 2801   2              DrvAsmReq120hz_Small_LcdBusy();
 2802   2              DrvLoadTabMultiple(1,6,0,0,1,ucTabId);        
 2803   2          } 
C251 COMPILER V5.54.0.0,  FlowFactory                                                      26/05/17  20:21:08  PAGE 44  

 2804   1          
 2805   1          DrvMcapSetTestMode(ucTestMode,1);          //0为开启测试模式,1为普通模式,选择输出key2   
 2806   1      
 2807   1          DrvAsmInterEnable0(BIT_LCD_ARAM_RDY_EN0);//开启AramReady中断使能
 2808   1          DrvAsmInterEnable0(BIT_LCD_PANEL_CONFLICT_EN0);//开启屏体冲突中断使能
 2809   1      
 2810   1          g_ucAramReadyFlag = 0;
 2811   1      
 2812   1      #if PWR_EN
 2813   1          ANACON8 = 0xFF;
 2814   1          ANACON9 = 0xFF;
 2815   1          DrvAsmSetPwrOn();
 2816   1      #endif
 2817   1      
 2818   1          while(ucAfeRunMode == TP_120HZ_RUN_MODE) // 表示LCD灭屏
 2819   1          {
 2820   2          
 2821   2      #if 1
 2822   2              ARAM_SEL = 1;
 2823   2              for(i = 0; i < 0x500; i++)
 2824   2              {
 2825   3                  *(UINT8 *)(0xA000 + i) = 0;//清除aram
 2826   3              }
 2827   2              ARAM_SEL = 0;
 2828   2      #endif
 2829   2          
 2830   2              DrvAsmScanStart();
 2831   2      
 2832   2              for(i = 0; i < 2; i++)
 2833   2              {
 2834   3                  while(!g_ucAramReadyFlag);
 2835   3                  g_ucAramReadyFlag = 0;
 2836   3                  DBG_FLOW("\nHave Aram Ready");
 2837   3      
 2838   3                  DrvMcapReadSta(g_pMcapPara);
 2839   3                  if(g_pMcapPara->usErrFlg)
 2840   3                  {
 2841   4                      DBG_FLOW("\nMcap Scan Err:%01x",g_pMcapPara->usErrSta);
 2842   4                      DBG_FLOW("\n");
 2843   4                  }
 2844   3                  else
 2845   3                  {           
 2846   4                      if(ucTestMode == 0)
 2847   4                      {
 2848   5                          if(g_pMcapPara->usSampl_6)
 2849   5                          {
 2850   6                              DrvGetAdcData(ucScanNum * 6);
 2851   6                          }
 2852   5                          else
 2853   5                          {
 2854   6                              DrvGetAdcData(ucScanNum * 8);
 2855   6                          }
 2856   5                      }
 2857   4                      else
 2858   4                      {
 2859   5                          DrvGetAramRawData();
 2860   5                      }           
 2861   4                  }
 2862   3                  
 2863   3                  DrvAsmAramAvail(); // realse aram:  Asm可以往Aram写下一个tp帧数据
 2864   3              }
 2865   2              
 2866   2      
 2867   2      #if 0//PWR_EN
                       DrvAsmSetPwrOff();       
               #endif        
C251 COMPILER V5.54.0.0,  FlowFactory                                                      26/05/17  20:21:08  PAGE 45  

 2870   2              DelayMs(2000);
 2871   2          }
 2872   1          
 2873   1      }
 2874          
 2875          
 2876          
 2877          
 2878          /*******************************************************************************
 2879          *   Name: Afe_Lcd_WakeUp_StandBy
 2880          *  Brief: 
 2881          *  Input: 
 2882          * Output: 
 2883          * Return: 
 2884          *******************************************************************************/
 2885          void Afe_Lcd_WakeUp_StandBy(void)
 2886          {
 2887   1          UINT16 XRAM usConfigValue;
 2888   1      
 2889   1          DBG_FLOW("\n====Afe_Lcd_WakeUp_StandBy====");
 2890   1      
 2891   1          usConfigValue = 0xFF;
 2892   1          Drv_XsiWriteReg(pXSI0Regs, Addr_AFE_SX_P1_P2_CFG, usConfigValue, AFE_REG);
 2893   1          Drv_XsiWriteReg(pXSI1Regs, Addr_AFE_SX_P1_P2_CFG, usConfigValue, AFE_REG);
 2894   1          
 2895   1          DrvAsmInterEnable0(BIT_LCD_ARAM_RDY_EN0);
 2896   1          DrvAsmInterEnable0(BIT_LCD_FRAME_END_EN0);
 2897   1      
 2898   1          DrvAsmInterDisable0(BIT_LCD_VSTART_EN0);   //Close Vstart interrupt
 2899   1      
 2900   1      #if TEST_LCD_RUN_FALL_WAKEUP   
                   DrvAsmInterEnable0(BIT_LCD_RUN_FALL_EN0);     
                   DrvAsmWakeEnable0(BIT_LCD_RUN_FALL_WAKE_EN0);        //1
               #endif
 2904   1      #if TEST_LCD_RUN_RISE_WAKEUP 
                   DrvAsmInterEnable0(BIT_LCD_RUN_RISE_EN0);
                   DrvAsmWakeEnable0(BIT_LCD_RUN_RISE_WAKE_EN0);        //0  
               #endif
 2908   1      #if TEST_LCD_DSTB_FAIL_WAKEUP
                   DrvAsmInterEnable0(BIT_LCD_DSTB_FAIL_EN0);  
                   DrvAsmWakeEnable0(BIT_LCD_DSTB_FAIL_WAKE_EN0);       //12
               #endif  
 2912   1      #if TEST_LCD_DSTB_RISE_WAKEUP
                   DrvAsmInterEnable0(BIT_LCD_DSTB_RISE_EN0);  
                   DrvAsmWakeEnable0(BIT_LCD_DSTB_RISE_WAKE_EN0);        //11
               #endif                                
 2916   1      #if TEST_LCD_VDO_MODE_FALL_WAKEUP                                 
                   DrvAsmInterEnable1(BIT_LCD_VDO_MODE_FALL_EN1);
                   DrvAsmWakeEnable1(BIT_LCD_VDO_MODE_FALL_WAKE_EN1);    //8
               #endif    
 2920   1      #if TEST_LCD_VDO_MODE_RISE_WAKEUP 
                   DrvAsmInterEnable1(BIT_LCD_VDO_MODE_RISE_EN1);
                   DrvAsmWakeEnable1(BIT_LCD_VDO_MODE_RISE_WAKE_EN1);    //7
               #endif
 2924   1      #if TEST_LCD_IDLE_MODE_FALL_WAKEUP 
                   DrvAsmInterEnable1(BIT_LCD_IDLE_MODE_FALL_EN1);
                   DrvAsmWakeEnable1(BIT_LCD_IDLE_MODE_FALL_WAKE_EN1);   //6
               #endif
 2928   1      #if TEST_LCD_IDLE_MODE_RISE_WAKEUP
                   DrvAsmInterEnable1(BIT_LCD_IDLE_MODE_RISE_EN1);
                   DrvAsmWakeEnable1(BIT_LCD_IDLE_MODE_RISE_WAKE_EN1);   //5
               #endif
 2932   1      #if TEST_LCD_3D_MODE_FALL_WAKEUP 
                   DrvAsmInterEnable1(BIT_LCD_3D_MODE_FALL_EN1);
                   DrvAsmWakeEnable1(BIT_LCD_3D_MODE_FALL_WAKE_EN1);     //4
               #endif
C251 COMPILER V5.54.0.0,  FlowFactory                                                      26/05/17  20:21:08  PAGE 46  

 2936   1      #if TEST_LCD_3D_MODE_RISE_WAKEUP
                   DrvAsmInterEnable1(BIT_LCD_3D_MODE_RISE_EN1);
                   DrvAsmWakeEnable1(BIT_LCD_3D_MODE_RISE_WAKE_EN1);     //3
               #endif
 2940   1      
 2941   1      //    DBG_FLOW("\nWakeEn0:0x%x WakeEn1:0x%x",pAsmRegs->usAsmIntWakeEn0,pAsmRegs->usAsmIntWakeEn1);       
             -                                                                                        
 2942   1          g_ucAramReadyFlag = 0;
 2943   1          
 2944   1          while(1) // 表示LCD灭屏
 2945   1          {     
 2946   2              if(ucAfeRunMode == TP_120HZ_RUN_MODE)
 2947   2              { 
 2948   3                  //Vstart 中启动扫描
 2949   3                  DrvAsmInterEnable0(BIT_LCD_VSTART_EN0);
 2950   3               
 2951   3                  /* 加载Tab表*/
 2952   3                  DrvLoadTabMultiple(1,6,0,0,1,1);    // 120hz表1  启动扫描后，每次连续扫描1帧，第1次启动从1坑
             -始.
 2953   3                  
 2954   3                  DBG_FLOW("\n120hz Wake in------");
 2955   3                  DelayMs(100); // For Print
 2956   3                  EA = 0;
 2957   3                  ASM_MON_WKEN = 1;
 2958   3                  DrvSysPowerStandby();
 2959   3      
 2960   3                  EA = 1;
 2961   3                  DBG_FLOW("\n120hz---------ucWake up:0x%x",ucAfeRunMode);            
 2962   3              }
 2963   2      
 2964   2              if(ucAfeRunMode == TP_FREE_RUN_MODE)
 2965   2              {            
 2966   3                  DBG_FLOW("\nFree Wake in------");
 2967   3                  DelayMs(100); // For Print
 2968   3                  EA = 0;
 2969   3                  ASM_MON_WKEN = 1;
 2970   3                  DrvSysPowerStandby();
 2971   3      
 2972   3                  EA = 1;
 2973   3                  DBG_FLOW("\nFree---------ucWake up:0x%x",ucAfeRunMode);           
 2974   3              }
 2975   2                   
 2976   2              g_RegHead.bits.ucDataReadToggle = 0;   
 2977   2          }
 2978   1      }
 2979          
 2980          void Afe_TestOneChannelAdc(void)
 2981          {
 2982   1          UINT16 XRAM usConfigValue;
 2983   1      
 2984   1          usConfigValue = 0xFF;
 2985   1          Drv_XsiWriteReg(pXSI0Regs, Addr_AFE_SX_P1_P2_CFG, usConfigValue, AFE_REG);
 2986   1          Drv_XsiWriteReg(pXSI1Regs, Addr_AFE_SX_P1_P2_CFG, usConfigValue, AFE_REG);
 2987   1      
 2988   1          DrvAsmInterEnable0(BIT_LCD_ARAM_RDY_EN0);
 2989   1          DrvAsmInterEnable0(BIT_LCD_FRAME_END_EN0);
 2990   1      
 2991   1          DrvAfeSetOneChannelTestMode(1,1,0);   //Test TP通道， 通道号1.
 2992   1      //    DrvAfeSetOneChannelTestMode(1,1,1);     //Test Key通道， 通道号1.    key键无SH,固定为双边采样，数字
             -相减
 2993   1         
 2994   1          g_ucAramReadyFlag = 0;
 2995   1          
 2996   1          while(1) // 表示LCD灭屏
 2997   1          {     
 2998   2              if(ucAfeRunMode == TP_FREE_RUN_MODE)
C251 COMPILER V5.54.0.0,  FlowFactory                                                      26/05/17  20:21:08  PAGE 47  

 2999   2              {                      
 3000   3                  /* 加载Tab表*/
 3001   3                  DrvLoadTabMultiple(1,0,0,0,0,0);    // Freerun表0  启动后，每次扫描1帧
 3002   3                  DrvAsmScanStart();
 3003   3                  
 3004   3                  while(!g_ucAramReadyFlag);
 3005   3                  g_ucAramReadyFlag = 0;
 3006   3                  
 3007   3                  DrvGetRptRamRawBase();  
 3008   3                  DrvGetRawdata(); 
 3009   3                  
 3010   3                  DrvInitRptRam();
 3011   3                  DrvInitAram();
 3012   3                  
 3013   3                  DrvAsmAramAvail(); // realse aram:  Asm可以往Aram写下一个tp帧数据, 触发AramReady中断
 3014   3      
 3015   3      //            DBG_FLOW("\nFreeRun:0x%x",g_ucAramReadyFlag);
 3016   3                  DBG_FLOW("\nReg4 0x%x ",DebugReadAFEOneReg(4));
 3017   3                  DBG_FLOW("\nReg51 0x%x ",DebugReadAFEOneReg(51)); //0x33
 3018   3      
 3019   3      
 3020   3              }
 3021   2          }
 3022   1      }
 3023          
 3024          void Afe_LVDESDWakeUp_Stop(void)
 3025          {
 3026   1          UINT16 XRAM usConfigValue;
 3027   1      
 3028   1          DBG_FLOW("\n====Afe_LVDESDWakeUp_Stop====");
 3029   1      
 3030   1          usConfigValue = 0xFF;
 3031   1          Drv_XsiWriteReg(pXSI0Regs, Addr_AFE_SX_P1_P2_CFG, usConfigValue, AFE_REG);
 3032   1          Drv_XsiWriteReg(pXSI1Regs, Addr_AFE_SX_P1_P2_CFG, usConfigValue, AFE_REG);
 3033   1      
 3034   1          DrvAsmInterEnable0(BIT_LCD_ARAM_RDY_EN0);
 3035   1          DrvAsmInterEnable0(BIT_LCD_FRAME_END_EN0);
 3036   1          DrvAsmInterEnable0(BIT_LCD_VSTART_EN0);
 3037   1      
 3038   1          
 3039   1          g_ucAramReadyFlag = 0;
 3040   1          
 3041   1          while(1)  
 3042   1          {     
 3043   2              if(ucAfeRunMode == TP_120HZ_RUN_MODE)
 3044   2              { 
 3045   3                  //Vstart 中启动扫描
 3046   3                  DrvAsmInterEnable0(BIT_LCD_VSTART_EN0);
 3047   3               
 3048   3                  /* 加载Tab表*/
 3049   3                  DrvLoadTabMultiple(1,6,0,0,1,1);    // 120hz表1  启动扫描后，每次连续扫描1帧，第1次启动从1坑
             -始.
 3050   3                  
 3051   3                  DBG_FLOW("\n120hz LVD ESD Wake in------");
 3052   3                  DelayMs(100); // For Print
 3053   3                  EA = 0;
 3054   3      
 3055   3                  //DrvSysPowerIdle();
 3056   3                  //DrvSysPowerStandby();
 3057   3                  DrvSysPowerStop();
 3058   3                  EA = 1;
 3059   3                  DBG_FLOW("\n120hz ucWake up LCD_ESD_STA:0x%x",ESD_STA);
 3060   3                  
 3061   3              }
 3062   2               
 3063   2          }
C251 COMPILER V5.54.0.0,  FlowFactory                                                      26/05/17  20:21:08  PAGE 48  

 3064   1      }
 3065          
 3066          void Afe_LcdRunWakeUp_Test(void)
 3067          {
 3068   1          UINT16 XRAM usConfigValue;
 3069   1      
 3070   1          DBG_FLOW("\n====Afe_LcdRunWakeUp_Test====");
 3071   1      
 3072   1          usConfigValue = 0xFF;
 3073   1          Drv_XsiWriteReg(pXSI0Regs, Addr_AFE_SX_P1_P2_CFG, usConfigValue, AFE_REG);
 3074   1          Drv_XsiWriteReg(pXSI1Regs, Addr_AFE_SX_P1_P2_CFG, usConfigValue, AFE_REG);
 3075   1      
 3076   1          DrvAsmInterEnable0(BIT_LCD_ARAM_RDY_EN0);
 3077   1          DrvAsmInterEnable0(BIT_LCD_FRAME_END_EN0);
 3078   1          DrvAsmInterEnable0(BIT_LCD_VSTART_EN0);
 3079   1          DrvAsmInterEnable0(BIT_LCD_RUN_FALL_EN0);  
 3080   1          DrvAsmInterEnable0(BIT_LCD_RUN_RISE_EN0);
 3081   1          
 3082   1          g_ucAramReadyFlag = 0;
 3083   1          
 3084   1          while(1) // 表示LCD灭屏
 3085   1          {     
 3086   2              if(ucAfeRunMode == TP_FREE_RUN_MODE)
 3087   2              {          
 3088   3                  DrvAsmInterDisable0(BIT_LCD_VSTART_EN0); // Close VStart中断  
 3089   3                  
 3090   3                  /* 加载Tab表*/
 3091   3                  DrvLoadTabMultiple(1,0,0,0,0,0);    // Freerun表0  启动后，每次扫描1帧
 3092   3                  DrvAsmScanStart();
 3093   3                  
 3094   3                  while(!g_ucAramReadyFlag);
 3095   3                  g_ucAramReadyFlag = 0;
 3096   3      
 3097   3                  DrvAsmAramAvail(); // realse aram:  Asm可以往Aram写下一个tp帧数据, 触发AramReady中断
 3098   3      
 3099   3                  DBG_FLOW("\nFreeRun Wake in------");
 3100   3                  DelayMs(100); // For Print
 3101   3                  EA = 0;
 3102   3                  LCD_TIM_WKEN = 1;
 3103   3                  //DrvSysPowerIdle();
 3104   3                  //DrvSysPowerStandby();
 3105   3                  DrvSysPowerStop();
 3106   3                  EA = 1;
 3107   3                  DBG_FLOW("\nFreeRun---------ucWake up:0x%x",ucAfeRunMode);
 3108   3      
 3109   3              }
 3110   2              else if(ucAfeRunMode == TP_120HZ_RUN_MODE)
 3111   2              { 
 3112   3                  //Vstart 中启动扫描
 3113   3                  DrvAsmInterEnable0(BIT_LCD_VSTART_EN0);
 3114   3               
 3115   3                  /* 加载Tab表*/
 3116   3                  DrvLoadTabMultiple(1,6,0,0,1,1);    // 120hz表1  启动扫描后，每次连续扫描1帧，第1次启动从1坑
             -始.
 3117   3                  
 3118   3                  DBG_FLOW("\n120hz Wake in------");
 3119   3                  DelayMs(100); // For Print
 3120   3                  EA = 0;
 3121   3                  LCD_TIM_WKEN = 1;
 3122   3                  //DrvSysPowerIdle();
 3123   3                  //DrvSysPowerStandby();
 3124   3                  DrvSysPowerStop();
 3125   3                  EA = 1;
 3126   3                  DBG_FLOW("\n120hz---------ucWake up:0x%x",ucAfeRunMode);
 3127   3                  
 3128   3              }
C251 COMPILER V5.54.0.0,  FlowFactory                                                      26/05/17  20:21:08  PAGE 49  

 3129   2                        
 3130   2              g_RegHead.bits.ucDataReadToggle = 0;   
 3131   2          }
 3132   1      }
 3133          
 3134          
 3135          void Afe_LcdDSTBWakeUp_Test(void)
 3136          {
 3137   1          UINT16 XRAM usConfigValue;
 3138   1      
 3139   1          DBG_FLOW("\n====Afe_LcdDSTBWakeUp_Test====");
 3140   1      
 3141   1          usConfigValue = 0xFF;
 3142   1          Drv_XsiWriteReg(pXSI0Regs, Addr_AFE_SX_P1_P2_CFG, usConfigValue, AFE_REG);
 3143   1          Drv_XsiWriteReg(pXSI1Regs, Addr_AFE_SX_P1_P2_CFG, usConfigValue, AFE_REG);
 3144   1      
 3145   1          DrvAsmInterEnable0(BIT_LCD_ARAM_RDY_EN0);
 3146   1          DrvAsmInterEnable0(BIT_LCD_FRAME_END_EN0);
 3147   1          DrvAsmInterEnable0(BIT_LCD_VSTART_EN0);
 3148   1      
 3149   1      
 3150   1          g_ucAramReadyFlag = 0;
 3151   1          
 3152   1          while(1)
 3153   1          {     
 3154   2              if(ucAfeRunMode == TP_120HZ_RUN_MODE) 
 3155   2              { 
 3156   3                  //Vstart 中启动扫描
 3157   3                  DrvAsmInterEnable0(BIT_LCD_VSTART_EN0);
 3158   3                  //DrvAsmInterDisable0(BIT_LCD_VSTART_EN0);  //for test idle
 3159   3               
 3160   3                  /* 加载Tab表*/
 3161   3                  DrvLoadTabMultiple(1,6,0,0,1,1);    // 120hz表1  启动扫描后，每次连续扫描1帧，第1次启动从1坑
             -始.
 3162   3                  
 3163   3                  DBG_FLOW("\n120hz DeepStandBy Wake in------");
 3164   3                  DelayMs(100); // For Print
 3165   3                  EA = 0;
 3166   3                  LCD_TIM_WKEN = 1;
 3167   3                  //DrvSysPowerIdle();
 3168   3                  //DrvSysPowerStandby();
 3169   3                  DrvSysPowerStop();
 3170   3                  EA = 1;
 3171   3                  DBG_FLOW("\n120hz---ucWake up STA:0x%x CGU5:0x%x",IWKSTA,CGUCON5);           
 3172   3              }            
 3173   2          }
 3174   1      }
 3175          
 3176          void Afe_ALL_WakeUpStandby(void)
 3177          {
 3178   1          UINT16 XRAM usConfigValue;
 3179   1      
 3180   1          DBG_FLOW("\n====Afe_ALL_WakeUpStandby====");
 3181   1      
 3182   1          usConfigValue = 0xFF;
 3183   1          Drv_XsiWriteReg(pXSI0Regs, Addr_AFE_SX_P1_P2_CFG, usConfigValue, AFE_REG);
 3184   1          Drv_XsiWriteReg(pXSI1Regs, Addr_AFE_SX_P1_P2_CFG, usConfigValue, AFE_REG);
 3185   1      
 3186   1          g_ucAramReadyFlag = 0;
 3187   1          
 3188   1          while(1)
 3189   1          {     
 3190   2              if(ucAfeRunMode == TP_120HZ_RUN_MODE) 
 3191   2              { 
 3192   3                  //Vstart 中启动扫描
 3193   3                  //DrvAsmInterEnable0(BIT_LCD_VSTART_EN0);
C251 COMPILER V5.54.0.0,  FlowFactory                                                      26/05/17  20:21:08  PAGE 50  

 3194   3               
 3195   3                  /* 加载Tab表*/
 3196   3                  DrvLoadTabMultiple(1,6,0,0,1,1);    // 120hz表1  启动扫描后，每次连续扫描1帧，第1次启动从1坑
             -始.
 3197   3                  
 3198   3                  DrvAsmInterDisableAll();     // Close interrupt
 3199   3      
 3200   3                  DBG_FLOW("\n120hz  StandBy Wake in---->");
 3201   3                  DelayMs(100); // For Print
 3202   3                  EA = 0;
 3203   3                  ASM_MON_WKEN = 1;
 3204   3                  LCD_TIM_WKEN = 1;
 3205   3                  LCD_LVD_WKEN = 1;   //lvd,esd state状态会保持，中断进入后，相位翻转硬件会清状态。    
 3206   3                  LCD_ESD_WKEN = 1;
 3207   3                  DrvAsmInterEnableAll();     // Open interrupt
 3208   3      #if 1
 3209   3                  DrvAsmWakeDisable0(BIT_LCD_BUSY_FALL_WAKE_EN0);
 3210   3                  DrvAsmWakeDisable0(BIT_LCD_BUSY_RISE_WAKE_EN0);
 3211   3      
 3212   3                  DrvAsmWakeDisable0(BIT_LCD_VSTART_WAKE_EN0);
 3213   3                  DrvAsmWakeDisable0(BIT_LCD_VMID_WAKE_EN0);
 3214   3                  DrvAsmWakeDisable0(BIT_LCD_VEND_WAKE_EN0);
 3215   3                  DrvAsmWakeDisable0(BIT_LCD_VBLANK_WAKE_EN0);
 3216   3                  
 3217   3                  DrvAsmWakeDisable1(BIT_LCD_STB_TICK_WAKE_EN1);
 3218   3      #endif
 3219   3      
 3220   3                  
 3221   3                  DrvAsmInterDisable0(BIT_LCD_VSTART_EN0);  //for test standby,Stop Scan.
 3222   3      
 3223   3                  DrvSysPowerStandby();
 3224   3      
 3225   3                  EA = 1;
 3226   3                  DBG_FLOW("\n120hz>---ucWake up out STA:0x%x CGU5:0x%x",IWKSTA,CGUCON5);           
 3227   3              }            
 3228   2          }
 3229   1      }
 3230          
 3231          /*******************************************************************************
 3232          *   Name: Afe_LcdRun_Changed
 3233          *  Brief: Freerun , 亮屏切换，lcd 自己生成的信号，中断测试。
 3234          *  Input: 
 3235          * Output: 
 3236          * Return: 
 3237          *******************************************************************************/
 3238          void Afe_LcdRun_Changed(void)
 3239          {
 3240   1          static XRAM getBaseCount = 0; 
 3241   1          static XRAM FristStart = 1;
 3242   1          UINT16 XRAM usConfigValue;
 3243   1          UINT8 XRAM ucTPFramePerScan = 0;
 3244   1      
 3245   1          usConfigValue = 0xFF;
 3246   1          Drv_XsiWriteReg(pXSI0Regs, Addr_AFE_SX_P1_P2_CFG, usConfigValue, AFE_REG);
 3247   1          Drv_XsiWriteReg(pXSI1Regs, Addr_AFE_SX_P1_P2_CFG, usConfigValue, AFE_REG);
 3248   1      
 3249   1          DrvAsmInterEnable0(BIT_LCD_ARAM_RDY_EN0);
 3250   1          DrvAsmInterEnable0(BIT_LCD_FRAME_END_EN0);
 3251   1          DrvAsmInterDisable0(BIT_LCD_VSTART_EN0);  
 3252   1      //     DrvAsmInterEnable0(BIT_LCD_VSTART_EN0);  
 3253   1      #if 0
                   DrvAsmInterEnable0(BIT_LCD_VMID_EN0);  
                   DrvAsmInterEnable0(BIT_LCD_VEND_EN0);  
                   DrvAsmInterEnable0(BIT_LCD_VBLANK_EN0); 
                   DrvAsmInterEnable0(BIT_LCD_BUSY_FALL_EN0); 
                   DrvAsmInterEnable0(BIT_LCD_BUSY_RISE_EN0); 
C251 COMPILER V5.54.0.0,  FlowFactory                                                      26/05/17  20:21:08  PAGE 51  

               #endif
 3260   1      
 3261   1          DrvAsmInterEnable0(BIT_LCD_RUN_FALL_EN0);  
 3262   1          DrvAsmInterEnable0(BIT_LCD_RUN_RISE_EN0);
 3263   1      
 3264   1      // test INT
 3265   1      #if 1
 3266   1          DrvAsmInterEnable1(BIT_LCD_STB_TICK_EN1);   
 3267   1          DrvAsmInterEnable1(BIT_LCD_ODD_EVEN_FALL_EN1);
 3268   1          DrvAsmInterEnable1(BIT_LCD_ODD_EVEN_RISE_EN1);
 3269   1          DrvAsmInterEnable1(BIT_LCD_VDO_MODE_FALL_EN1);
 3270   1          DrvAsmInterEnable1(BIT_LCD_VDO_MODE_RISE_EN1);
 3271   1          DrvAsmInterEnable1(BIT_LCD_IDLE_MODE_FALL_EN1);
 3272   1          DrvAsmInterEnable1(BIT_LCD_IDLE_MODE_RISE_EN1);
 3273   1          DrvAsmInterEnable1(BIT_LCD_3D_MODE_FALL_EN1);
 3274   1          DrvAsmInterEnable1(BIT_LCD_3D_MODE_RISE_EN1);
 3275   1      
 3276   1      #endif
 3277   1      
 3278   1      //Test ESD,LVD, LCD_RUN, DSTB INT
 3279   1      #if 1
 3280   1          //LCD_LVD_PHASE = 1; // default1: 1:检测高电平    该寄存器已删除
 3281   1          //LCD_ESD_PHASE = 1;                              该寄存器已删除
 3282   1          DrvAsmSetPhase();
 3283   1      
 3284   1          LCD_ESD_WKEN = 1; //测试ESD中断0，要开启该enalbe
 3285   1          LCD_LVD_WKEN = 1; //测试LVD中断0，要开启该enalbe
 3286   1          DrvAsmInterEnable1(BIT_LCD_RUN_EN1);    // 控制中断4，LCD中断
 3287   1          DrvAsmInterEnable1(BIT_LCD_DSTB_EN1);   // 控制中断4，LCD中断
 3288   1      #endif
 3289   1       
 3290   1          DBG_FLOW("\nucAfeRunMode:0x%x",ucAfeRunMode);
 3291   1      
 3292   1          g_ucAramReadyFlag = 0;
 3293   1          
 3294   1          while(1) // 表示LCD灭屏
 3295   1          {     
 3296   2              if(ucAfeRunMode == TP_FREE_RUN_MODE)
 3297   2              {          
 3298   3                  DrvAsmInterDisable0(BIT_LCD_VSTART_EN0); // Close VStart中断  
 3299   3                  
 3300   3                  /* 加载Tab表*/
 3301   3                  DrvLoadTabMultiple(1,0,0,0,0,0);    // Freerun表0  启动后，每次扫描1帧
 3302   3                  DrvAsmScanStart();
 3303   3                  
 3304   3                  while(!g_ucAramReadyFlag);
 3305   3                  g_ucAramReadyFlag = 0;
 3306   3      
 3307   3                  DrvAsmAramAvail(); // realse aram:  Asm可以往Aram写下一个tp帧数据, 触发AramReady中断
 3308   3      
 3309   3      //            DBG_FLOW("\nFreeRun:0x%x",g_ucAramReadyFlag);
 3310   3      
 3311   3              }
 3312   2              else if(ucAfeRunMode == TP_120HZ_RUN_MODE)
 3313   2              {      
 3314   3                  /* 加载Tab表*/
 3315   3                  if(FristStart == 1)
 3316   3                  {
 3317   4                      //FristStart = 0;
 3318   4                      DrvLoadTabMultiple(1,6,0,0,1,1);    // 120hz表1  启动扫描后，每次连续扫描1帧，第1次启动从
             -1坑开始.
 3319   4                  }
 3320   3                  
 3321   3                  //Vstart 中启动扫描
 3322   3                  DrvAsmInterEnable0(BIT_LCD_VSTART_EN0);
 3323   3              }
C251 COMPILER V5.54.0.0,  FlowFactory                                                      26/05/17  20:21:08  PAGE 52  

 3324   2         
 3325   2      //        DBG_FLOW("\nucAfeRunMode:0x%x",ucAfeRunMode);
 3326   2      //        DBG_FLOW("\npAsmRegs->usAsmIntSta:0x%x",pAsmRegs->usAsmIntSta);
 3327   2      
 3328   2                      
 3329   2              g_RegHead.bits.ucDataReadToggle = 0;   
 3330   2          }
 3331   1      }
 3332          
 3333          void Afe_60Hz_120Hz_Changed(void)
 3334          {
 3335   1          /* 加载Tab表*/
 3336   1          DrvLoadTabSingle(1,0);
 3337   1          
 3338   1          while(1)
 3339   1          {
 3340   2              //TP_120HZRE = ~TP_120HZRE; //TP_120HZ_REQ^0
 3341   2              DelayMs(400);
 3342   2      
 3343   2              DrvAsmScanStart();
 3344   2                  
 3345   2              //DBG_FLOW("\n%02x,%02x,%02x,%02x",tmp,tmp2,INT_FLAG0,IWKSTA);
 3346   2              while((g_ucAramReadyFlag==0)&&(g_ucLcdStopFlag==0)&&(g_ucLcdSyncMissFlag==0));
 3347   2           
 3348   2      //      DrvGetRawdata();
 3349   2                      
 3350   2              g_ucAramReadyFlag = 0;
 3351   2      
 3352   2              g_RegHead.bits.ucDataReadToggle = 0;
 3353   2          }
 3354   1      }
 3355          
 3356          /*******************************************************************************
 3357          *   Name: TestXbus
 3358          *  Brief:
 3359          *  Input:
 3360          * Output:
 3361          * Return:
 3362          *******************************************************************************/
 3363          void TestXbus(void)
 3364          {
 3365   1          UINT16 XRAM i;
 3366   1          UINT16 XRAM ReadValue;
 3367   1      
 3368   1          DBG_FLOW("\nXbus test %02X",CGUCON1);
 3369   1          
 3370   1      //    RLDMACKEN = 1;
 3371   1      
 3372   1          for(i = 0; i<100; i++)
 3373   1          {
 3374   2              DrvXbus_WriteLcdReg(0xF680,(UINT8)i);
 3375   2      
 3376   2              ReadValue = DrvXbus_ReadLcdReg(0xF680);
 3377   2              DBG_FLOW("\nXbus Write:%d Read:%d",i,ReadValue);       
 3378   2          } 
 3379   1          while(1);
 3380   1      }
 3381          
 3382          /*******************************************************************************
 3383          *   Name: Test_AfeRegWrite
 3384          *  Brief:
 3385          *  Input:
 3386          * Output:
 3387          * Return:
 3388          *******************************************************************************/
 3389          void Test_AfeRegWrite(UINT16 addr,UINT16 mask0,UINT16 mask1)
C251 COMPILER V5.54.0.0,  FlowFactory                                                      26/05/17  20:21:08  PAGE 53  

 3390          {
 3391   1          UINT16 tmp;
 3392   1          UINT16 cnt_back;
 3393   1          UINT16 cnt;
 3394   1          UINT16 BackUp;
 3395   1          BOOLEAN flag;
 3396   1      
 3397   1          flag = TRUE;
 3398   1          BackUp = Drv_XsiReadReg(pXSI0Regs,addr,AFE_REG);
 3399   1          for (cnt = 0; cnt < 0xffff; cnt++)
 3400   1          {
 3401   2              cnt_back = cnt;
 3402   2              cnt &= mask0;
 3403   2              cnt |= mask1;
 3404   2      
 3405   2              Drv_XsiWriteReg(pXSI0Regs,addr,cnt,AFE_REG);
 3406   2              tmp = Drv_XsiReadReg(pXSI0Regs,addr,AFE_REG);
 3407   2              if (tmp != cnt)
 3408   2              {
 3409   3                  Drv_XsiWriteReg(pXSI0Regs,addr,BackUp,AFE_REG);
 3410   3                  DBG_FLOW("\n\Error rREG_%02d,write:%04x,read:%04x",addr,cnt,tmp);
 3411   3                  DelayMs(10);
 3412   3                  flag = 0;
 3413   3                  break;
 3414   3              }
 3415   2              cnt = cnt_back;
 3416   2          }
 3417   1          if (flag)
 3418   1          {
 3419   2             DBG_FLOW("\n\rREG_%02d write ok!",addr);
 3420   2          }
 3421   1          Drv_XsiWriteReg(pXSI0Regs,addr,BackUp,AFE_REG);
 3422   1      }
 3423          
 3424          /*******************************************************************************
 3425          *   Name: Test_Afe_BaseRam
 3426          *  Brief:
 3427          *  Input:
 3428          * Output:
 3429          * Return:
 3430          *******************************************************************************/
 3431          void Test_Afe_BaseRam(void)
 3432          {
 3433   1          UINT8 i;
 3434   1          UINT8 ucLen;
 3435   1          UINT16 usAddr;
 3436   1          UINT16 XRAM Buf[BASE_RAM_LEN];
 3437   1          
 3438   1          XSICKEN = 1;
 3439   1      
 3440   1          DBG_FLOW("\n\rAfe Base Ram Test is start");
 3441   1      
 3442   1          /* set ram buf as base ram: testram_sel = 0;*/
 3443   1          DrvAfeSelTaborRepRam(AREA_BASE_ORDER);
 3444   1      
 3445   1          ucLen  = 0xFF;
 3446   1          usAddr = BASE_RAM_START_ADDR;
 3447   1          Drv_XsiRead(pXSI0Regs,usAddr,Buf,ucLen,AFE_REG);
 3448   1          for (i = 0; i < ucLen; i++)
 3449   1          {
 3450   2              if (Buf[i] != 0x00)
 3451   2              {
 3452   3                  DBG_FLOW("\n\rBase_Buf[%02d] = 0x%04x",i,Buf[i]);
 3453   3              }
 3454   2          }
 3455   1      
C251 COMPILER V5.54.0.0,  FlowFactory                                                      26/05/17  20:21:08  PAGE 54  

 3456   1          usAddr += ucLen;
 3457   1          ucLen = 0xFF;
 3458   1          Drv_XsiRead(pXSI0Regs,usAddr,Buf,ucLen,AFE_REG);
 3459   1          for (i = 0; i < ucLen; i++)
 3460   1          {
 3461   2              if (Buf[i] != 0x00)
 3462   2              {
 3463   3                  DBG_FLOW("\n\rBase_Buf[%02d] = 0x%04x",i,Buf[i]);
 3464   3              }
 3465   2          }
 3466   1       
 3467   1          usAddr += ucLen;
 3468   1          ucLen = BASE_RAM_LEN - ucLen*2;
 3469   1          Drv_XsiRead(pXSI0Regs,usAddr,Buf,ucLen,AFE_REG);
 3470   1          for (i = 0; i < ucLen; i++)
 3471   1          {
 3472   2              if (Buf[i] != 0x00)
 3473   2              {
 3474   3                  DBG_FLOW("\n\rBase_Buf[%02d] = 0x%04x",i,Buf[i]);
 3475   3              }
 3476   2          }
 3477   1          DBG_FLOW("\n\r\n\rRead BaseRam is OK!");
 3478   1      
 3479   1          DBG_FLOW("\n\r\n\rWrite BaseRam is start!");
 3480   1          ucLen = 0xFF;
 3481   1          usAddr = BASE_RAM_START_ADDR;
 3482   1          for (i = 0; i < ucLen; i++)
 3483   1          {
 3484   2              usAddr++;
 3485   2              Test_AfeRegWrite(usAddr,0xFFFF,0x0000);
 3486   2          }
 3487   1      
 3488   1          usAddr = BASE_RAM_START_ADDR + ucLen;
 3489   1          ucLen = 0xFF;
 3490   1          for (i = 0; i < ucLen; i++)
 3491   1          {
 3492   2              usAddr++;
 3493   2              Test_AfeRegWrite(usAddr,0xFFFF,0x0000);
 3494   2          }
 3495   1      
 3496   1          
 3497   1          usAddr = BASE_RAM_START_ADDR + ucLen*2;
 3498   1          ucLen = BASE_RAM_LEN - ucLen*2;
 3499   1          for (i = 0; i < ucLen; i++)
 3500   1          {
 3501   2              usAddr++;
 3502   2              Test_AfeRegWrite(usAddr,0xFFFF,0x0000);
 3503   2          }
 3504   1          DBG_FLOW("\n\r\n\rWrite BaseRam is OK!");
 3505   1          DBG_FLOW("\n\rafe BaseRam test is end\n\r");
 3506   1          while(1);
 3507   1      }
 3508          
 3509          /*******************************************************************************
 3510          *   Name: Test_Afe_AccRam
 3511          *  Brief:
 3512          *  Input:
 3513          * Output:
 3514          * Return:
 3515          *******************************************************************************/
 3516          void Test_Afe_AccRam(void)
 3517          {
 3518   1          UINT8 i;
 3519   1          UINT8 ucLen;
 3520   1          UINT16 usAddr;
 3521   1          UINT16 XRAM Buf[ACC_RAM_LEN];
C251 COMPILER V5.54.0.0,  FlowFactory                                                      26/05/17  20:21:08  PAGE 55  

 3522   1      
 3523   1          XSICKEN = 1;
 3524   1      
 3525   1          DBG_FLOW("\n\rAfe Acc Ram Test");
 3526   1          
 3527   1          usAddr = ACC_RAM_START_ADDR;
 3528   1          ucLen  = ACC_RAM_LEN;
 3529   1          
 3530   1      #if TEST_ACC_H_RAM_EN
 3531   1          /* set ram buf as acc_h ram: */
 3532   1          DrvAfeSelACCRam(3);
 3533   1          Drv_XsiRead(pXSI0Regs,usAddr,Buf,ucLen,AFE_REG);
 3534   1          for (i = 0; i < ucLen; i++)
 3535   1          {
 3536   2              if (Buf[i] != 0x00)
 3537   2              {
 3538   3                  DBG_FLOW("\n\rAcc_Buf_h[%02d] = 0x%04x",i,Buf[i]);
 3539   3              }
 3540   2          }
 3541   1          DBG_FLOW("\n\r\n\rRead AccRam_H is OK!");
 3542   1      
 3543   1          DBG_FLOW("\n\r\n\rWrite AccRam_H is start!");
 3544   1          for (i = 0; i < ucLen; i++)
 3545   1          {        
 3546   2              Test_AfeRegWrite(usAddr,0x007F,0x0000);  //54bit
 3547   2              usAddr++;
 3548   2          }
 3549   1          DBG_FLOW("\n\r\n\rWrite AccRam_H is OK!");
 3550   1      #endif
 3551   1      
 3552   1      #if TEST_ACC_M_RAM_EN
 3553   1          /* set ram buf as acc_m ram:  */
 3554   1          DrvAfeSelACCRam(2);
 3555   1      
 3556   1          Drv_XsiRead(pXSI0Regs,usAddr,Buf,ucLen,AFE_REG);
 3557   1          for (i = 0; i < ucLen; i++)
 3558   1          {
 3559   2              if (Buf[i] != 0x00)
 3560   2              {
 3561   3                  DBG_FLOW("\n\rAcc_Buf_m[%02d] = 0x%04x",i,Buf[i]);
 3562   3              }
 3563   2          }
 3564   1          DBG_FLOW("\n\r\n\rRead AccRam_M is OK!");
 3565   1      
 3566   1          DBG_FLOW("\n\r\n\rWrite AccRam_M is start!");
 3567   1          usAddr = ACC_RAM_START_ADDR;
 3568   1          for (i = 0; i < ucLen; i++)
 3569   1          {
 3570   2              Test_AfeRegWrite(usAddr,0xFFFF,0x0000);
 3571   2              usAddr++;
 3572   2          }
 3573   1          DBG_FLOW("\n\r\n\rWrite AccRam_M is OK!");
 3574   1      #endif
 3575   1      
 3576   1      #if TEST_ACC_M2_RAM_EN
 3577   1          /* set ram buf as acc_m ram:  */
 3578   1          DrvAfeSelACCRam(1);
 3579   1      
 3580   1          Drv_XsiRead(pXSI0Regs,usAddr,Buf,ucLen,AFE_REG);
 3581   1          for (i = 0; i < ucLen; i++)
 3582   1          {
 3583   2              if (Buf[i] != 0x00)
 3584   2              {
 3585   3                  DBG_FLOW("\n\rAcc_Buf_m2[%02d] = 0x%04x",i,Buf[i]);
 3586   3              }
 3587   2          }
C251 COMPILER V5.54.0.0,  FlowFactory                                                      26/05/17  20:21:08  PAGE 56  

 3588   1          DBG_FLOW("\n\r\n\rRead AccRam_M2 is OK!");
 3589   1      
 3590   1          DBG_FLOW("\n\r\n\rWrite AccRam_M2 is start!");
 3591   1          usAddr = ACC_RAM_START_ADDR;
 3592   1          for (i = 0; i < ucLen; i++)
 3593   1          {
 3594   2              Test_AfeRegWrite(usAddr,0xFFFF,0x0000);
 3595   2              usAddr++;
 3596   2          }
 3597   1          DBG_FLOW("\n\r\n\rWrite AccRam_M2 is OK!");
 3598   1      #endif
 3599   1      #if TEST_ACC_L_RAM_EN
 3600   1          /* set ram buf as acc_l ram:  */
 3601   1          DrvAfeSelACCRam(0);
 3602   1      
 3603   1          Drv_XsiRead(pXSI0Regs,usAddr,Buf,ucLen,AFE_REG);
 3604   1          for (i = 0; i < ucLen; i++)
 3605   1          {
 3606   2              if (Buf[i] != 0x00)
 3607   2              {
 3608   3                  DBG_FLOW("\n\rAcc_Buf_l[%02d] = 0x%04x",i,Buf[i]);
 3609   3              }
 3610   2          }
 3611   1          DBG_FLOW("\n\r\n\rRead AccRam_L is OK!");
 3612   1      
 3613   1          DBG_FLOW("\n\r\n\rWrite AccRam_L is start!");
 3614   1          usAddr = ACC_RAM_START_ADDR;
 3615   1          for (i = 0; i < ucLen; i++)
 3616   1          {
 3617   2              Test_AfeRegWrite(usAddr,0xFFFF,0x0000);
 3618   2              usAddr++;
 3619   2          }
 3620   1          DBG_FLOW("\n\r\n\rWrite AccRam_L is OK!");
 3621   1          DBG_FLOW("\n\rAfe acc ram test is end");
 3622   1      #endif
 3623   1          while(1);
 3624   1      }
 3625          
 3626          
 3627          /*******************************************************************************
 3628          *   Name: Test_Afe_TabRam
 3629          *  Brief:
 3630          *  Input:
 3631          * Output:
 3632          * Return:
 3633          *******************************************************************************/
 3634          void Test_Afe_TabRam(void)
 3635          {
 3636   1          UINT8 i;
 3637   1          UINT8 ucLen;
 3638   1          UINT16 usAddr;
 3639   1          UINT16 XRAM Buf[TAB_RAM_LEN];
 3640   1      
 3641   1          usAddr = TAB_RAM_START_ADDR;
 3642   1          ucLen  = TAB_RAM_LEN;
 3643   1      
 3644   1          XSICKEN = 1;
 3645   1      
 3646   1          DBG_FLOW("\n\rAfe Tab Ram Test is start");
 3647   1          
 3648   1          /* set ram buf as tab ram: */
 3649   1          DrvAfeSelTaborRepRam(AREA_TBL_RAM);
 3650   1      
 3651   1          memset(Buf,0xff,TAB_RAM_LEN*2);
 3652   1          Drv_XsiRead(pXSI0Regs,usAddr,Buf,ucLen,AFE_REG);
 3653   1          for (i = 0; i < ucLen; i++)
C251 COMPILER V5.54.0.0,  FlowFactory                                                      26/05/17  20:21:08  PAGE 57  

 3654   1          {
 3655   2              if (Buf[i] != 0x00)
 3656   2              {
 3657   3                  DBG_FLOW("\n\rRam_Tab1[%02d] = 0x%04x",i,Buf[i]);
 3658   3              }
 3659   2          }
 3660   1          DBG_FLOW("\n\rRead Ram_Tab1 is ok!");
 3661   1      
 3662   1          usAddr += TAB_RAM_LEN;
 3663   1          memset(Buf,0xff,TAB_RAM_LEN*2);
 3664   1          Drv_XsiRead(pXSI0Regs,usAddr,Buf,ucLen,AFE_REG);
 3665   1          for (i = 0; i < ucLen; i++)
 3666   1          {
 3667   2              if (Buf[i] != 0x00)
 3668   2              {
 3669   3                  DBG_FLOW("\n\rRam_Tab2[%02d] = 0x%04x",i,Buf[i]);
 3670   3              }
 3671   2          }
 3672   1          DBG_FLOW("\n\rRead Ram_Tab2 is ok!");
 3673   1      
 3674   1          usAddr += TAB_RAM_LEN;
 3675   1          memset(Buf,0xff,TAB_RAM_LEN*2);
 3676   1          Drv_XsiRead(pXSI0Regs,usAddr,Buf,ucLen,AFE_REG);
 3677   1          for (i = 0; i < ucLen; i++)
 3678   1          {
 3679   2              if (Buf[i] != 0x00)
 3680   2              {
 3681   3                  DBG_FLOW("\n\rRam_Tab3[%02d] = 0x%04x",i,Buf[i]);
 3682   3              }
 3683   2          }
 3684   1          DBG_FLOW("\n\rRead Ram_Tab3 is ok!");
 3685   1      
 3686   1          usAddr += TAB_RAM_LEN;
 3687   1          memset(Buf,0xff,TAB_RAM_LEN*2);
 3688   1          Drv_XsiRead(pXSI0Regs,usAddr,Buf,ucLen,AFE_REG);
 3689   1          for (i = 0; i < ucLen; i++)
 3690   1          {
 3691   2              if (Buf[i] != 0x00)
 3692   2              {
 3693   3                  DBG_FLOW("\n\rRam_Tab4[%02d] = 0x%04x",i,Buf[i]);
 3694   3              }
 3695   2          }
 3696   1          DBG_FLOW("\n\rRead Ram_Tab4 is ok!");
 3697   1      
 3698   1      
 3699   1          DBG_FLOW("\n\r\n\rWrite Ram_Tab is start!");
 3700   1          usAddr = TAB_RAM_START_ADDR;
 3701   1          for (i = 0; i < ucLen; i++)
 3702   1          {
 3703   2              usAddr++;
 3704   2              Test_AfeRegWrite(usAddr,0xFFFF,0x0000);
 3705   2          }
 3706   1          DBG_FLOW("\n\r\n\rWrite Ram_Tab1 is OK!");
 3707   1          
 3708   1          usAddr = TAB_RAM_START_ADDR + TAB_RAM_LEN;
 3709   1          for (i = 0; i < ucLen; i++)
 3710   1          {
 3711   2              usAddr++;
 3712   2              Test_AfeRegWrite(usAddr,0xFFFF,0x0000);
 3713   2          }
 3714   1          DBG_FLOW("\n\r\n\rWrite Ram_Tab2 is OK!");
 3715   1      
 3716   1          usAddr = TAB_RAM_START_ADDR + TAB_RAM_LEN*2;
 3717   1          for (i = 0; i < ucLen; i++)
 3718   1          {
 3719   2              usAddr++;
C251 COMPILER V5.54.0.0,  FlowFactory                                                      26/05/17  20:21:08  PAGE 58  

 3720   2              Test_AfeRegWrite(usAddr,0xFFFF,0x0000);
 3721   2          }
 3722   1          DBG_FLOW("\n\r\n\rWrite Ram_Tab3 is OK!");
 3723   1      
 3724   1      
 3725   1          usAddr = TAB_RAM_START_ADDR + TAB_RAM_LEN*3;
 3726   1          for (i = 0; i < ucLen-1; i++)
 3727   1          {
 3728   2              usAddr++;
 3729   2              Test_AfeRegWrite(usAddr,0xFFFF,0x0000);
 3730   2          }
 3731   1          DBG_FLOW("\n\r\n\rWrite Ram_Tab4 is OK!");
 3732   1          DBG_FLOW("\n\rAfe Tab Ram is end");
 3733   1          while(1);
 3734   1      }
 3735          
 3736          /*******************************************************************************
 3737          *   Name: Test_AfeReg
 3738          *  Brief:
 3739          *  Input:
 3740          * Output:
 3741          * Return:
 3742          *******************************************************************************/
 3743          void Test_AfeReg(void)
 3744          {
 3745   1          UINT8 i;
 3746   1      //    UINT16 tmp,tmp1;
 3747   1          UINT16 XRAM Buf[AFE_REG_LEN];
 3748   1      
 3749   1          DBG_FLOW("\n\rafe Reg Test is start");
 3750   1          Drv_XsiInit();
 3751   1      #if 0
                   /* XSI_S_REG Read and Write Test */
                   tmp1 = Drv_XsiReadReg(pXSI0Regs,0,XSI_S_REG);
                   DBG_FLOW("\n\rXSI0_S_Reg: %04x",tmp1);
               
                   for (i = 0; i < 0x07; i++)
                   {
                       Drv_XsiWriteReg(pXSI0Regs,0,i,XSI_S_REG);
                       tmp = Drv_XsiReadReg(pXSI0Regs,0,XSI_S_REG);
                       if (tmp != i)
                       {
                           DBG_FLOW("\n\rError XSI0_S_Reg=%04x; i=%04x",tmp,i);
                           break;
                       }
                   }
                   Drv_XsiWriteReg(pXSI0Regs,0,tmp1,XSI_S_REG);
                   DBG_FLOW("\n\rXSI_S_Reg write is OK!\n\r");
               #endif
 3769   1          /* AFE_REG Read and Write Test */
 3770   1          DBG_FLOW("\n\rAfe Reg read and write:");
 3771   1          Drv_XsiRead(pXSI0Regs,0,Buf,AFE_REG_LEN,AFE_REG);
 3772   1          for (i = 0; i < AFE_REG_LEN; i++)
 3773   1          {
 3774   2              DBG_FLOW("\n\rreg[%02d] = 0x%04x",i,Buf[i]);
 3775   2          }
 3776   1      //    Test_AfeRegWrite(0,0xFFFF,0x0000);
 3777   1      
 3778   1          Test_AfeRegWrite(1,0x7FFF,0x0000);
 3779   1          Test_AfeRegWrite(2,0x07FF,0x0000);
 3780   1          Test_AfeRegWrite(3,0x00FF,0x0000);
 3781   1          Test_AfeRegWrite(4,0xFFFF,0x0000);
 3782   1          Test_AfeRegWrite(5,0xFFFF,0x0000);
 3783   1          Test_AfeRegWrite(6,0x007F,0x0000);
 3784   1          Test_AfeRegWrite(7,0x007F,0x0000);
 3785   1          Test_AfeRegWrite(8,0x0FFF,0x0000);
C251 COMPILER V5.54.0.0,  FlowFactory                                                      26/05/17  20:21:08  PAGE 59  

 3786   1          Test_AfeRegWrite(9,0xFFFF,0x0000);
 3787   1          Test_AfeRegWrite(10,0xFFFF,0x0000);
 3788   1          Test_AfeRegWrite(11,0xFFFF,0x0000);
 3789   1          Test_AfeRegWrite(12,0xFFFF,0x0000);
 3790   1          Test_AfeRegWrite(13,0x07FF,0x0000);
 3791   1          Test_AfeRegWrite(14,0x07FF,0x0000);
 3792   1          Test_AfeRegWrite(15,0x0FFF,0x0000);
 3793   1          Test_AfeRegWrite(16,0xFFFF,0x0000);
 3794   1          Test_AfeRegWrite(17,0x003F,0x0000);
 3795   1          Test_AfeRegWrite(18,0x03FF,0x0000);
 3796   1          Test_AfeRegWrite(19,0x03FF,0x0000);
 3797   1          Test_AfeRegWrite(20,0x03FF,0x0000);
 3798   1          Test_AfeRegWrite(21,0x03FF,0x0000);
 3799   1          Test_AfeRegWrite(22,0x03FF,0x0000);
 3800   1          Test_AfeRegWrite(23,0x03FF,0x0000);
 3801   1          Test_AfeRegWrite(24,0xFFFF,0x0000);
 3802   1          Test_AfeRegWrite(25,0x00FF,0x0000);
 3803   1          Test_AfeRegWrite(26,0x03FF,0x0000);
 3804   1          Test_AfeRegWrite(27,0x03FF,0x0000);
 3805   1          Test_AfeRegWrite(28,0x01FF,0x0000);
 3806   1          Test_AfeRegWrite(29,0x01FF,0x0000);
 3807   1          Test_AfeRegWrite(30,0x03FF,0x0000);
 3808   1          Test_AfeRegWrite(31,0x01FF,0x0000);
 3809   1          Test_AfeRegWrite(32,0x0FFF,0x4000); //bit12-14导致误扫描,必须固定配置。
 3810   1          Test_AfeRegWrite(33,0xFFFF,0x0000);
 3811   1          Test_AfeRegWrite(34,0x1FFF,0x0000);
 3812   1          Test_AfeRegWrite(35,0x1FFF,0x0000);
 3813   1          Test_AfeRegWrite(36,0x1FFF,0x0000);
 3814   1          Test_AfeRegWrite(37,0x03FF,0x0000);
 3815   1          Test_AfeRegWrite(38,0x03FF,0x0000);
 3816   1          Test_AfeRegWrite(39,0xFFFF,0x0000);
 3817   1          Test_AfeRegWrite(40,0x00FF,0x0000);
 3818   1          Test_AfeRegWrite(41,0xFFFF,0x0000);
 3819   1          Test_AfeRegWrite(42,0xFFFF,0x0000);
 3820   1          Test_AfeRegWrite(43,0xFFFF,0x0000);
 3821   1          Test_AfeRegWrite(44,0x002F,0x0000);
 3822   1          Test_AfeRegWrite(45,0x03FF,0x0000);
 3823   1          Test_AfeRegWrite(46,0xFFFF,0x0000);
 3824   1          Test_AfeRegWrite(47,0xFFFF,0x0000);
 3825   1          Test_AfeRegWrite(48,0xFFFF,0x0000);
 3826   1          Test_AfeRegWrite(49,0xFFFF,0x0000);
 3827   1          Test_AfeRegWrite(50,0xFFFF,0x0000);
 3828   1          Test_AfeRegWrite(51,0xFFFF,0x0000);
 3829   1          Test_AfeRegWrite(52,0xFFFF,0x0000);
 3830   1          Test_AfeRegWrite(53,0xFFFF,0x0000);
 3831   1          Test_AfeRegWrite(54,0x002F,0x0000);
 3832   1          Test_AfeRegWrite(55,0x03FF,0x0000);
 3833   1          Test_AfeRegWrite(56,0xFFFF,0x0000);
 3834   1          Test_AfeRegWrite(57,0xFFFF,0x0000);
 3835   1          Test_AfeRegWrite(58,0xFFFF,0x0000);
 3836   1          Test_AfeRegWrite(59,0xFFFF,0x0000);
 3837   1          Test_AfeRegWrite(60,0xFFFF,0x0000);
 3838   1          Test_AfeRegWrite(61,0xFFFF,0x0000);   
 3839   1          Test_AfeRegWrite(62,0xFFFF,0x0000);
 3840   1          Test_AfeRegWrite(63,0xFFFF,0x0000);   
 3841   1      
 3842   1          Test_AfeRegWrite(0x40,0xA010,0x0000); //64
 3843   1          Test_AfeRegWrite(0x41,0x0008,0x0000);
 3844   1          Test_AfeRegWrite(0x42,0x03FF,0x0000);
 3845   1          Test_AfeRegWrite(0x43,0xFFFF,0x0000);
 3846   1          Test_AfeRegWrite(0x44,0xFFFF,0x0000);
 3847   1          Test_AfeRegWrite(0x45,0x000F,0x0000);
 3848   1          Test_AfeRegWrite(0x46,0x0000,0x0000);
 3849   1          Test_AfeRegWrite(0x47,0x00FF,0x0000);
 3850   1          Test_AfeRegWrite(0x48,0x0FFF,0x0000);
 3851   1          Test_AfeRegWrite(0x49,0x0FFF,0x0000);
C251 COMPILER V5.54.0.0,  FlowFactory                                                      26/05/17  20:21:08  PAGE 60  

 3852   1          Test_AfeRegWrite(0x4A,0x0FFF,0x0000);
 3853   1          Test_AfeRegWrite(0x4B,0x0FFF,0x0000);
 3854   1          Test_AfeRegWrite(0x4C,0x0FFF,0x0000);
 3855   1          Test_AfeRegWrite(0x4D,0x0FFF,0x0000);
 3856   1          Test_AfeRegWrite(0x4E,0x00FF,0x0000);
 3857   1          Test_AfeRegWrite(0x4F,0x0FFF,0x0000);
 3858   1          Test_AfeRegWrite(0x50,0xFFFF,0x0000);
 3859   1          Test_AfeRegWrite(0x51,0xFFFF,0x0000);
 3860   1          Test_AfeRegWrite(0x52,0xFFFF,0x0000);
 3861   1          Test_AfeRegWrite(0x53,0xFFFF,0x0000);
 3862   1          Test_AfeRegWrite(0x54,0xFFFF,0x0000);
 3863   1          Test_AfeRegWrite(0x55,0xFFFF,0x0000);
 3864   1          Test_AfeRegWrite(0x56,0xFFFF,0x0000);
 3865   1          Test_AfeRegWrite(0x57,0xFFFF,0x0000);
 3866   1      
 3867   1      
 3868   1          DBG_FLOW("\n\rAFE_Reg read and write is OK!\n\r");  
 3869   1          while(1);
 3870   1      }
 3871          
 3872          /*******************************************************************************
 3873          *   Name: AfeModeSelInit
 3874          *  Brief:
 3875          *  Input:
 3876          * Output:
 3877          * Return:
 3878          *******************************************************************************/
 3879          void AfeModeSelInit(void)
 3880          {
 3881   1          if ((DrvAsmGetSta()&LCD_RUN_STA) == 0)
 3882   1          {
 3883   2              ucAfeRunMode = TP_FREE_RUN_MODE;
 3884   2              DBG_FLOW("\nFree run Mode");
 3885   2          }
 3886   1          else if (DrvAsmGetSta()&LCD_RUN_STA)
 3887   1          {
 3888   2      //        if (pAsmRegs->usAsmIntSta&LCD_GLANCE_STA)
 3889   2      //        {
 3890   2      //            ucAfeRunMode = TP_GLANCE_RUN_MODE;
 3891   2      //            DBG_FLOW("\nGlance Mode");
 3892   2      //        }
 3893   2      //        else
 3894   2              {
 3895   3                   if (g_ucAfeScanMode == TP_60HZ_RUN_MODE)
 3896   3                   {
 3897   4                       ucAfeRunMode = TP_60HZ_RUN_MODE;
 3898   4                       DBG_FLOW("\nNomal   60HZ ");
 3899   4      //                 TP_120HZ_REQ = 0x00;                           
 3900   4                   }
 3901   3                   else
 3902   3                   {
 3903   4                       ucAfeRunMode = TP_120HZ_RUN_MODE;
 3904   4      //                 TP_120HZ_REQ = 0x01;
 3905   4                       DBG_FLOW("\nNomal   120Hz ");
 3906   4                   }
 3907   3              }
 3908   2          }
 3909   1          DBG_FLOW("\nlcd run: %04x",DrvAsmGetSta());              
 3910   1      }
 3911          
 3912          /*******************************************************************************
 3913          *   Name: FlowFactory
 3914          *  Brief: Factory flow, get raw touching data, then report the data to host for
 3915          *         more processing.
 3916          *  Input: None
 3917          * Output: None
C251 COMPILER V5.54.0.0,  FlowFactory                                                      26/05/17  20:21:08  PAGE 61  

 3918          * Return: None
 3919          *******************************************************************************/
 3920          void FlowFactory(void)
 3921          {
 3922   1          UINT8 ucFlag;
 3923   1          
 3924   1          ucFlag = 1;
 3925   1      
 3926   1          Afe_Clk_Init();
 3927   1          
 3928   1      //    Test_AfeReg();
 3929   1      //    Test_Afe_TabRam();
 3930   1      //    Test_Afe_AccRam();
 3931   1      //    Test_Afe_BaseRam();
 3932   1      //    TestXbus(); 
 3933   1          Afe_Init();
 3934   1      
 3935   1          Test_DebugOut();
 3936   1      
 3937   1        DrvXbus_WriteInitCode();
 3938   1      
 3939   1          g_RegHead.bits.ucDataReadToggle = 1;
 3940   1      
 3941   1          while(1)
 3942   1          {
 3943   2              if (g_State == SS_FACTORY)
 3944   2              {
 3945   3                  /* Check if need to start raw data collect */
 3946   3                  if (g_RegHead.bits.ucDataReadToggle)
 3947   3                  {
 3948   4                      if (ucFlag == 1)
 3949   4                      {
 3950   5                          AfeModeSelInit();
 3951   5                          ucFlag = 0;
 3952   5      
 3953   5      #if TEST_LCD_CHANGED                  
                                   Afe_LcdRun_Changed();
               #endif
 3956   5      
 3957   5      #if TEST_STANDBY_WAKEUP_ALL
                                   Afe_ALL_WakeUpStandby();
               #endif
 3960   5      
 3961   5      #if TEST_LCD_RUN_WAKEUP
                                   Afe_LcdRunWakeUp_Test();
               #endif
 3964   5      #if TEST_LCD_DSTB_WAKEUP
                                   Afe_LcdDSTBWakeUp_Test();
               #endif
 3967   5      #if TEST_LCD_WAKE_UP_STANDBY
                                   Afe_Lcd_WakeUp_StandBy();
               #endif
 3970   5      #if TEST_LCD_LVDESD_WAKEUP
                                   Afe_LVDESDWakeUp_Stop();
               #endif
 3973   5      #if TEST_ONE_CHANNEL_ADC
                                   Afe_TestOneChannelAdc();
               #endif
 3976   5                      }
 3977   4                      switch(ucAfeRunMode)
 3978   4                      {
 3979   5                          case TP_FREE_RUN_MODE:
 3980   5                          {
 3981   6                              DBG_FLOW("\nfree run");
 3982   6                              //Afe_Free_Run();
 3983   6      #if TEST_FREERUN_MONITOR                        
C251 COMPILER V5.54.0.0,  FlowFactory                                                      26/05/17  20:21:08  PAGE 62  

                                       Afe_Free_Run_Monitor();
               #endif
 3986   6                              //Afe_Free_Run_RTC_Monitor();
 3987   6                              //Afe_Free_Run_H_CB();
 3988   6                              Mcap_Free_Run();
 3989   6                              break;
 3990   6                          }
 3991   5                          case TP_60HZ_RUN_MODE:
 3992   5                          {
 3993   6                              DBG_FLOW("\n60Hz run");
 3994   6                              //Afe_60Hz_Run();
 3995   6                              //Afe_60Hz_H_Clb();
 3996   6                              Mcap_60Hz_Run();
 3997   6                              break;
 3998   6                          }
 3999   5                          case TP_120HZ_RUN_MODE:
 4000   5                          {
 4001   6                              DBG_FLOW("\n120Hz run");
 4002   6                           
 4003   6                              //Afe_120Hz_Run(); 
 4004   6      #if TEST_120HZ_MONTIOR                        
                                       Afe_120Hz_Run_Monitor();
               #endif
 4007   6                              //Afe_120Hz_H_Clb();
 4008   6                              Mcap_120Hz_Run();
 4009   6                              //Afe_120Hz_Run_RTC_Monitor();
 4010   6                              //Afe_60Hz_120Hz_Changed();
 4011   6      
 4012   6                              break;
 4013   6                          }
 4014   5                          default:
 4015   5                          {
 4016   6                              break;
 4017   6                          }
 4018   5                   
 4019   5                      }
 4020   4                  }
 4021   3              }
 4022   2      
 4023   2          }  
 4024   1      }
 4025          


Module Information          Static   Overlayable
------------------------------------------------
  code size            =         2     ------
  ecode size           =     13764     ------
  data size            =    ------     ------
  idata size           =    ------     ------
  pdata size           =    ------     ------
  xdata size           =    ------     ------
  xdata-const size     =    ------     ------
  edata size           =      6034       4790
  bit size             =         1          1
  ebit size            =    ------     ------
  bitaddressable size  =    ------     ------
  ebitaddressable size =    ------     ------
  far data size        =    ------     ------
  huge data size       =    ------     ------
  const size           =    ------     ------
  hconst size          =      2891     ------
End of Module Information.


C251 COMPILATION COMPLETE.  1 WARNING(S),  0 ERROR(S)
