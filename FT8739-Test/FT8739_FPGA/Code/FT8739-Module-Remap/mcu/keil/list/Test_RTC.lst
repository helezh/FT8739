C251 COMPILER V5.54.0.0,  Test_RTC                                                         14/04/17  16:04:04  PAGE 1   


C251 COMPILER V5.54.0.0, COMPILATION OF MODULE Test_RTC
OBJECT MODULE PLACED IN .\obj\Test_RTC.obj
COMPILER INVOKED BY: D:\Program Files (x86)\keil\C251\BIN\C251.EXE ..\..\src\source\task\Test_RTC.c XSMALL ROM(HUGE) OPT
                    -IMIZE(9,SPEED) BROWSE INCDIR(..\..\src\include;..\..\src\include\Debug;..\..\src\include\Drv;..\..\src\include\task) STR
                    -ING(FAR) DEBUG PRINT(.\list\Test_RTC.lst) TABS(2) OBJECT(.\obj\Test_RTC.obj) 

stmt  level    source

    1          /*******************************************************************************
    2          * Copyright (C) 2013-2014, FocalTech Systems (R)，All Rights Reserved.
    3          *
    4          * File Name: Test_RTC.c
    5          *
    6          *    Author: xinkunpeng
    7          *
    8          *   Created: 2014-04-18
    9          *
   10          *  Abstract:
   11          *
   12          * Reference:
   13          *******************************************************************************/
   14          
   15          /*******************************************************************************
   16          * 1.Included header files
   17          *******************************************************************************/
   18          #include "Test_RTC.h"
   19          
   20          #if _TEST_RTC_EN
   21           
   22          /*******************************************************************************
   23          * 2.Private constant and macro definitions using #define
   24          *******************************************************************************/
   25          /* RTC */
   26          #define RTC_MS        32
   27          #define RTC_N_MS     (RTC_MS*99)//100ms
   28          
   29          /*
   30           * Normal   :此时CPU启动RTC，RTC产生一次定时中断，计时时间与计数Counter相关
   31           * Slot     :此时CPU启动RTC，若打开wake_sub_en，则RTC会产生slot_num+1个中断给CPU Cancel
   32           * Auto     :此时CPU启动一次RTC，产生一次RTC中断给CPU，产生无限次中断给ASM，
   33                       直到CPU CLR RTC
   34           * LCD Start:此时RTC会根据LCD信号启动，在Counter中间会自动屏蔽LCD的start
   35                       信号
   36          */
   37          /*
   38           * 问题点：
   39           * 1.eint1中不做RTC_CLR也不会导致一直停在eint1中断中不出来，配置成small或者big int均一样
   40           * 2.RTC打印出来的定时时间与设定时间不一样，设定时间100ms，实际出来时间是66ms
   41          */
   42          //RTC MODE 0-Normal,1-Slot,2-Auto,3-Lcd Start
   43          #define RTC_MODE    0
   44          
   45          /* time0 */
   46          #define T0MODE                            0x02    //高四位为T1,低四位为T0
   47          #define IRQTIME0_VALUE                    1       //(MS)
   48          //#define IRQTIME0_LOAD()                   TMOD|=T0MODE;TH0=IRQTIME0_VALUE;TL0=0 old
   49          #define IRQTIME0_LOAD()                   TMOD|=T0MODE;TH0=IRQTIME0_VALUE;TL0=0
   50          
   51          #define TEST_RTC_WK                       0//0:不测试rtc wk；1 测试rtc wk
   52          #define INT1_TRI_MODE                     0// 0:LOW level triggered 1:falling edge
   53          
   54          //#define AUTO_MODE                         1//0:不开启Auto_mode  1:开启Auto_Mode
   55          #define RTC_SLOT_NUM                      9
   56          #define RTC_SLOT_NUM_NONE                 0
   57          #define TEST_WAKE_EN_SUB                  0
C251 COMPILER V5.54.0.0,  Test_RTC                                                         14/04/17  16:04:04  PAGE 2   

   58          
   59          //设置LCD Start信号源--0--Vstart,1--Vmid;2--Vend;3--Vblank
   60          #define LCD_START_SRC   0
   61          
   62          //以下三种模式最多只能进入一种
   63          #define IDLE_MODE                         0//0:不进入idle   1:进入idle
   64          #define STANDBY_MODE                      0//0:不进入standy 1:进入standy
   65          #define STOP_MODE                         0//0:不进入stop   1:进入stop
   66          
   67          /*******************************************************************************
   68          * 3.Private enumerations, structures and unions using typedef
   69          *******************************************************************************/
   70          
   71          /*******************************************************************************
   72          * 4.Static variables
   73          *******************************************************************************/
   74          UINT8 g_nWKsrc     = 0x00;
   75          BOOLEAN g_bWKsrcOut = 1;
   76          BOOLEAN g_bRtcFlag  = 0;
   77          
   78          UINT16 m_usCnt = 0;
   79          /*******************************************************************************
   80          * 5.Global variable or extern global variabls/functions
   81          *******************************************************************************/
   82          
   83          /*******************************************************************************
   84          * 6.Static function prototypes
   85          *******************************************************************************/
   86          
   87          
   88          /*******************************************************************************
   89          *   Name:  DrvRTCInit
   90          *  Brief:  RTC初始化
   91          *          1.时钟是固定32K, 1秒32000次，1ms是32次 = 0x20
   92          *          2.计数器为16位，--到0，产生中断
   93          *          3.最大定时时间: t = 0x10000/0x20 = 65536/32 = 2048ms
   94          *  Input:
   95          * Output:
   96          * Return:
   97          *******************************************************************************/
   98          void DrvRTCInit(void)
   99          {
  100   1          // 32K时钟使能
  101   1          CLK_WP = 1;
  102   1          EN_32K = 1;
  103   1          CKEN_32KRTC = 1;
  104   1          
  105   1          // rtc clk enable
  106   1          RTCCKEN = 1;
  107   1      
  108   1          // clear rtc
  109   1          RTC_WP  = 1;
  110   1          RTC_CLR = 1;
  111   1          //DelayMs(100);
  112   1      
  113   1          // 设置RTC计数时间
  114   1          RTCIVH  = RTC_N_MS>>8;
  115   1          RTCIVL  = RTC_N_MS;
  116   1      
  117   1          //Normal mode
  118   1          #if (RTC_MODE == 0)
  119   1          RTC_AUTO_MODE = 0;
  120   1          LCD_START_EN  = 0;
  121   1          #endif
  122   1      
  123   1      #if 0
C251 COMPILER V5.54.0.0,  Test_RTC                                                         14/04/17  16:04:04  PAGE 3   

                   //Slot mode
                   #if (RTC_MODE == 1)
               //    RTCSLN          = RTC_SLOT_NUM;
                   RTC_AUTO_MODE   = 0;
                   LCD_START_EN    = 0;
                   #endif
               #endif
  131   1      
  132   1          //Auto mode
  133   1          #if (RTC_MODE == 2)
                   RTC_AUTO_MODE   = 1;
                   LCD_START_EN    = 0;
                   #endif
  137   1      
  138   1          //LCD Start mode
  139   1          #if (RTC_MODE == 3)
                   #if (LCD_START_SRC == 0)
                   RTCCON1 |= 0x00;
                   #elif (LCD_START_SRC == 1)
                   RTCCON1 |= 0x02;
                   #elif (LCD_START_SRC == 2)
                   RTCCON1 |= 0x04;
                   #elif (LCD_START_SRC == 3)
                   RTCCON1 |= 0x06;
                   #endif
                   RTC_AUTO_MODE = 0;
                   LCD_START_EN = 1;
                   #endif
  152   1      
  153   1          #if TEST_RTC_WK
                   RTC_CNT_WKEN = 1;  // RTC wake en  
                   #endif
  156   1      
  157   1          //RTC中断使能
  158   1          RTC_INT_EN_CPU = 1;
  159   1      
  160   1      #if 0
                   //RTC中断作为中断0
                   #if TEST_WAKE_EN_SUB
                   RTC_WKEN_SUB = 1;
                   RTC_WKEN     = 0;
                   RTCSLN       = RTC_SLOT_NUM;
                   #else
                   RTC_WKEN     = 1;  // select rtc  
                   RTC_WKEN_SUB = 0;
                   RTCSLN = RTC_SLOT_NUM_NONE;    
                   #endif
               #endif
  172   1       
  173   1          DBG_RTC("\nRTC Interval:%dms",RTC_N_MS/RTC_MS);         // 1.8ms@115200bps total 19 character 100us p
             -er character
  174   1          DBG_RTC("\nRTC_IVH:%02X,RTC_IVL:%02X",RTCIVH,RTCIVL);
  175   1          DBG_RTC("\ninit RTC OK!");
  176   1          DelayMs(10);
  177   1      
  178   1      }
  179          
  180          /*******************************************************************************
  181          *   Name:
  182          *  Brief:
  183          *  Input:
  184          * Output:
  185          * Return: INT0中断初始化函数
  186          *******************************************************************************/
  187          void ExternInt0Init(void)
  188          {
C251 COMPILER V5.54.0.0,  Test_RTC                                                         14/04/17  16:04:04  PAGE 4   

  189   1          IT0   = 0;   // 0:LOW level triggered 1:falling edge
  190   1      
  191   1          IPL0  = 0;
  192   1          IPH0  = 0;
  193   1      
  194   1          IPLX0 = 1;
  195   1          IPHX0 = 1;  //中断0优先级必须最高
  196   1      
  197   1          EX0   = 1;
  198   1      }
  199          
  200          /*******************************************************************************
  201          *   Name: DrvSysTimer0_Init
  202          *  Brief: 定时1ms
  203          *  Input:
  204          * Output:
  205          * Return: timer0 定时器初始化函数
  206          *******************************************************************************/
  207          void DrvSysTimer0_Init(void)
  208          {
  209   1          TR0 = 0;     /* Stop Timer Counter */
  210   1          IRQTIME0_LOAD();    //1//1ms interval
  211   1          
  212   1          TR0 = 1;
  213   1          ET0 = 1;     // enable timer interrupt
  214   1      }
  215          
  216          /*******************************************************************************
  217          *   Name:
  218          *  Brief:
  219          *  Input:
  220          * Output:
  221          * Return: INT1中断初始化函数
  222          *******************************************************************************/
  223          void ExternInt1Init(void)
  224          {
  225   1          IT1 = INT1_TRI_MODE;   // 0:LOW level triggered 1:falling edge
  226   1          IPHX1 = 1;
  227   1          IPLX1 = 1;
  228   1          EX1   = 1;       
  229   1          EA    = 1;
  230   1      }
  231          
  232          /*******************************************************************************
  233          *   Name:
  234          *  Brief:
  235          *  Input:
  236          * Output:
  237          * Return: INT0中断响应函数
  238          *******************************************************************************/
  239          void Exint0_IRQHandler(void) interrupt 0
  240          {
  241   1          if (g_bWKsrcOut)
  242   1          {
  243   2              g_nWKsrc = IWKSTA;
  244   2              g_bWKsrcOut = FALSE;
  245   2          }
  246   1          g_bRtcFlag = TRUE;
  247   1          if(RTC_CNT_INT)
  248   1          {
  249   2              RTC_CNT_WKEN = 0;
  250   2              DBG_FLOW("\n\rrtc int0");
  251   2          }
  252   1      }
  253          
  254          /*******************************************************************************
C251 COMPILER V5.54.0.0,  Test_RTC                                                         14/04/17  16:04:04  PAGE 5   

  255          *   Name:
  256          *  Brief:
  257          *  Input:
  258          * Output:
  259          * Return: timer0 定时器中断响应函数
  260          *******************************************************************************/
  261          void Timer0_IRQHandler(void) interrupt  1
  262          {
  263   1          m_usCnt++;
  264   1      }
  265          
  266          /*******************************************************************************
  267          *   Name:
  268          *  Brief:
  269          *  Input:
  270          * Output:
  271          * Return: INT1中断响应函数.
  272          *******************************************************************************/
  273          void Exint1_IRQHandler(void) interrupt 2
  274          {   
  275   1          P0_2 = 0;
  276   1          //如果是在AUTO模式，则不清rtc，否则一定要清RTC，不然会一直在中断中出不去
  277   1      #if !(RTC_MODE == 2)
  278   1          while(RTC_START_STA == 0);
  279   1          RTC_WP  = 1;
  280   1          RTC_CLR = 1;
  281   1      #endif
  282   1      
  283   1          DBG_FLOW("\n\rrtc int1");
  284   1      
  285   1          g_bRtcFlag = TRUE;
  286   1      
  287   1      #if TEST_RTC_WK
                   RTC_CNT_WKEN = 1;
               #endif
  290   1      }
  291          
  292          /*******************************************************************************
  293          *   Name: Test_RTC
  294          *  Brief:
  295          *  Input:
  296          * Output:
  297          * Return:
  298          *******************************************************************************/
  299          void Test_RTC(void)
  300          {
  301   1          DrvSysTimer0_Init();
  302   1          DrvRTCInit();
  303   1          ExternInt1Init();
  304   1      
  305   1          #if TEST_RTC_WK
                   ExternInt0Init();
                   #endif
  308   1      
  309   1          // clear rtc
  310   1          RTC_WP  = 1;
  311   1          RTC_CLR = 1;  
  312   1      
  313   1          // RTC Start
  314   1          RTC_WP    = 1;
  315   1          RTC_START = 1;
  316   1      
  317   1          P0_2 = 1;
  318   1      
  319   1          while (1)
  320   1          {      
C251 COMPILER V5.54.0.0,  Test_RTC                                                         14/04/17  16:04:04  PAGE 6   

  321   2              g_bRtcFlag = FALSE;
  322   2              g_bWKsrcOut = 1;
  323   2              m_usCnt = 0;
  324   2              // RTC Start
  325   2              //RTC_WP    = 1;
  326   2              //RTC_START = 1;
  327   2              
  328   2              #if 0
                       if(m_usCnt = 10)
                       {
                           LCD_START_EN = 0;
                       }
                       else if(m_usCnt = 20)
                       {
                           LCD_START_EN = 1;
                       }
                       #endif
  338   2      
  339   2              //idle_mode
  340   2              #if  IDLE_MODE
                       DBG_RTC("\n\rjoin in Idle");
                       DelayMs(50);
                       DrvSysPowerIdle();
                       DBG_RTC("\n\rexit Idle");        
                       #endif
  346   2      
  347   2              //standby_mode
  348   2              #if STANDBY_MODE
                       DBG_RTC("\n\rjoin in Standby");
                       DelayMs(50);    
                       DrvSysPowerStandby();
                       DBG_RTC("\n\rexit Standby");
                       #endif
  354   2              
  355   2              //stop_mode
  356   2              #if STOP_MODE
                       DBG_RTC("\n\rjoin in Stop");
                       DelayMs(50);        
                       DrvSysPowerStop();
                       DBG_RTC("\n\rexit Stop");        
                       #endif
  362   2              
  363   2              while (!g_bRtcFlag);
  364   2              DBG_RTC("\nm_usCnt=%dms",m_usCnt);   
  365   2              DelayMs(10);
  366   2              
  367   2              if (g_bRtcFlag && g_bWKsrcOut == FALSE)
  368   2              {
  369   3                  DBG_RTC("\n\rWK src:%x",g_nWKsrc);
  370   3              }
  371   2          }
  372   1      }
  373          #endif
  374          
  375          
  376          


Module Information          Static   Overlayable
------------------------------------------------
  code size            =        16     ------
  ecode size           =       195     ------
  data size            =    ------     ------
  idata size           =    ------     ------
  pdata size           =    ------     ------
  xdata size           =    ------     ------
  xdata-const size     =    ------     ------
C251 COMPILER V5.54.0.0,  Test_RTC                                                         14/04/17  16:04:04  PAGE 7   

  edata size           =         3     ------
  bit size             =         2     ------
  ebit size            =    ------     ------
  bitaddressable size  =    ------     ------
  ebitaddressable size =    ------     ------
  far data size        =    ------     ------
  huge data size       =    ------     ------
  const size           =    ------     ------
  hconst size          =        11     ------
End of Module Information.


C251 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
